##[[
if not MINIAUDIO_NO_IMPL then
  cdefine 'MA_API static'
  cdefine 'MINIAUDIO_IMPLEMENTATION'
end
cinclude 'miniaudio.h'
cinclude 'miniaudio_engine.h'
if ccinfo.is_linux then
  linklib 'dl'
  cflags '-pthread'
elseif ccinfo.is_windows then
  linklib 'ole32'
end
]]
## if ccinfo.is_windows then
global ma_thread: type = @pointer
global ma_mutex: type = @pointer
global ma_event: type = @pointer
global ma_semaphore: type = @pointer
## else
global __pthread_internal_list: type <cimport, forwarddecl> = @record{}
global __pthread_internal_list: type <cimport, nodecl> = @record{
  __prev: *__pthread_internal_list,
  __next: *__pthread_internal_list
}
global __pthread_list_t: type = @__pthread_internal_list
global __pthread_mutex_s: type <cimport, nodecl> = @record{
  __lock: cint,
  __count: cuint,
  __owner: cint,
  __nusers: cuint,
  __kind: cint,
  __spins: cshort,
  __elision: cshort,
  __list: __pthread_list_t
}
global __pthread_cond_s: type <cimport, nodecl> = @record{
  __unnamed1: union{
    __wseq: culonglong,
    __wseq32: record{
      __low: cuint,
      __high: cuint
    }
  },
  __unnamed2: union{
    __g1_start: culonglong,
    __g1_start32: record{
      __low: cuint,
      __high: cuint
    }
  },
  __g_refs: [2]cuint,
  __g_size: [2]cuint,
  __g1_orig_size: cuint,
  __wrefs: cuint,
  __g_signals: [2]cuint
}
global pthread_mutex_t: type <cimport, nodecl> = @union{
  __data: __pthread_mutex_s,
  __size: [40]cchar,
  __align: clong
}
global pthread_cond_t: type <cimport, nodecl> = @union{
  __data: __pthread_cond_s,
  __size: [48]cchar,
  __align: clonglong
}
global ma_thread: type = @culong
global ma_mutex: type = @pthread_mutex_t
global ma_event: type <cimport, nodecl> = @record{
  value: uint32,
  lock: pthread_mutex_t,
  cond: pthread_cond_t
}
global ma_semaphore: type <cimport, nodecl> = @record{
  value: cint,
  lock: pthread_mutex_t,
  cond: pthread_cond_t
}
## end
global ma_bool8: type = @cuchar
global ma_bool32: type = @cuint
global ma_handle: type = @pointer
global ma_ptr: type = @pointer
global ma_proc: type <cimport, nodecl> = @function()
global ma_context: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device: type <cimport, nodecl, forwarddecl> = @record{}
global ma_result: type = @cint
global ma_stream_format: type <cimport, nodecl, using> = @enum(cint){
  ma_stream_format_pcm = 0
}
global ma_stream_layout: type <cimport, nodecl, using> = @enum(cint){
  ma_stream_layout_interleaved = 0,
  ma_stream_layout_deinterleaved = 1
}
global ma_dither_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_dither_mode_none = 0,
  ma_dither_mode_rectangle = 1,
  ma_dither_mode_triangle = 2
}
global ma_format: type <cimport, nodecl, using> = @enum(cint){
  ma_format_unknown = 0,
  ma_format_u8 = 1,
  ma_format_s16 = 2,
  ma_format_s24 = 3,
  ma_format_s32 = 4,
  ma_format_f32 = 5,
  ma_format_count = 6
}
global ma_standard_sample_rate: type <cimport, nodecl, using> = @enum(cint){
  ma_standard_sample_rate_48000 = 48000,
  ma_standard_sample_rate_44100 = 44100,
  ma_standard_sample_rate_32000 = 32000,
  ma_standard_sample_rate_24000 = 24000,
  ma_standard_sample_rate_22050 = 22050,
  ma_standard_sample_rate_88200 = 88200,
  ma_standard_sample_rate_96000 = 96000,
  ma_standard_sample_rate_176400 = 176400,
  ma_standard_sample_rate_192000 = 192000,
  ma_standard_sample_rate_16000 = 16000,
  ma_standard_sample_rate_11025 = 11250,
  ma_standard_sample_rate_8000 = 8000,
  ma_standard_sample_rate_352800 = 352800,
  ma_standard_sample_rate_384000 = 384000,
  ma_standard_sample_rate_min = 8000,
  ma_standard_sample_rate_max = 384000,
  ma_standard_sample_rate_count = 14
}
global ma_channel_mix_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_channel_mix_mode_rectangular = 0,
  ma_channel_mix_mode_simple = 1,
  ma_channel_mix_mode_custom_weights = 2,
  ma_channel_mix_mode_planar_blend = 0,
  ma_channel_mix_mode_default = 0
}
global ma_standard_channel_map: type <cimport, nodecl, using> = @enum(cint){
  ma_standard_channel_map_microsoft = 0,
  ma_standard_channel_map_alsa = 1,
  ma_standard_channel_map_rfc3551 = 2,
  ma_standard_channel_map_flac = 3,
  ma_standard_channel_map_vorbis = 4,
  ma_standard_channel_map_sound4 = 5,
  ma_standard_channel_map_sndio = 6,
  ma_standard_channel_map_webaudio = 3,
  ma_standard_channel_map_default = 0
}
global ma_performance_profile: type <cimport, nodecl, using> = @enum(cint){
  ma_performance_profile_low_latency = 0,
  ma_performance_profile_conservative = 1
}
global ma_allocation_callbacks: type <cimport, nodecl> = @record{
  pUserData: pointer,
  onMalloc: function(csize, pointer): pointer,
  onRealloc: function(pointer, csize, pointer): pointer,
  onFree: function(pointer, pointer)
}
global ma_lcg: type <cimport, nodecl> = @record{
  state: int32
}
global ma_thread_priority: type <cimport, nodecl, using> = @enum(cint){
  ma_thread_priority_idle = -5,
  ma_thread_priority_lowest = -4,
  ma_thread_priority_low = -3,
  ma_thread_priority_normal = -2,
  ma_thread_priority_high = -1,
  ma_thread_priority_highest = 0,
  ma_thread_priority_realtime = 1,
  ma_thread_priority_default = 0
}
global ma_spinlock: type <cimport, nodecl, cincomplete> = @record{}
global ma_thread: type <cimport, nodecl, cincomplete> = @record{}
global ma_mutex: type <cimport, nodecl, cincomplete> = @record{}
global ma_event: type <cimport, nodecl, cincomplete> = @record{}
global ma_semaphore: type <cimport, nodecl, cincomplete> = @record{}
global function ma_version(pMajor: *uint32, pMinor: *uint32, pRevision: *uint32) <cimport, nodecl> end
global function ma_version_string(): cstring <cimport, nodecl> end
global ma_log_callback_proc: type <cimport, nodecl> = @function(pointer, uint32, cstring)
global ma_log_callback: type <cimport, nodecl> = @record{
  onLog: ma_log_callback_proc,
  pUserData: pointer
}
global function ma_log_callback_init(onLog: ma_log_callback_proc, pUserData: pointer): ma_log_callback <cimport, nodecl> end
global ma_log: type <cimport, nodecl> = @record{
  callbacks: [4]ma_log_callback,
  callbackCount: uint32,
  allocationCallbacks: ma_allocation_callbacks,
  lock: ma_mutex
}
global function ma_log_init(pAllocationCallbacks: *ma_allocation_callbacks, pLog: *ma_log): ma_result <cimport, nodecl> end
global function ma_log_uninit(pLog: *ma_log) <cimport, nodecl> end
global function ma_log_register_callback(pLog: *ma_log, callback: ma_log_callback): ma_result <cimport, nodecl> end
global function ma_log_unregister_callback(pLog: *ma_log, callback: ma_log_callback): ma_result <cimport, nodecl> end
global function ma_log_post(pLog: *ma_log, level: uint32, pMessage: cstring): ma_result <cimport, nodecl> end
global function ma_log_postv(pLog: *ma_log, level: uint32, pFormat: cstring, args: cvalist): ma_result <cimport, nodecl> end
global function ma_log_postf(pLog: *ma_log, level: uint32, pFormat: cstring, ...: cvarargs): ma_result <cimport, nodecl> end
global ma_biquad_coefficient: type <cimport, nodecl> = @union{
  f32: float32,
  s32: int32
}
global ma_biquad_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: float64,
  b1: float64,
  b2: float64,
  a0: float64,
  a1: float64,
  a2: float64
}
global function ma_biquad_config_init(format: ma_format, channels: uint32, b0: float64, b1: float64, b2: float64, a0: float64, a1: float64, a2: float64): ma_biquad_config <cimport, nodecl> end
global ma_biquad: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: ma_biquad_coefficient,
  b1: ma_biquad_coefficient,
  b2: ma_biquad_coefficient,
  a1: ma_biquad_coefficient,
  a2: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient,
  r2: [32]ma_biquad_coefficient
}
global function ma_biquad_init(pConfig: *ma_biquad_config, pBQ: *ma_biquad): ma_result <cimport, nodecl> end
global function ma_biquad_reinit(pConfig: *ma_biquad_config, pBQ: *ma_biquad): ma_result <cimport, nodecl> end
global function ma_biquad_process_pcm_frames(pBQ: *ma_biquad, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_biquad_get_latency(pBQ: *ma_biquad): uint32 <cimport, nodecl> end
global ma_lpf1_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_lpf2_config: type = @ma_lpf1_config
global function ma_lpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_lpf1_config <cimport, nodecl> end
global function ma_lpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_lpf2_config <cimport, nodecl> end
global ma_lpf1: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient
}
global function ma_lpf1_init(pConfig: *ma_lpf1_config, pLPF: *ma_lpf1): ma_result <cimport, nodecl> end
global function ma_lpf1_reinit(pConfig: *ma_lpf1_config, pLPF: *ma_lpf1): ma_result <cimport, nodecl> end
global function ma_lpf1_process_pcm_frames(pLPF: *ma_lpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf1_get_latency(pLPF: *ma_lpf1): uint32 <cimport, nodecl> end
global ma_lpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_lpf2_init(pConfig: *ma_lpf2_config, pLPF: *ma_lpf2): ma_result <cimport, nodecl> end
global function ma_lpf2_reinit(pConfig: *ma_lpf2_config, pLPF: *ma_lpf2): ma_result <cimport, nodecl> end
global function ma_lpf2_process_pcm_frames(pLPF: *ma_lpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf2_get_latency(pLPF: *ma_lpf2): uint32 <cimport, nodecl> end
global ma_lpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_lpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_lpf_config <cimport, nodecl> end
global ma_lpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  lpf1Count: uint32,
  lpf2Count: uint32,
  lpf1: [1]ma_lpf1,
  lpf2: [4]ma_lpf2
}
global function ma_lpf_init(pConfig: *ma_lpf_config, pLPF: *ma_lpf): ma_result <cimport, nodecl> end
global function ma_lpf_reinit(pConfig: *ma_lpf_config, pLPF: *ma_lpf): ma_result <cimport, nodecl> end
global function ma_lpf_process_pcm_frames(pLPF: *ma_lpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf_get_latency(pLPF: *ma_lpf): uint32 <cimport, nodecl> end
global ma_hpf1_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_hpf2_config: type = @ma_hpf1_config
global function ma_hpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_hpf1_config <cimport, nodecl> end
global function ma_hpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_hpf2_config <cimport, nodecl> end
global ma_hpf1: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient
}
global function ma_hpf1_init(pConfig: *ma_hpf1_config, pHPF: *ma_hpf1): ma_result <cimport, nodecl> end
global function ma_hpf1_reinit(pConfig: *ma_hpf1_config, pHPF: *ma_hpf1): ma_result <cimport, nodecl> end
global function ma_hpf1_process_pcm_frames(pHPF: *ma_hpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf1_get_latency(pHPF: *ma_hpf1): uint32 <cimport, nodecl> end
global ma_hpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_hpf2_init(pConfig: *ma_hpf2_config, pHPF: *ma_hpf2): ma_result <cimport, nodecl> end
global function ma_hpf2_reinit(pConfig: *ma_hpf2_config, pHPF: *ma_hpf2): ma_result <cimport, nodecl> end
global function ma_hpf2_process_pcm_frames(pHPF: *ma_hpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf2_get_latency(pHPF: *ma_hpf2): uint32 <cimport, nodecl> end
global ma_hpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_hpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_hpf_config <cimport, nodecl> end
global ma_hpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  hpf1Count: uint32,
  hpf2Count: uint32,
  hpf1: [1]ma_hpf1,
  hpf2: [4]ma_hpf2
}
global function ma_hpf_init(pConfig: *ma_hpf_config, pHPF: *ma_hpf): ma_result <cimport, nodecl> end
global function ma_hpf_reinit(pConfig: *ma_hpf_config, pHPF: *ma_hpf): ma_result <cimport, nodecl> end
global function ma_hpf_process_pcm_frames(pHPF: *ma_hpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf_get_latency(pHPF: *ma_hpf): uint32 <cimport, nodecl> end
global ma_bpf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global function ma_bpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_bpf2_config <cimport, nodecl> end
global ma_bpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_bpf2_init(pConfig: *ma_bpf2_config, pBPF: *ma_bpf2): ma_result <cimport, nodecl> end
global function ma_bpf2_reinit(pConfig: *ma_bpf2_config, pBPF: *ma_bpf2): ma_result <cimport, nodecl> end
global function ma_bpf2_process_pcm_frames(pBPF: *ma_bpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_bpf2_get_latency(pBPF: *ma_bpf2): uint32 <cimport, nodecl> end
global ma_bpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_bpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_bpf_config <cimport, nodecl> end
global ma_bpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  bpf2Count: uint32,
  bpf2: [4]ma_bpf2
}
global function ma_bpf_init(pConfig: *ma_bpf_config, pBPF: *ma_bpf): ma_result <cimport, nodecl> end
global function ma_bpf_reinit(pConfig: *ma_bpf_config, pBPF: *ma_bpf): ma_result <cimport, nodecl> end
global function ma_bpf_process_pcm_frames(pBPF: *ma_bpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_bpf_get_latency(pBPF: *ma_bpf): uint32 <cimport, nodecl> end
global ma_notch2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  q: float64,
  frequency: float64
}
global ma_notch_config: type = @ma_notch2_config
global function ma_notch2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, q: float64, frequency: float64): ma_notch2_config <cimport, nodecl> end
global ma_notch2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_notch2_init(pConfig: *ma_notch2_config, pFilter: *ma_notch2): ma_result <cimport, nodecl> end
global function ma_notch2_reinit(pConfig: *ma_notch2_config, pFilter: *ma_notch2): ma_result <cimport, nodecl> end
global function ma_notch2_process_pcm_frames(pFilter: *ma_notch2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_notch2_get_latency(pFilter: *ma_notch2): uint32 <cimport, nodecl> end
global ma_peak2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  q: float64,
  frequency: float64
}
global ma_peak_config: type = @ma_peak2_config
global function ma_peak2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_peak2_config <cimport, nodecl> end
global ma_peak2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_peak2_init(pConfig: *ma_peak2_config, pFilter: *ma_peak2): ma_result <cimport, nodecl> end
global function ma_peak2_reinit(pConfig: *ma_peak2_config, pFilter: *ma_peak2): ma_result <cimport, nodecl> end
global function ma_peak2_process_pcm_frames(pFilter: *ma_peak2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_peak2_get_latency(pFilter: *ma_peak2): uint32 <cimport, nodecl> end
global ma_loshelf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global ma_loshelf_config: type = @ma_loshelf2_config
global function ma_loshelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_loshelf2_config <cimport, nodecl> end
global ma_loshelf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_loshelf2_init(pConfig: *ma_loshelf2_config, pFilter: *ma_loshelf2): ma_result <cimport, nodecl> end
global function ma_loshelf2_reinit(pConfig: *ma_loshelf2_config, pFilter: *ma_loshelf2): ma_result <cimport, nodecl> end
global function ma_loshelf2_process_pcm_frames(pFilter: *ma_loshelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_loshelf2_get_latency(pFilter: *ma_loshelf2): uint32 <cimport, nodecl> end
global ma_hishelf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global ma_hishelf_config: type = @ma_hishelf2_config
global function ma_hishelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_hishelf2_config <cimport, nodecl> end
global ma_hishelf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_hishelf2_init(pConfig: *ma_hishelf2_config, pFilter: *ma_hishelf2): ma_result <cimport, nodecl> end
global function ma_hishelf2_reinit(pConfig: *ma_hishelf2_config, pFilter: *ma_hishelf2): ma_result <cimport, nodecl> end
global function ma_hishelf2_process_pcm_frames(pFilter: *ma_hishelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hishelf2_get_latency(pFilter: *ma_hishelf2): uint32 <cimport, nodecl> end
global ma_linear_resampler_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  lpfOrder: uint32,
  lpfNyquistFactor: float64
}
global function ma_linear_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_linear_resampler_config <cimport, nodecl> end
global ma_linear_resampler: type <cimport, nodecl> = @record{
  config: ma_linear_resampler_config,
  inAdvanceInt: uint32,
  inAdvanceFrac: uint32,
  inTimeInt: uint32,
  inTimeFrac: uint32,
  x0: union{
    f32: [32]float32,
    s16: [32]int16
  },
  x1: union{
    f32: [32]float32,
    s16: [32]int16
  },
  lpf: ma_lpf
}
global function ma_linear_resampler_init(pConfig: *ma_linear_resampler_config, pResampler: *ma_linear_resampler): ma_result <cimport, nodecl> end
global function ma_linear_resampler_uninit(pResampler: *ma_linear_resampler) <cimport, nodecl> end
global function ma_linear_resampler_process_pcm_frames(pResampler: *ma_linear_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_linear_resampler_set_rate(pResampler: *ma_linear_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_linear_resampler_set_rate_ratio(pResampler: *ma_linear_resampler, ratioInOut: float32): ma_result <cimport, nodecl> end
global function ma_linear_resampler_get_required_input_frame_count(pResampler: *ma_linear_resampler, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_expected_output_frame_count(pResampler: *ma_linear_resampler, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_input_latency(pResampler: *ma_linear_resampler): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_output_latency(pResampler: *ma_linear_resampler): uint64 <cimport, nodecl> end
global ma_resample_algorithm: type <cimport, nodecl, using> = @enum(cint){
  ma_resample_algorithm_linear = 0,
  ma_resample_algorithm_speex = 1
}
global ma_resampler_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  algorithm: ma_resample_algorithm,
  linear: record{
    lpfOrder: uint32,
    lpfNyquistFactor: float64
  },
  speex: record{
    quality: cint
  }
}
global function ma_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32, algorithm: ma_resample_algorithm): ma_resampler_config <cimport, nodecl> end
global ma_resampler: type <cimport, nodecl> = @record{
  config: ma_resampler_config,
  state: union{
    linear: ma_linear_resampler,
    speex: record{
      pSpeexResamplerState: pointer
    }
  }
}
global function ma_resampler_init(pConfig: *ma_resampler_config, pResampler: *ma_resampler): ma_result <cimport, nodecl> end
global function ma_resampler_uninit(pResampler: *ma_resampler) <cimport, nodecl> end
global function ma_resampler_process_pcm_frames(pResampler: *ma_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_resampler_set_rate(pResampler: *ma_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_resampler_set_rate_ratio(pResampler: *ma_resampler, ratio: float32): ma_result <cimport, nodecl> end
global function ma_resampler_get_required_input_frame_count(pResampler: *ma_resampler, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_resampler_get_expected_output_frame_count(pResampler: *ma_resampler, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_resampler_get_input_latency(pResampler: *ma_resampler): uint64 <cimport, nodecl> end
global function ma_resampler_get_output_latency(pResampler: *ma_resampler): uint64 <cimport, nodecl> end
global ma_channel_converter_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  mixingMode: ma_channel_mix_mode,
  weights: [32][32]float32
}
global function ma_channel_converter_config_init(format: ma_format, channelsIn: uint32, pChannelMapIn: *cuchar, channelsOut: uint32, pChannelMapOut: *cuchar, mixingMode: ma_channel_mix_mode): ma_channel_converter_config <cimport, nodecl> end
global ma_channel_converter: type <cimport, nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  mixingMode: ma_channel_mix_mode,
  weights: union{
    f32: [32][32]float32,
    s16: [32][32]int32
  },
  isPassthrough: ma_bool8,
  isSimpleShuffle: ma_bool8,
  isSimpleMonoExpansion: ma_bool8,
  isStereoToMono: ma_bool8,
  shuffleTable: [32]uint8
}
global function ma_channel_converter_init(pConfig: *ma_channel_converter_config, pConverter: *ma_channel_converter): ma_result <cimport, nodecl> end
global function ma_channel_converter_uninit(pConverter: *ma_channel_converter) <cimport, nodecl> end
global function ma_channel_converter_process_pcm_frames(pConverter: *ma_channel_converter, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global ma_data_converter_config: type <cimport, nodecl> = @record{
  formatIn: ma_format,
  formatOut: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  ditherMode: ma_dither_mode,
  channelMixMode: ma_channel_mix_mode,
  channelWeights: [32][32]float32,
  resampling: record{
    algorithm: ma_resample_algorithm,
    allowDynamicSampleRate: ma_bool32,
    linear: record{
      lpfOrder: uint32,
      lpfNyquistFactor: float64
    },
    speex: record{
      quality: cint
    }
  }
}
global function ma_data_converter_config_init_default(): ma_data_converter_config <cimport, nodecl> end
global function ma_data_converter_config_init(formatIn: ma_format, formatOut: ma_format, channelsIn: uint32, channelsOut: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_data_converter_config <cimport, nodecl> end
global ma_data_converter: type <cimport, nodecl> = @record{
  config: ma_data_converter_config,
  channelConverter: ma_channel_converter,
  resampler: ma_resampler,
  hasPreFormatConversion: ma_bool8,
  hasPostFormatConversion: ma_bool8,
  hasChannelConverter: ma_bool8,
  hasResampler: ma_bool8,
  isPassthrough: ma_bool8
}
global function ma_data_converter_init(pConfig: *ma_data_converter_config, pConverter: *ma_data_converter): ma_result <cimport, nodecl> end
global function ma_data_converter_uninit(pConverter: *ma_data_converter) <cimport, nodecl> end
global function ma_data_converter_process_pcm_frames(pConverter: *ma_data_converter, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_data_converter_set_rate(pConverter: *ma_data_converter, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_data_converter_set_rate_ratio(pConverter: *ma_data_converter, ratioInOut: float32): ma_result <cimport, nodecl> end
global function ma_data_converter_get_required_input_frame_count(pConverter: *ma_data_converter, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_data_converter_get_expected_output_frame_count(pConverter: *ma_data_converter, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_data_converter_get_input_latency(pConverter: *ma_data_converter): uint64 <cimport, nodecl> end
global function ma_data_converter_get_output_latency(pConverter: *ma_data_converter): uint64 <cimport, nodecl> end
global function ma_pcm_u8_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_convert(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, sampleCount: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_convert_pcm_frames_format(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, frameCount: uint64, channels: uint32, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_deinterleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, pInterleavedPCMFrames: pointer, ppDeinterleavedPCMFrames: *pointer) <cimport, nodecl> end
global function ma_interleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, ppDeinterleavedPCMFrames: *pointer, pInterleavedPCMFrames: pointer) <cimport, nodecl> end
global function ma_channel_map_get_default_channel(channelCount: uint32, channelIndex: uint32): cuchar <cimport, nodecl> end
global function ma_channel_map_get_channel(pChannelMap: *cuchar, channelCount: uint32, channelIndex: uint32): cuchar <cimport, nodecl> end
global function ma_channel_map_init_blank(channels: uint32, pChannelMap: *cuchar) <cimport, nodecl> end
global function ma_get_standard_channel_map(standardChannelMap: ma_standard_channel_map, channels: uint32, pChannelMap: *cuchar) <cimport, nodecl> end
global function ma_channel_map_copy(pOut: *cuchar, pIn: *cuchar, channels: uint32) <cimport, nodecl> end
global function ma_channel_map_copy_or_default(pOut: *cuchar, pIn: *cuchar, channels: uint32) <cimport, nodecl> end
global function ma_channel_map_valid(channels: uint32, pChannelMap: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_equal(channels: uint32, pChannelMapA: *cuchar, pChannelMapB: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_blank(channels: uint32, pChannelMap: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_contains_channel_position(channels: uint32, pChannelMap: *cuchar, channelPosition: cuchar): ma_bool32 <cimport, nodecl> end
global function ma_convert_frames(pOut: pointer, frameCountOut: uint64, formatOut: ma_format, channelsOut: uint32, sampleRateOut: uint32, pIn: pointer, frameCountIn: uint64, formatIn: ma_format, channelsIn: uint32, sampleRateIn: uint32): uint64 <cimport, nodecl> end
global function ma_convert_frames_ex(pOut: pointer, frameCountOut: uint64, pIn: pointer, frameCountIn: uint64, pConfig: *ma_data_converter_config): uint64 <cimport, nodecl> end
global ma_rb: type <cimport, nodecl> = @record{
  pBuffer: pointer,
  subbufferSizeInBytes: uint32,
  subbufferCount: uint32,
  subbufferStrideInBytes: uint32,
  encodedReadOffset: uint32,
  encodedWriteOffset: uint32,
  ownsBuffer: ma_bool8,
  clearOnWriteAcquire: ma_bool8,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_rb_init_ex(subbufferSizeInBytes: csize, subbufferCount: csize, subbufferStrideInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport, nodecl> end
global function ma_rb_init(bufferSizeInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport, nodecl> end
global function ma_rb_uninit(pRB: *ma_rb) <cimport, nodecl> end
global function ma_rb_reset(pRB: *ma_rb) <cimport, nodecl> end
global function ma_rb_acquire_read(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_rb_commit_read(pRB: *ma_rb, sizeInBytes: csize, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_rb_acquire_write(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_rb_commit_write(pRB: *ma_rb, sizeInBytes: csize, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_rb_seek_read(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport, nodecl> end
global function ma_rb_seek_write(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport, nodecl> end
global function ma_rb_pointer_distance(pRB: *ma_rb): int32 <cimport, nodecl> end
global function ma_rb_available_read(pRB: *ma_rb): uint32 <cimport, nodecl> end
global function ma_rb_available_write(pRB: *ma_rb): uint32 <cimport, nodecl> end
global function ma_rb_get_subbuffer_size(pRB: *ma_rb): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_stride(pRB: *ma_rb): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_offset(pRB: *ma_rb, subbufferIndex: csize): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_ptr(pRB: *ma_rb, subbufferIndex: csize, pBuffer: pointer): pointer <cimport, nodecl> end
global ma_pcm_rb: type <cimport, nodecl> = @record{
  rb: ma_rb,
  format: ma_format,
  channels: uint32
}
global function ma_pcm_rb_init_ex(format: ma_format, channels: uint32, subbufferSizeInFrames: uint32, subbufferCount: uint32, subbufferStrideInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport, nodecl> end
global function ma_pcm_rb_init(format: ma_format, channels: uint32, bufferSizeInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport, nodecl> end
global function ma_pcm_rb_uninit(pRB: *ma_pcm_rb) <cimport, nodecl> end
global function ma_pcm_rb_reset(pRB: *ma_pcm_rb) <cimport, nodecl> end
global function ma_pcm_rb_acquire_read(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_commit_read(pRB: *ma_pcm_rb, sizeInFrames: uint32, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_acquire_write(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_commit_write(pRB: *ma_pcm_rb, sizeInFrames: uint32, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_seek_read(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport, nodecl> end
global function ma_pcm_rb_seek_write(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport, nodecl> end
global function ma_pcm_rb_pointer_distance(pRB: *ma_pcm_rb): int32 <cimport, nodecl> end
global function ma_pcm_rb_available_read(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_available_write(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_size(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_stride(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_offset(pRB: *ma_pcm_rb, subbufferIndex: uint32): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_ptr(pRB: *ma_pcm_rb, subbufferIndex: uint32, pBuffer: pointer): pointer <cimport, nodecl> end
global ma_duplex_rb: type <cimport, nodecl> = @record{
  rb: ma_pcm_rb
}
global function ma_duplex_rb_init(captureFormat: ma_format, captureChannels: uint32, sampleRate: uint32, captureInternalSampleRate: uint32, captureInternalPeriodSizeInFrames: uint32, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_duplex_rb): ma_result <cimport, nodecl> end
global function ma_duplex_rb_uninit(pRB: *ma_duplex_rb): ma_result <cimport, nodecl> end
global function ma_result_description(result: ma_result): cstring <cimport, nodecl> end
global function ma_malloc(sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_realloc(p: pointer, sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_aligned_malloc(sz: csize, alignment: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_aligned_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_get_format_name(format: ma_format): cstring <cimport, nodecl> end
global function ma_blend_f32(pOut: *float32, pInA: *float32, pInB: *float32, factor: float32, channels: uint32) <cimport, nodecl> end
global function ma_get_bytes_per_sample(format: ma_format): uint32 <cimport, nodecl> end
global function ma_get_bytes_per_frame(format: ma_format, channels: uint32): uint32 <cimport, nodecl> end
global function ma_log_level_to_string(logLevel: uint32): cstring <cimport, nodecl> end
global ma_backend: type <cimport, nodecl, using> = @enum(cint){
  ma_backend_wasapi = 0,
  ma_backend_dsound = 1,
  ma_backend_winmm = 2,
  ma_backend_coreaudio = 3,
  ma_backend_sndio = 4,
  ma_backend_audio4 = 5,
  ma_backend_oss = 6,
  ma_backend_pulseaudio = 7,
  ma_backend_alsa = 8,
  ma_backend_jack = 9,
  ma_backend_aaudio = 10,
  ma_backend_opensl = 11,
  ma_backend_webaudio = 12,
  ma_backend_custom = 13,
  ma_backend_null = 14
}
global ma_device_callback_proc: type <cimport, nodecl> = @function(*ma_device, pointer, pointer, uint32)
global ma_stop_proc: type <cimport, nodecl> = @function(*ma_device)
global ma_log_proc: type <cimport, nodecl> = @function(*ma_context, *ma_device, uint32, cstring)
global ma_device_type: type <cimport, nodecl, using> = @enum(cint){
  ma_device_type_playback = 1,
  ma_device_type_capture = 2,
  ma_device_type_duplex = 3,
  ma_device_type_loopback = 4
}
global ma_share_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_share_mode_shared = 0,
  ma_share_mode_exclusive = 1
}
global ma_ios_session_category: type <cimport, nodecl, using> = @enum(cint){
  ma_ios_session_category_default = 0,
  ma_ios_session_category_none = 1,
  ma_ios_session_category_ambient = 2,
  ma_ios_session_category_solo_ambient = 3,
  ma_ios_session_category_playback = 4,
  ma_ios_session_category_record = 5,
  ma_ios_session_category_play_and_record = 6,
  ma_ios_session_category_multi_route = 7
}
global ma_ios_session_category_option: type <cimport, nodecl, using> = @enum(cint){
  ma_ios_session_category_option_mix_with_others = 1,
  ma_ios_session_category_option_duck_others = 2,
  ma_ios_session_category_option_allow_bluetooth = 4,
  ma_ios_session_category_option_default_to_speaker = 8,
  ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others = 17,
  ma_ios_session_category_option_allow_bluetooth_a2dp = 32,
  ma_ios_session_category_option_allow_air_play = 64
}
global ma_opensl_stream_type: type <cimport, nodecl, using> = @enum(cint){
  ma_opensl_stream_type_default = 0,
  ma_opensl_stream_type_voice = 1,
  ma_opensl_stream_type_system = 2,
  ma_opensl_stream_type_ring = 3,
  ma_opensl_stream_type_media = 4,
  ma_opensl_stream_type_alarm = 5,
  ma_opensl_stream_type_notification = 6
}
global ma_opensl_recording_preset: type <cimport, nodecl, using> = @enum(cint){
  ma_opensl_recording_preset_default = 0,
  ma_opensl_recording_preset_generic = 1,
  ma_opensl_recording_preset_camcorder = 2,
  ma_opensl_recording_preset_voice_recognition = 3,
  ma_opensl_recording_preset_voice_communication = 4,
  ma_opensl_recording_preset_voice_unprocessed = 5
}
global ma_aaudio_usage: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_usage_default = 0,
  ma_aaudio_usage_announcement = 1,
  ma_aaudio_usage_emergency = 2,
  ma_aaudio_usage_safety = 3,
  ma_aaudio_usage_vehicle_status = 4,
  ma_aaudio_usage_alarm = 5,
  ma_aaudio_usage_assistance_accessibility = 6,
  ma_aaudio_usage_assistance_navigation_guidance = 7,
  ma_aaudio_usage_assistance_sonification = 8,
  ma_aaudio_usage_assitant = 9,
  ma_aaudio_usage_game = 10,
  ma_aaudio_usage_media = 11,
  ma_aaudio_usage_notification = 12,
  ma_aaudio_usage_notification_event = 13,
  ma_aaudio_usage_notification_ringtone = 14,
  ma_aaudio_usage_voice_communication = 15,
  ma_aaudio_usage_voice_communication_signalling = 16
}
global ma_aaudio_content_type: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_content_type_default = 0,
  ma_aaudio_content_type_movie = 1,
  ma_aaudio_content_type_music = 2,
  ma_aaudio_content_type_sonification = 3,
  ma_aaudio_content_type_speech = 4
}
global ma_aaudio_input_preset: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_input_preset_default = 0,
  ma_aaudio_input_preset_generic = 1,
  ma_aaudio_input_preset_camcorder = 2,
  ma_aaudio_input_preset_unprocessed = 3,
  ma_aaudio_input_preset_voice_recognition = 4,
  ma_aaudio_input_preset_voice_communication = 5,
  ma_aaudio_input_preset_voice_performance = 6
}
global ma_timer: type <cimport, nodecl> = @union{
  counter: int64,
  counterD: float64
}
global ma_device_id: type <cimport, nodecl> = @union{
  wasapi: [64]cint,
  dsound: [16]uint8,
  winmm: uint32,
  alsa: [256]cchar,
  pulse: [256]cchar,
  jack: cint,
  coreaudio: [256]cchar,
  sndio: [256]cchar,
  audio4: [256]cchar,
  oss: [64]cchar,
  aaudio: int32,
  opensl: uint32,
  webaudio: [32]cchar,
  custom: union{
    i: cint,
    s: [256]cchar,
    p: pointer
  },
  nullbackend: cint
}
global ma_context_config: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device_config: type <cimport, nodecl, forwarddecl> = @record{}
global ma_backend_callbacks: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device_info: type <cimport, nodecl> = @record{
  id: ma_device_id,
  name: [256]cchar,
  isDefault: ma_bool32,
  formatCount: uint32,
  formats: [6]ma_format,
  minChannels: uint32,
  maxChannels: uint32,
  minSampleRate: uint32,
  maxSampleRate: uint32,
  nativeDataFormatCount: uint32,
  nativeDataFormats: [64]record{
    format: ma_format,
    channels: uint32,
    sampleRate: uint32,
    flags: uint32
  }
}
ma_device_config = @record{
  deviceType: ma_device_type,
  sampleRate: uint32,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periods: uint32,
  performanceProfile: ma_performance_profile,
  noPreZeroedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  dataCallback: ma_device_callback_proc,
  stopCallback: ma_stop_proc,
  pUserData: pointer,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  playback: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    channelMixMode: ma_channel_mix_mode,
    shareMode: ma_share_mode
  },
  capture: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    channelMixMode: ma_channel_mix_mode,
    shareMode: ma_share_mode
  },
  wasapi: record{
    noAutoConvertSRC: ma_bool8,
    noDefaultQualitySRC: ma_bool8,
    noAutoStreamRouting: ma_bool8,
    noHardwareOffloading: ma_bool8
  },
  alsa: record{
    noMMap: ma_bool32,
    noAutoFormat: ma_bool32,
    noAutoChannels: ma_bool32,
    noAutoResample: ma_bool32
  },
  pulse: record{
    pStreamNamePlayback: cstring,
    pStreamNameCapture: cstring
  },
  coreaudio: record{
    allowNominalSampleRateChange: ma_bool32
  },
  opensl: record{
    streamType: ma_opensl_stream_type,
    recordingPreset: ma_opensl_recording_preset
  },
  aaudio: record{
    usage: ma_aaudio_usage,
    contentType: ma_aaudio_content_type,
    inputPreset: ma_aaudio_input_preset
  }
}
global ma_enum_devices_callback_proc: type <cimport, nodecl> = @function(*ma_context, ma_device_type, *ma_device_info, pointer): ma_bool32
global ma_device_descriptor: type <cimport, nodecl> = @record{
  pDeviceID: *ma_device_id,
  shareMode: ma_share_mode,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  channelMap: [32]cuchar,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periodCount: uint32
}
ma_backend_callbacks = @record{
  onContextInit: function(*ma_context, *ma_context_config, *ma_backend_callbacks): ma_result,
  onContextUninit: function(*ma_context): ma_result,
  onContextEnumerateDevices: function(*ma_context, ma_enum_devices_callback_proc, pointer): ma_result,
  onContextGetDeviceInfo: function(*ma_context, ma_device_type, *ma_device_id, *ma_device_info): ma_result,
  onDeviceInit: function(*ma_device, *ma_device_config, *ma_device_descriptor, *ma_device_descriptor): ma_result,
  onDeviceUninit: function(*ma_device): ma_result,
  onDeviceStart: function(*ma_device): ma_result,
  onDeviceStop: function(*ma_device): ma_result,
  onDeviceRead: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceWrite: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceDataLoop: function(*ma_device): ma_result,
  onDeviceDataLoopWakeup: function(*ma_device): ma_result
}
ma_context_config = @record{
  logCallback: ma_log_proc,
  pLog: *ma_log,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  alsa: record{
    useVerboseDeviceEnumeration: ma_bool32
  },
  pulse: record{
    pApplicationName: cstring,
    pServerName: cstring,
    tryAutoSpawn: ma_bool32
  },
  coreaudio: record{
    sessionCategory: ma_ios_session_category,
    sessionCategoryOptions: uint32,
    noAudioSessionActivate: ma_bool32,
    noAudioSessionDeactivate: ma_bool32
  },
  jack: record{
    pClientName: cstring,
    tryStartServer: ma_bool32
  },
  custom: ma_backend_callbacks
}
global ma_context_command__wasapi: type <cimport, nodecl> = @record{
  code: cint,
  pEvent: *ma_event,
  data: union{
    quit: record{
      _unused: cint
    },
    createAudioClient: record{
      deviceType: ma_device_type,
      pAudioClient: pointer,
      ppAudioClientService: *pointer,
      pResult: *ma_result
    },
    releaseAudioClient: record{
      pDevice: *ma_device,
      deviceType: ma_device_type
    }
  }
}
ma_context = @record{
  callbacks: ma_backend_callbacks,
  backend: ma_backend,
  pLog: *ma_log,
  log: ma_log,
  logCallback: ma_log_proc,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  deviceEnumLock: ma_mutex,
  deviceInfoLock: ma_mutex,
  deviceInfoCapacity: uint32,
  playbackDeviceInfoCount: uint32,
  captureDeviceInfoCount: uint32,
  pDeviceInfos: *ma_device_info,
  __unnamed1: union{
    alsa: record{
      asoundSO: ma_handle,
      snd_pcm_open: ma_proc,
      snd_pcm_close: ma_proc,
      snd_pcm_hw_params_sizeof: ma_proc,
      snd_pcm_hw_params_any: ma_proc,
      snd_pcm_hw_params_set_format: ma_proc,
      snd_pcm_hw_params_set_format_first: ma_proc,
      snd_pcm_hw_params_get_format_mask: ma_proc,
      snd_pcm_hw_params_set_channels: ma_proc,
      snd_pcm_hw_params_set_channels_near: ma_proc,
      snd_pcm_hw_params_set_channels_minmax: ma_proc,
      snd_pcm_hw_params_set_rate_resample: ma_proc,
      snd_pcm_hw_params_set_rate: ma_proc,
      snd_pcm_hw_params_set_rate_near: ma_proc,
      snd_pcm_hw_params_set_buffer_size_near: ma_proc,
      snd_pcm_hw_params_set_periods_near: ma_proc,
      snd_pcm_hw_params_set_access: ma_proc,
      snd_pcm_hw_params_get_format: ma_proc,
      snd_pcm_hw_params_get_channels: ma_proc,
      snd_pcm_hw_params_get_channels_min: ma_proc,
      snd_pcm_hw_params_get_channels_max: ma_proc,
      snd_pcm_hw_params_get_rate: ma_proc,
      snd_pcm_hw_params_get_rate_min: ma_proc,
      snd_pcm_hw_params_get_rate_max: ma_proc,
      snd_pcm_hw_params_get_buffer_size: ma_proc,
      snd_pcm_hw_params_get_periods: ma_proc,
      snd_pcm_hw_params_get_access: ma_proc,
      snd_pcm_hw_params_test_format: ma_proc,
      snd_pcm_hw_params_test_channels: ma_proc,
      snd_pcm_hw_params_test_rate: ma_proc,
      snd_pcm_hw_params: ma_proc,
      snd_pcm_sw_params_sizeof: ma_proc,
      snd_pcm_sw_params_current: ma_proc,
      snd_pcm_sw_params_get_boundary: ma_proc,
      snd_pcm_sw_params_set_avail_min: ma_proc,
      snd_pcm_sw_params_set_start_threshold: ma_proc,
      snd_pcm_sw_params_set_stop_threshold: ma_proc,
      snd_pcm_sw_params: ma_proc,
      snd_pcm_format_mask_sizeof: ma_proc,
      snd_pcm_format_mask_test: ma_proc,
      snd_pcm_get_chmap: ma_proc,
      snd_pcm_state: ma_proc,
      snd_pcm_prepare: ma_proc,
      snd_pcm_start: ma_proc,
      snd_pcm_drop: ma_proc,
      snd_pcm_drain: ma_proc,
      snd_pcm_reset: ma_proc,
      snd_device_name_hint: ma_proc,
      snd_device_name_get_hint: ma_proc,
      snd_card_get_index: ma_proc,
      snd_device_name_free_hint: ma_proc,
      snd_pcm_mmap_begin: ma_proc,
      snd_pcm_mmap_commit: ma_proc,
      snd_pcm_recover: ma_proc,
      snd_pcm_readi: ma_proc,
      snd_pcm_writei: ma_proc,
      snd_pcm_avail: ma_proc,
      snd_pcm_avail_update: ma_proc,
      snd_pcm_wait: ma_proc,
      snd_pcm_nonblock: ma_proc,
      snd_pcm_info: ma_proc,
      snd_pcm_info_sizeof: ma_proc,
      snd_pcm_info_get_name: ma_proc,
      snd_pcm_poll_descriptors: ma_proc,
      snd_pcm_poll_descriptors_count: ma_proc,
      snd_pcm_poll_descriptors_revents: ma_proc,
      snd_config_update_free_global: ma_proc,
      internalDeviceEnumLock: ma_mutex,
      useVerboseDeviceEnumeration: ma_bool32
    },
    pulse: record{
      pulseSO: ma_handle,
      pa_mainloop_new: ma_proc,
      pa_mainloop_free: ma_proc,
      pa_mainloop_quit: ma_proc,
      pa_mainloop_get_api: ma_proc,
      pa_mainloop_iterate: ma_proc,
      pa_mainloop_wakeup: ma_proc,
      pa_threaded_mainloop_new: ma_proc,
      pa_threaded_mainloop_free: ma_proc,
      pa_threaded_mainloop_start: ma_proc,
      pa_threaded_mainloop_stop: ma_proc,
      pa_threaded_mainloop_lock: ma_proc,
      pa_threaded_mainloop_unlock: ma_proc,
      pa_threaded_mainloop_wait: ma_proc,
      pa_threaded_mainloop_signal: ma_proc,
      pa_threaded_mainloop_accept: ma_proc,
      pa_threaded_mainloop_get_retval: ma_proc,
      pa_threaded_mainloop_get_api: ma_proc,
      pa_threaded_mainloop_in_thread: ma_proc,
      pa_threaded_mainloop_set_name: ma_proc,
      pa_context_new: ma_proc,
      pa_context_unref: ma_proc,
      pa_context_connect: ma_proc,
      pa_context_disconnect: ma_proc,
      pa_context_set_state_callback: ma_proc,
      pa_context_get_state: ma_proc,
      pa_context_get_sink_info_list: ma_proc,
      pa_context_get_source_info_list: ma_proc,
      pa_context_get_sink_info_by_name: ma_proc,
      pa_context_get_source_info_by_name: ma_proc,
      pa_operation_unref: ma_proc,
      pa_operation_get_state: ma_proc,
      pa_channel_map_init_extend: ma_proc,
      pa_channel_map_valid: ma_proc,
      pa_channel_map_compatible: ma_proc,
      pa_stream_new: ma_proc,
      pa_stream_unref: ma_proc,
      pa_stream_connect_playback: ma_proc,
      pa_stream_connect_record: ma_proc,
      pa_stream_disconnect: ma_proc,
      pa_stream_get_state: ma_proc,
      pa_stream_get_sample_spec: ma_proc,
      pa_stream_get_channel_map: ma_proc,
      pa_stream_get_buffer_attr: ma_proc,
      pa_stream_set_buffer_attr: ma_proc,
      pa_stream_get_device_name: ma_proc,
      pa_stream_set_write_callback: ma_proc,
      pa_stream_set_read_callback: ma_proc,
      pa_stream_set_suspended_callback: ma_proc,
      pa_stream_is_suspended: ma_proc,
      pa_stream_flush: ma_proc,
      pa_stream_drain: ma_proc,
      pa_stream_is_corked: ma_proc,
      pa_stream_cork: ma_proc,
      pa_stream_trigger: ma_proc,
      pa_stream_begin_write: ma_proc,
      pa_stream_write: ma_proc,
      pa_stream_peek: ma_proc,
      pa_stream_drop: ma_proc,
      pa_stream_writable_size: ma_proc,
      pa_stream_readable_size: ma_proc,
      pMainLoop: ma_ptr,
      pPulseContext: ma_ptr
    },
    jack: record{
      jackSO: ma_handle,
      jack_client_open: ma_proc,
      jack_client_close: ma_proc,
      jack_client_name_size: ma_proc,
      jack_set_process_callback: ma_proc,
      jack_set_buffer_size_callback: ma_proc,
      jack_on_shutdown: ma_proc,
      jack_get_sample_rate: ma_proc,
      jack_get_buffer_size: ma_proc,
      jack_get_ports: ma_proc,
      jack_activate: ma_proc,
      jack_deactivate: ma_proc,
      jack_connect: ma_proc,
      jack_port_register: ma_proc,
      jack_port_name: ma_proc,
      jack_port_get_buffer: ma_proc,
      jack_free: ma_proc,
      pClientName: cstring,
      tryStartServer: ma_bool32
    },
    null_backend: record{
      _unused: cint
    }
  },
  __unnamed2: union{
    posix: record{
      pthreadSO: ma_handle,
      pthread_create: ma_proc,
      pthread_join: ma_proc,
      pthread_mutex_init: ma_proc,
      pthread_mutex_destroy: ma_proc,
      pthread_mutex_lock: ma_proc,
      pthread_mutex_unlock: ma_proc,
      pthread_cond_init: ma_proc,
      pthread_cond_destroy: ma_proc,
      pthread_cond_wait: ma_proc,
      pthread_cond_signal: ma_proc,
      pthread_attr_init: ma_proc,
      pthread_attr_destroy: ma_proc,
      pthread_attr_setschedpolicy: ma_proc,
      pthread_attr_getschedparam: ma_proc,
      pthread_attr_setschedparam: ma_proc
    },
    _unused: cint
  }
}
ma_device = @record{
  pContext: *ma_context,
  type: ma_device_type,
  sampleRate: uint32,
  state: uint32,
  onData: ma_device_callback_proc,
  onStop: ma_stop_proc,
  pUserData: pointer,
  startStopLock: ma_mutex,
  wakeupEvent: ma_event,
  startEvent: ma_event,
  stopEvent: ma_event,
  thread: ma_thread,
  workResult: ma_result,
  isOwnerOfContext: ma_bool8,
  noPreZeroedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  masterVolumeFactor: float32,
  duplexRB: ma_duplex_rb,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  playback: record{
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [32]cuchar,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    converter: ma_data_converter
  },
  capture: record{
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [32]cuchar,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    converter: ma_data_converter
  },
  __unnamed1: union{
    alsa: record{
      pPCMPlayback: ma_ptr,
      pPCMCapture: ma_ptr,
      pPollDescriptorsPlayback: pointer,
      pPollDescriptorsCapture: pointer,
      pollDescriptorCountPlayback: cint,
      pollDescriptorCountCapture: cint,
      wakeupfdPlayback: cint,
      wakeupfdCapture: cint,
      isUsingMMapPlayback: ma_bool8,
      isUsingMMapCapture: ma_bool8
    },
    pulse: record{
      pStreamPlayback: ma_ptr,
      pStreamCapture: ma_ptr
    },
    jack: record{
      pClient: ma_ptr,
      pPortsPlayback: [32]ma_ptr,
      pPortsCapture: [32]ma_ptr,
      pIntermediaryBufferPlayback: *float32,
      pIntermediaryBufferCapture: *float32
    },
    null_device: record{
      deviceThread: ma_thread,
      operationEvent: ma_event,
      operationCompletionEvent: ma_event,
      operationSemaphore: ma_semaphore,
      operation: uint32,
      operationResult: ma_result,
      timer: ma_timer,
      priorRunTime: float64,
      currentPeriodFramesRemainingPlayback: uint32,
      currentPeriodFramesRemainingCapture: uint32,
      lastProcessedFramePlayback: uint64,
      lastProcessedFrameCapture: uint64,
      isStarted: ma_bool32
    }
  }
}
global function ma_context_config_init(): ma_context_config <cimport, nodecl> end
global function ma_context_init(backends: *ma_backend, backendCount: uint32, pConfig: *ma_context_config, pContext: *ma_context): ma_result <cimport, nodecl> end
global function ma_context_uninit(pContext: *ma_context): ma_result <cimport, nodecl> end
global function ma_context_sizeof(): csize <cimport, nodecl> end
global function ma_context_get_log(pContext: *ma_context): *ma_log <cimport, nodecl> end
global function ma_context_enumerate_devices(pContext: *ma_context, callback: ma_enum_devices_callback_proc, pUserData: pointer): ma_result <cimport, nodecl> end
global function ma_context_get_devices(pContext: *ma_context, ppPlaybackDeviceInfos: **ma_device_info, pPlaybackDeviceCount: *uint32, ppCaptureDeviceInfos: **ma_device_info, pCaptureDeviceCount: *uint32): ma_result <cimport, nodecl> end
global function ma_context_get_device_info(pContext: *ma_context, deviceType: ma_device_type, pDeviceID: *ma_device_id, shareMode: ma_share_mode, pDeviceInfo: *ma_device_info): ma_result <cimport, nodecl> end
global function ma_context_is_loopback_supported(pContext: *ma_context): ma_bool32 <cimport, nodecl> end
global function ma_device_config_init(deviceType: ma_device_type): ma_device_config <cimport, nodecl> end
global function ma_device_init(pContext: *ma_context, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_init_ex(backends: *ma_backend, backendCount: uint32, pContextConfig: *ma_context_config, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_uninit(pDevice: *ma_device) <cimport, nodecl> end
global function ma_device_get_context(pDevice: *ma_device): *ma_context <cimport, nodecl> end
global function ma_device_get_log(pDevice: *ma_device): *ma_log <cimport, nodecl> end
global function ma_device_start(pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_stop(pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_is_started(pDevice: *ma_device): ma_bool32 <cimport, nodecl> end
global function ma_device_get_state(pDevice: *ma_device): uint32 <cimport, nodecl> end
global function ma_device_set_master_volume(pDevice: *ma_device, volume: float32): ma_result <cimport, nodecl> end
global function ma_device_get_master_volume(pDevice: *ma_device, pVolume: *float32): ma_result <cimport, nodecl> end
global function ma_device_set_master_gain_db(pDevice: *ma_device, gainDB: float32): ma_result <cimport, nodecl> end
global function ma_device_get_master_gain_db(pDevice: *ma_device, pGainDB: *float32): ma_result <cimport, nodecl> end
global function ma_device_handle_backend_data_callback(pDevice: *ma_device, pOutput: pointer, pInput: pointer, frameCount: uint32): ma_result <cimport, nodecl> end
global function ma_calculate_buffer_size_in_frames_from_descriptor(pDescriptor: *ma_device_descriptor, nativeSampleRate: uint32, performanceProfile: ma_performance_profile): uint32 <cimport, nodecl> end
global function ma_get_backend_name(backend: ma_backend): cstring <cimport, nodecl> end
global function ma_is_backend_enabled(backend: ma_backend): ma_bool32 <cimport, nodecl> end
global function ma_get_enabled_backends(pBackends: *ma_backend, backendCap: csize, pBackendCount: *csize): ma_result <cimport, nodecl> end
global function ma_is_loopback_supported(backend: ma_backend): ma_bool32 <cimport, nodecl> end
global function ma_spinlock_lock(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_spinlock_lock_noyield(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_spinlock_unlock(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_mutex_init(pMutex: *ma_mutex): ma_result <cimport, nodecl> end
global function ma_mutex_uninit(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_mutex_lock(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_mutex_unlock(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_event_init(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_event_uninit(pEvent: *ma_event) <cimport, nodecl> end
global function ma_event_wait(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_event_signal(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_scale_buffer_size(baseBufferSize: uint32, scale: float32): uint32 <cimport, nodecl> end
global function ma_calculate_buffer_size_in_milliseconds_from_frames(bufferSizeInFrames: uint32, sampleRate: uint32): uint32 <cimport, nodecl> end
global function ma_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds: uint32, sampleRate: uint32): uint32 <cimport, nodecl> end
global function ma_copy_pcm_frames(dst: pointer, src: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_silence_pcm_frames(p: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_zero_pcm_frames(p: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_offset_pcm_frames_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport, nodecl> end
global function ma_offset_pcm_frames_const_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport, nodecl> end
global function ma_offset_pcm_frames_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport, nodecl> end
global function ma_offset_pcm_frames_const_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport, nodecl> end
global function ma_clip_samples_f32(p: *float32, sampleCount: uint64) <cimport, nodecl> end
global function ma_clip_pcm_frames_f32(p: *float32, frameCount: uint64, channels: uint32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_u8(pSamplesOut: *uint8, pSamplesIn: *uint8, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s16(pSamplesOut: *int16, pSamplesIn: *int16, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s24(pSamplesOut: pointer, pSamplesIn: pointer, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s32(pSamplesOut: *int32, pSamplesIn: *int32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_f32(pSamplesOut: *float32, pSamplesIn: *float32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_u8(pSamples: *uint8, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s16(pSamples: *int16, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s24(pSamples: pointer, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s32(pSamples: *int32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_f32(pSamples: *float32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_u8(pPCMFramesOut: *uint8, pPCMFramesIn: *uint8, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s16(pPCMFramesOut: *int16, pPCMFramesIn: *int16, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s24(pPCMFramesOut: pointer, pPCMFramesIn: pointer, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s32(pPCMFramesOut: *int32, pPCMFramesIn: *int32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_f32(pPCMFramesOut: *float32, pPCMFramesIn: *float32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames(pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_u8(pFrames: *uint8, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s16(pFrames: *int16, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s24(pFrames: pointer, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s32(pFrames: *int32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_f32(pFrames: *float32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames(pFrames: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_factor_to_gain_db(factor: float32): float32 <cimport, nodecl> end
global function ma_gain_db_to_factor(gain: float32): float32 <cimport, nodecl> end
global ma_data_source_vtable: type <cimport, nodecl> = @record{
  onRead: function(pointer, pointer, uint64, *uint64): ma_result,
  onSeek: function(pointer, uint64): ma_result,
  onMap: function(pointer, *pointer, *uint64): ma_result,
  onUnmap: function(pointer, uint64): ma_result,
  onGetDataFormat: function(pointer, *ma_format, *uint32, *uint32): ma_result,
  onGetCursor: function(pointer, *uint64): ma_result,
  onGetLength: function(pointer, *uint64): ma_result
}
global ma_data_source_callbacks: type = @ma_data_source_vtable
global ma_data_source_get_next_proc: type <cimport, nodecl> = @function(pointer): pointer
global ma_data_source_config: type <cimport, nodecl> = @record{
  vtable: *ma_data_source_vtable
}
global function ma_data_source_config_init(): ma_data_source_config <cimport, nodecl> end
global ma_data_source_base: type <cimport, nodecl> = @record{
  cb: ma_data_source_callbacks,
  vtable: *ma_data_source_vtable,
  rangeBegInFrames: uint64,
  rangeEndInFrames: uint64,
  loopBegInFrames: uint64,
  loopEndInFrames: uint64,
  pCurrent: pointer,
  pNext: pointer,
  onGetNext: ma_data_source_get_next_proc
}
global function ma_data_source_init(pConfig: *ma_data_source_config, pDataSource: pointer): ma_result <cimport, nodecl> end
global function ma_data_source_uninit(pDataSource: pointer) <cimport, nodecl> end
global function ma_data_source_read_pcm_frames(pDataSource: pointer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64, loop: ma_bool32): ma_result <cimport, nodecl> end
global function ma_data_source_seek_pcm_frames(pDataSource: pointer, frameCount: uint64, pFramesSeeked: *uint64, loop: ma_bool32): ma_result <cimport, nodecl> end
global function ma_data_source_seek_to_pcm_frame(pDataSource: pointer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_data_source_map(pDataSource: pointer, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_data_source_unmap(pDataSource: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_data_source_get_data_format(pDataSource: pointer, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_data_source_get_cursor_in_pcm_frames(pDataSource: pointer, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_data_source_get_length_in_pcm_frames(pDataSource: pointer, pLength: *uint64): ma_result <cimport, nodecl> end
global ma_audio_buffer_ref: type <cimport, nodecl> = @record{
  ds: ma_data_source_base,
  format: ma_format,
  channels: uint32,
  cursor: uint64,
  sizeInFrames: uint64,
  pData: pointer
}
global function ma_audio_buffer_ref_init(format: ma_format, channels: uint32, pData: pointer, sizeInFrames: uint64, pAudioBufferRef: *ma_audio_buffer_ref): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_uninit(pAudioBufferRef: *ma_audio_buffer_ref) <cimport, nodecl> end
global function ma_audio_buffer_ref_set_data(pAudioBufferRef: *ma_audio_buffer_ref, pData: pointer, sizeInFrames: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_read_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport, nodecl> end
global function ma_audio_buffer_ref_seek_to_pcm_frame(pAudioBufferRef: *ma_audio_buffer_ref, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_map(pAudioBufferRef: *ma_audio_buffer_ref, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_unmap(pAudioBufferRef: *ma_audio_buffer_ref, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_at_end(pAudioBufferRef: *ma_audio_buffer_ref): ma_bool32 <cimport, nodecl> end
global function ma_audio_buffer_ref_get_cursor_in_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_get_length_in_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_get_available_frames(pAudioBufferRef: *ma_audio_buffer_ref, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global ma_audio_buffer_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sizeInFrames: uint64,
  pData: pointer,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_audio_buffer_config_init(format: ma_format, channels: uint32, sizeInFrames: uint64, pData: pointer, pAllocationCallbacks: *ma_allocation_callbacks): ma_audio_buffer_config <cimport, nodecl> end
global ma_audio_buffer: type <cimport, nodecl> = @record{
  ref: ma_audio_buffer_ref,
  allocationCallbacks: ma_allocation_callbacks,
  ownsData: ma_bool32,
  _pExtraData: [1]uint8
}
global function ma_audio_buffer_init(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_init_copy(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_alloc_and_init(pConfig: *ma_audio_buffer_config, ppAudioBuffer: **ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_uninit(pAudioBuffer: *ma_audio_buffer) <cimport, nodecl> end
global function ma_audio_buffer_uninit_and_free(pAudioBuffer: *ma_audio_buffer) <cimport, nodecl> end
global function ma_audio_buffer_read_pcm_frames(pAudioBuffer: *ma_audio_buffer, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport, nodecl> end
global function ma_audio_buffer_seek_to_pcm_frame(pAudioBuffer: *ma_audio_buffer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_map(pAudioBuffer: *ma_audio_buffer, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_unmap(pAudioBuffer: *ma_audio_buffer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_at_end(pAudioBuffer: *ma_audio_buffer): ma_bool32 <cimport, nodecl> end
global function ma_audio_buffer_get_cursor_in_pcm_frames(pAudioBuffer: *ma_audio_buffer, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_get_length_in_pcm_frames(pAudioBuffer: *ma_audio_buffer, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_get_available_frames(pAudioBuffer: *ma_audio_buffer, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global ma_vfs_file: type = @pointer
global ma_seek_origin: type <cimport, nodecl, using> = @enum(cint){
  ma_seek_origin_start = 0,
  ma_seek_origin_current = 1,
  ma_seek_origin_end = 2
}
global ma_file_info: type <cimport, nodecl> = @record{
  sizeInBytes: uint64
}
global ma_vfs_callbacks: type <cimport, nodecl> = @record{
  onOpen: function(pointer, cstring, uint32, *ma_vfs_file): ma_result,
  onOpenW: function(pointer, *cint, uint32, *ma_vfs_file): ma_result,
  onClose: function(pointer, ma_vfs_file): ma_result,
  onRead: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onWrite: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onSeek: function(pointer, ma_vfs_file, int64, ma_seek_origin): ma_result,
  onTell: function(pointer, ma_vfs_file, *int64): ma_result,
  onInfo: function(pointer, ma_vfs_file, *ma_file_info): ma_result
}
global function ma_vfs_open(pVFS: pointer, pFilePath: cstring, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_open_w(pVFS: pointer, pFilePath: *cint, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_close(pVFS: pointer, file: ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_read(pVFS: pointer, file: ma_vfs_file, pDst: pointer, sizeInBytes: csize, pBytesRead: *csize): ma_result <cimport, nodecl> end
global function ma_vfs_write(pVFS: pointer, file: ma_vfs_file, pSrc: pointer, sizeInBytes: csize, pBytesWritten: *csize): ma_result <cimport, nodecl> end
global function ma_vfs_seek(pVFS: pointer, file: ma_vfs_file, offset: int64, origin: ma_seek_origin): ma_result <cimport, nodecl> end
global function ma_vfs_tell(pVFS: pointer, file: ma_vfs_file, pCursor: *int64): ma_result <cimport, nodecl> end
global function ma_vfs_info(pVFS: pointer, file: ma_vfs_file, pInfo: *ma_file_info): ma_result <cimport, nodecl> end
global function ma_vfs_open_and_read_file(pVFS: pointer, pFilePath: cstring, ppData: *pointer, pSize: *csize, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global ma_default_vfs: type <cimport, nodecl> = @record{
  cb: ma_vfs_callbacks,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_default_vfs_init(pVFS: *ma_default_vfs, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global ma_read_proc: type <cimport, nodecl> = @function(pointer, pointer, csize, *csize): ma_result
global ma_seek_proc: type <cimport, nodecl> = @function(pointer, int64, ma_seek_origin): ma_result
global ma_tell_proc: type <cimport, nodecl> = @function(pointer, *int64): ma_result
global ma_resource_format: type <cimport, nodecl, using> = @enum(cint){
  ma_resource_format_wav = 0
}
global ma_encoding_format: type <cimport, nodecl, using> = @enum(cint){
  ma_encoding_format_unknown = 0,
  ma_encoding_format_wav = 1,
  ma_encoding_format_flac = 2,
  ma_encoding_format_mp3 = 3,
  ma_encoding_format_vorbis = 4
}
global ma_decoder: type <cimport, nodecl, forwarddecl> = @record{}
global ma_decoding_backend_config: type <cimport, nodecl> = @record{
  preferredFormat: ma_format
}
global function ma_decoding_backend_config_init(preferredFormat: ma_format): ma_decoding_backend_config <cimport, nodecl> end
global ma_decoding_backend_vtable: type <cimport, nodecl> = @record{
  onInit: function(pointer, ma_read_proc, ma_seek_proc, ma_tell_proc, pointer, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitFile: function(pointer, cstring, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitFileW: function(pointer, *cint, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitMemory: function(pointer, pointer, csize, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onUninit: function(pointer, pointer, *ma_allocation_callbacks),
  onGetChannelMap: function(pointer, pointer, *cuchar, csize): ma_result
}
global ma_decoder_read_proc: type <cimport, nodecl> = @function(*ma_decoder, pointer, csize): csize
global ma_decoder_seek_proc: type <cimport, nodecl> = @function(*ma_decoder, int64, ma_seek_origin): ma_bool32
global ma_decoder_tell_proc: type <cimport, nodecl> = @function(*ma_decoder, *int64): ma_result
global ma_decoder_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  channelMap: [32]cuchar,
  channelMixMode: ma_channel_mix_mode,
  ditherMode: ma_dither_mode,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  allocationCallbacks: ma_allocation_callbacks,
  encodingFormat: ma_encoding_format,
  ppCustomBackendVTables: **ma_decoding_backend_vtable,
  customBackendCount: uint32,
  pCustomBackendUserData: pointer
}
ma_decoder = @record{
  ds: ma_data_source_base,
  pBackend: pointer,
  pBackendVTable: *ma_decoding_backend_vtable,
  pBackendUserData: pointer,
  onRead: ma_decoder_read_proc,
  onSeek: ma_decoder_seek_proc,
  onTell: ma_decoder_tell_proc,
  pUserData: pointer,
  readPointerInPCMFrames: uint64,
  outputFormat: ma_format,
  outputChannels: uint32,
  outputSampleRate: uint32,
  outputChannelMap: [32]cuchar,
  converter: ma_data_converter,
  allocationCallbacks: ma_allocation_callbacks,
  data: union{
    vfs: record{
      pVFS: pointer,
      file: ma_vfs_file
    },
    memory: record{
      pData: *uint8,
      dataSize: csize,
      currentReadPos: csize
    }
  }
}
global function ma_decoder_config_init(outputFormat: ma_format, outputChannels: uint32, outputSampleRate: uint32): ma_decoder_config <cimport, nodecl> end
global function ma_decoder_config_init_default(): ma_decoder_config <cimport, nodecl> end
global function ma_decoder_init(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_uninit(pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_get_cursor_in_pcm_frames(pDecoder: *ma_decoder, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_decoder_get_length_in_pcm_frames(pDecoder: *ma_decoder): uint64 <cimport, nodecl> end
global function ma_decoder_read_pcm_frames(pDecoder: *ma_decoder, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_decoder_seek_to_pcm_frame(pDecoder: *ma_decoder, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_decoder_get_available_frames(pDecoder: *ma_decoder, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global function ma_decode_from_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global function ma_decode_file(pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global function ma_decode_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global function ma_decoder_init_wav(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_flac(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_mp3(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vorbis(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_wav(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_flac(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_mp3(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_vorbis(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_wav(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_flac(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_mp3(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_vorbis(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_wav_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_flac_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_mp3_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_vorbis_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_wav(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_flac(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_mp3(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_vorbis(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_wav_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_flac_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_mp3_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_vorbis_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global ma_encoder: type <cimport, nodecl, forwarddecl> = @record{}
global ma_encoder_write_proc: type <cimport, nodecl> = @function(*ma_encoder, pointer, csize): csize
global ma_encoder_seek_proc: type <cimport, nodecl> = @function(*ma_encoder, cint, ma_seek_origin): ma_bool32
global ma_encoder_init_proc: type <cimport, nodecl> = @function(*ma_encoder): ma_result
global ma_encoder_uninit_proc: type <cimport, nodecl> = @function(*ma_encoder)
global ma_encoder_write_pcm_frames_proc: type <cimport, nodecl> = @function(*ma_encoder, pointer, uint64): uint64
global ma_encoder_config: type <cimport, nodecl> = @record{
  resourceFormat: ma_resource_format,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_encoder_config_init(resourceFormat: ma_resource_format, format: ma_format, channels: uint32, sampleRate: uint32): ma_encoder_config <cimport, nodecl> end
ma_encoder = @record{
  config: ma_encoder_config,
  onWrite: ma_encoder_write_proc,
  onSeek: ma_encoder_seek_proc,
  onInit: ma_encoder_init_proc,
  onUninit: ma_encoder_uninit_proc,
  onWritePCMFrames: ma_encoder_write_pcm_frames_proc,
  pUserData: pointer,
  pInternalEncoder: pointer,
  pFile: pointer
}
global function ma_encoder_init(onWrite: ma_encoder_write_proc, onSeek: ma_encoder_seek_proc, pUserData: pointer, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_init_file(pFilePath: cstring, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_init_file_w(pFilePath: *cint, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_uninit(pEncoder: *ma_encoder) <cimport, nodecl> end
global function ma_encoder_write_pcm_frames(pEncoder: *ma_encoder, pFramesIn: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global ma_waveform_type: type <cimport, nodecl, using> = @enum(cint){
  ma_waveform_type_sine = 0,
  ma_waveform_type_square = 1,
  ma_waveform_type_triangle = 2,
  ma_waveform_type_sawtooth = 3
}
global ma_waveform_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  type: ma_waveform_type,
  amplitude: float64,
  frequency: float64
}
global function ma_waveform_config_init(format: ma_format, channels: uint32, sampleRate: uint32, type: ma_waveform_type, amplitude: float64, frequency: float64): ma_waveform_config <cimport, nodecl> end
global ma_waveform: type <cimport, nodecl> = @record{
  ds: ma_data_source_base,
  config: ma_waveform_config,
  advance: float64,
  time: float64
}
global function ma_waveform_init(pConfig: *ma_waveform_config, pWaveform: *ma_waveform): ma_result <cimport, nodecl> end
global function ma_waveform_uninit(pWaveform: *ma_waveform) <cimport, nodecl> end
global function ma_waveform_read_pcm_frames(pWaveform: *ma_waveform, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_waveform_seek_to_pcm_frame(pWaveform: *ma_waveform, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_waveform_set_amplitude(pWaveform: *ma_waveform, amplitude: float64): ma_result <cimport, nodecl> end
global function ma_waveform_set_frequency(pWaveform: *ma_waveform, frequency: float64): ma_result <cimport, nodecl> end
global function ma_waveform_set_type(pWaveform: *ma_waveform, type: ma_waveform_type): ma_result <cimport, nodecl> end
global function ma_waveform_set_sample_rate(pWaveform: *ma_waveform, sampleRate: uint32): ma_result <cimport, nodecl> end
global ma_noise_type: type <cimport, nodecl, using> = @enum(cint){
  ma_noise_type_white = 0,
  ma_noise_type_pink = 1,
  ma_noise_type_brownian = 2
}
global ma_noise_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  type: ma_noise_type,
  seed: int32,
  amplitude: float64,
  duplicateChannels: ma_bool32
}
global function ma_noise_config_init(format: ma_format, channels: uint32, type: ma_noise_type, seed: int32, amplitude: float64): ma_noise_config <cimport, nodecl> end
global ma_noise: type <cimport, nodecl> = @record{
  ds: ma_data_source_vtable,
  config: ma_noise_config,
  lcg: ma_lcg,
  state: union{
    pink: record{
      bin: [32][16]float64,
      accumulation: [32]float64,
      counter: [32]uint32
    },
    brownian: record{
      accumulation: [32]float64
    }
  }
}
global function ma_noise_init(pConfig: *ma_noise_config, pNoise: *ma_noise): ma_result <cimport, nodecl> end
global function ma_noise_uninit(pNoise: *ma_noise) <cimport, nodecl> end
global function ma_noise_read_pcm_frames(pNoise: *ma_noise, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_noise_set_amplitude(pNoise: *ma_noise, amplitude: float64): ma_result <cimport, nodecl> end
global function ma_noise_set_seed(pNoise: *ma_noise, seed: int32): ma_result <cimport, nodecl> end
global function ma_noise_set_type(pNoise: *ma_noise, type: ma_noise_type): ma_result <cimport, nodecl> end
global ma_paged_audio_buffer_page: type <cimport, nodecl, forwarddecl> = @record{}
ma_paged_audio_buffer_page = @record{
  pNext: *ma_paged_audio_buffer_page,
  sizeInFrames: uint64,
  pAudioData: [1]uint8
}
global ma_paged_audio_buffer_data: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  head: ma_paged_audio_buffer_page,
  pTail: *ma_paged_audio_buffer_page
}
global function ma_paged_audio_buffer_data_init(format: ma_format, channels: uint32, pData: *ma_paged_audio_buffer_data): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_data_uninit(pData: *ma_paged_audio_buffer_data, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_paged_audio_buffer_data_get_head(pData: *ma_paged_audio_buffer_data): *ma_paged_audio_buffer_page <cimport, nodecl> end
global function ma_paged_audio_buffer_data_get_tail(pData: *ma_paged_audio_buffer_data): *ma_paged_audio_buffer_page <cimport, nodecl> end
global function ma_paged_audio_buffer_data_get_length_in_pcm_frames(pData: *ma_paged_audio_buffer_data, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_data_allocate_page(pData: *ma_paged_audio_buffer_data, pageSizeInFrames: uint64, pInitialData: pointer, pAllocationCallbacks: *ma_allocation_callbacks, ppPage: **ma_paged_audio_buffer_page): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_data_free_page(pData: *ma_paged_audio_buffer_data, pPage: *ma_paged_audio_buffer_page, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_data_append_page(pData: *ma_paged_audio_buffer_data, pPage: *ma_paged_audio_buffer_page): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_data_allocate_and_append_page(pData: *ma_paged_audio_buffer_data, pageSizeInFrames: uint32, pInitialData: pointer, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global ma_paged_audio_buffer_config: type <cimport, nodecl> = @record{
  pData: *ma_paged_audio_buffer_data
}
global function ma_paged_audio_buffer_config_init(pData: *ma_paged_audio_buffer_data): ma_paged_audio_buffer_config <cimport, nodecl> end
global ma_paged_audio_buffer: type <cimport, nodecl> = @record{
  ds: ma_data_source_base,
  pData: *ma_paged_audio_buffer_data,
  pCurrent: *ma_paged_audio_buffer_page,
  relativeCursor: uint64,
  absoluteCursor: uint64
}
global function ma_paged_audio_buffer_init(pConfig: *ma_paged_audio_buffer_config, pPagedAudioBuffer: *ma_paged_audio_buffer): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_uninit(pPagedAudioBuffer: *ma_paged_audio_buffer) <cimport, nodecl> end
global function ma_paged_audio_buffer_read_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_seek_to_pcm_frame(pPagedAudioBuffer: *ma_paged_audio_buffer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_get_cursor_in_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_paged_audio_buffer_get_length_in_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_per_channel_f32(pFramesOut: *float32, pFramesIn: *float32, frameCount: uint64, channels: uint32, pChannelGains: *float32) <cimport, nodecl> end
global function ma_apply_volume_factor_per_channel_f32(pFramesOut: *float32, frameCount: uint64, channels: uint32, pChannelGains: *float32) <cimport, nodecl> end
global function ma_get_accumulation_bytes_per_sample(format: ma_format): csize <cimport, nodecl> end
global function ma_get_accumulation_bytes_per_frame(format: ma_format, channels: uint32): csize <cimport, nodecl> end
global ma_gainer_config: type <cimport, nodecl> = @record{
  channels: uint32,
  smoothTimeInFrames: uint32
}
global function ma_gainer_config_init(channels: uint32, smoothTimeInFrames: uint32): ma_gainer_config <cimport, nodecl> end
global ma_gainer: type <cimport, nodecl> = @record{
  config: ma_gainer_config,
  t: uint32,
  pOldGains: *float32,
  pNewGains: *float32,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_gainer_get_heap_size(pConfig: *ma_gainer_config, pHeapSizeInBytes: *csize): ma_result <cimport, nodecl> end
global function ma_gainer_init_preallocated(pConfig: *ma_gainer_config, pHeap: pointer, pGainer: *ma_gainer): ma_result <cimport, nodecl> end
global function ma_gainer_init(pConfig: *ma_gainer_config, pAllocationCallbacks: *ma_allocation_callbacks, pGainer: *ma_gainer): ma_result <cimport, nodecl> end
global function ma_gainer_uninit(pGainer: *ma_gainer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_gainer_process_pcm_frames(pGainer: *ma_gainer, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_gainer_set_gain(pGainer: *ma_gainer, newGain: float32): ma_result <cimport, nodecl> end
global function ma_gainer_set_gains(pGainer: *ma_gainer, pNewGains: *float32): ma_result <cimport, nodecl> end
global ma_node_graph: type <cimport, nodecl, forwarddecl> = @record{}
global ma_node_state: type <cimport, nodecl, using> = @enum(cint){
  ma_node_state_started = 0,
  ma_node_state_stopped = 1
}
global ma_node_vtable: type <cimport, nodecl> = @record{
  onProcess: function(pointer, **float32, *uint32, **float32, *uint32),
  onGetRequiredInputFrameCount: function(pointer, uint32): uint32,
  inputBusCount: uint8,
  outputBusCount: uint8,
  flags: uint32
}
global ma_node_config: type <cimport, nodecl> = @record{
  vtable: *ma_node_vtable,
  initialState: ma_node_state,
  inputBusCount: uint32,
  outputBusCount: uint32,
  pInputChannels: *uint32,
  pOutputChannels: *uint32
}
global function ma_node_config_init(): ma_node_config <cimport, nodecl> end
global ma_node_output_bus: type <cimport, nodecl, forwarddecl> = @record{}
ma_node_output_bus = @record{
  pNode: pointer,
  outputBusIndex: uint8,
  channels: uint8,
  inputNodeInputBusIndex: uint8,
  flags: uint8,
  refCount: uint16,
  isAttached: ma_bool8,
  lock: ma_spinlock,
  volume: float32,
  pNext: *ma_node_output_bus,
  pPrev: *ma_node_output_bus,
  pInputNode: pointer
}
global ma_node_input_bus: type <cimport, nodecl, forwarddecl> = @record{}
ma_node_input_bus = @record{
  head: ma_node_output_bus,
  nextCounter: uint16,
  lock: ma_spinlock,
  channels: uint8
}
global ma_node_base: type <cimport, nodecl, forwarddecl> = @record{}
ma_node_base = @record{
  pNodeGraph: *ma_node_graph,
  vtable: *ma_node_vtable,
  pCachedData: *float32,
  cachedDataCapInFramesPerBus: uint16,
  cachedFrameCountOut: uint16,
  cachedFrameCountIn: uint16,
  consumedFrameCountIn: uint16,
  state: ma_node_state,
  stateTimes: [2]uint64,
  localTime: uint64,
  inputBusCount: uint32,
  outputBusCount: uint32,
  pInputBuses: *ma_node_input_bus,
  pOutputBuses: *ma_node_output_bus,
  _inputBuses: [2]ma_node_input_bus,
  _outputBuses: [2]ma_node_output_bus,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_node_get_heap_size(pConfig: *ma_node_config, pHeapSizeInBytes: *csize): ma_result <cimport, nodecl> end
global function ma_node_init_preallocated(pNodeGraph: *ma_node_graph, pConfig: *ma_node_config, pHeap: pointer, pNode: pointer): ma_result <cimport, nodecl> end
global function ma_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: pointer): ma_result <cimport, nodecl> end
global function ma_node_uninit(pNode: pointer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_node_get_node_graph(pNode: pointer): *ma_node_graph <cimport, nodecl> end
global function ma_node_get_input_bus_count(pNode: pointer): uint32 <cimport, nodecl> end
global function ma_node_get_output_bus_count(pNode: pointer): uint32 <cimport, nodecl> end
global function ma_node_get_input_channels(pNode: pointer, inputBusIndex: uint32): uint32 <cimport, nodecl> end
global function ma_node_get_output_channels(pNode: pointer, outputBusIndex: uint32): uint32 <cimport, nodecl> end
global function ma_node_attach_output_bus(pNode: pointer, outputBusIndex: uint32, pOtherNode: pointer, otherNodeInputBusIndex: uint32): ma_result <cimport, nodecl> end
global function ma_node_detach_output_bus(pNode: pointer, outputBusIndex: uint32): ma_result <cimport, nodecl> end
global function ma_node_detach_all_output_buses(pNode: pointer): ma_result <cimport, nodecl> end
global function ma_node_set_output_bus_volume(pNode: pointer, outputBusIndex: uint32, volume: float32): ma_result <cimport, nodecl> end
global function ma_node_get_output_bus_volume(pNode: pointer, outputBusIndex: uint32): float32 <cimport, nodecl> end
global function ma_node_set_state(pNode: pointer, state: ma_node_state): ma_result <cimport, nodecl> end
global function ma_node_get_state(pNode: pointer): ma_node_state <cimport, nodecl> end
global function ma_node_set_state_time(pNode: pointer, state: ma_node_state, globalTime: uint64): ma_result <cimport, nodecl> end
global function ma_node_get_state_time(pNode: pointer, state: ma_node_state): uint64 <cimport, nodecl> end
global function ma_node_get_state_by_time(pNode: pointer, globalTime: uint64): ma_node_state <cimport, nodecl> end
global function ma_node_get_state_by_time_range(pNode: pointer, globalTimeBeg: uint64, globalTimeEnd: uint64): ma_node_state <cimport, nodecl> end
global function ma_node_get_time(pNode: pointer): uint64 <cimport, nodecl> end
global function ma_node_set_time(pNode: pointer, localTime: uint64): ma_result <cimport, nodecl> end
global ma_node_graph_config: type <cimport, nodecl> = @record{
  channels: uint32
}
global function ma_node_graph_config_init(channels: uint32): ma_node_graph_config <cimport, nodecl> end
ma_node_graph = @record{
  endpoint: ma_node_base,
  isReading: ma_bool8
}
global function ma_node_graph_init(pConfig: *ma_node_graph_config, pAllocationCallbacks: *ma_allocation_callbacks, pNodeGraph: *ma_node_graph): ma_result <cimport, nodecl> end
global function ma_node_graph_uninit(pNodeGraph: *ma_node_graph, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_node_graph_get_endpoint(pNodeGraph: *ma_node_graph): pointer <cimport, nodecl> end
global function ma_node_graph_read_pcm_frames(pNodeGraph: *ma_node_graph, pFramesOut: pointer, frameCount: uint32, pFramesRead: *uint32): ma_result <cimport, nodecl> end
global function ma_node_graph_get_channels(pNodeGraph: *ma_node_graph): uint32 <cimport, nodecl> end
global function ma_node_graph_get_time(pNodeGraph: *ma_node_graph): uint64 <cimport, nodecl> end
global function ma_node_graph_set_time(pNodeGraph: *ma_node_graph, globalTime: uint64): ma_result <cimport, nodecl> end
global ma_data_source_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  pDataSource: pointer,
  looping: ma_bool32
}
global function ma_data_source_node_config_init(pDataSource: pointer, looping: ma_bool32): ma_data_source_node_config <cimport, nodecl> end
global ma_data_source_node: type <cimport, nodecl> = @record{
  base: ma_node_base,
  pDataSource: pointer,
  looping: ma_bool32
}
global function ma_data_source_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_data_source_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pDataSourceNode: *ma_data_source_node): ma_result <cimport, nodecl> end
global function ma_data_source_node_uninit(pDataSourceNode: *ma_data_source_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_data_source_node_set_looping(pDataSourceNode: *ma_data_source_node, looping: ma_bool32): ma_result <cimport, nodecl> end
global function ma_data_source_node_is_looping(pDataSourceNode: *ma_data_source_node): ma_bool32 <cimport, nodecl> end
global ma_splitter_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config
}
global function ma_splitter_node_config_init(channels: uint32): ma_splitter_node_config <cimport, nodecl> end
global ma_splitter_node: type <cimport, nodecl> = @record{
  base: ma_node_base
}
global function ma_splitter_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_splitter_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pSplitterNode: *ma_splitter_node): ma_result <cimport, nodecl> end
global function ma_splitter_node_uninit(pSplitterNode: *ma_splitter_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_resource_manager: type <cimport, nodecl, forwarddecl> = @record{}
global ma_resource_manager_data_buffer_node: type <cimport, nodecl, forwarddecl> = @record{}
global ma_resource_manager_data_buffer: type <cimport, nodecl, forwarddecl> = @record{}
global ma_resource_manager_data_stream: type <cimport, nodecl, forwarddecl> = @record{}
global ma_resource_manager_data_source: type <cimport, nodecl, forwarddecl> = @record{}
global ma_slot_allocator: type <cimport, nodecl> = @record{
  groups: [32]record{
    bitfield: uint32
  },
  slots: [1024]uint32,
  count: uint32
}
global function ma_slot_allocator_init(pAllocator: *ma_slot_allocator): ma_result <cimport, nodecl> end
global function ma_slot_allocator_alloc(pAllocator: *ma_slot_allocator, pSlot: *uint64): ma_result <cimport, nodecl> end
global function ma_slot_allocator_free(pAllocator: *ma_slot_allocator, slot: uint64): ma_result <cimport, nodecl> end
global ma_fence: type <cimport, nodecl> = @record{
  e: ma_event,
  counter: uint32
}
global function ma_fence_init(pFence: *ma_fence): ma_result <cimport, nodecl> end
global function ma_fence_uninit(pFence: *ma_fence) <cimport, nodecl> end
global function ma_fence_acquire(pFence: *ma_fence): ma_result <cimport, nodecl> end
global function ma_fence_release(pFence: *ma_fence): ma_result <cimport, nodecl> end
global function ma_fence_wait(pFence: *ma_fence): ma_result <cimport, nodecl> end
global ma_async_notification: type <cimport, nodecl> = @void
global ma_async_notification_callbacks: type <cimport, nodecl> = @record{
  onSignal: function(pointer)
}
global function ma_async_notification_signal(pNotification: pointer): ma_result <cimport, nodecl> end
global ma_async_notification_poll: type <cimport, nodecl> = @record{
  cb: ma_async_notification_callbacks,
  signalled: ma_bool32
}
global function ma_async_notification_poll_init(pNotificationPoll: *ma_async_notification_poll): ma_result <cimport, nodecl> end
global function ma_async_notification_poll_is_signalled(pNotificationPoll: *ma_async_notification_poll): ma_bool32 <cimport, nodecl> end
global ma_async_notification_event: type <cimport, nodecl> = @record{
  cb: ma_async_notification_callbacks,
  e: ma_event
}
global function ma_async_notification_event_init(pNotificationEvent: *ma_async_notification_event): ma_result <cimport, nodecl> end
global function ma_async_notification_event_uninit(pNotificationEvent: *ma_async_notification_event): ma_result <cimport, nodecl> end
global function ma_async_notification_event_wait(pNotificationEvent: *ma_async_notification_event): ma_result <cimport, nodecl> end
global function ma_async_notification_event_signal(pNotificationEvent: *ma_async_notification_event): ma_result <cimport, nodecl> end
global ma_pipeline_stage_notification: type <cimport, nodecl> = @record{
  pNotification: pointer,
  pFence: *ma_fence
}
global ma_pipeline_notifications: type <cimport, nodecl> = @record{
  init: ma_pipeline_stage_notification,
  done: ma_pipeline_stage_notification
}
global function ma_pipeline_notifications_init(): ma_pipeline_notifications <cimport, nodecl> end
global ma_job: type <cimport, nodecl> = @record{
  toc: union{
    breakup: record{
      code: uint16,
      slot: uint16,
      refcount: uint32
    },
    allocation: uint64
  },
  next: uint64,
  order: uint32,
  __unnamed1: union{
    loadDataBufferNode: record{
      pDataBufferNode: *ma_resource_manager_data_buffer_node,
      pFilePath: cstring,
      pFilePathW: *cint,
      decode: ma_bool32,
      pInitNotification: pointer,
      pDoneNotification: pointer,
      pInitFence: *ma_fence,
      pDoneFence: *ma_fence
    },
    freeDataBufferNode: record{
      pDataBufferNode: *ma_resource_manager_data_buffer_node,
      pDoneNotification: pointer,
      pDoneFence: *ma_fence
    },
    pageDataBufferNode: record{
      pDataBufferNode: *ma_resource_manager_data_buffer_node,
      pDecoder: *ma_decoder,
      pDoneNotification: pointer,
      pDoneFence: *ma_fence
    },
    loadDataBuffer: record{
      pDataBuffer: *ma_resource_manager_data_buffer,
      pInitNotification: pointer,
      pDoneNotification: pointer,
      pInitFence: *ma_fence,
      pDoneFence: *ma_fence
    },
    freeDataBuffer: record{
      pDataBuffer: *ma_resource_manager_data_buffer,
      pDoneNotification: pointer,
      pDoneFence: *ma_fence
    },
    loadDataStream: record{
      pDataStream: *ma_resource_manager_data_stream,
      pFilePath: cstring,
      pFilePathW: *cint,
      pInitNotification: pointer,
      pInitFence: *ma_fence
    },
    freeDataStream: record{
      pDataStream: *ma_resource_manager_data_stream,
      pDoneNotification: pointer,
      pDoneFence: *ma_fence
    },
    pageDataStream: record{
      pDataStream: *ma_resource_manager_data_stream,
      pageIndex: uint32
    },
    seekDataStream: record{
      pDataStream: *ma_resource_manager_data_stream,
      frameIndex: uint64
    },
    custom: record{
      data0: usize,
      data1: usize
    }
  }
}
global function ma_job_init(code: uint16): ma_job <cimport, nodecl> end
global ma_job_queue: type <cimport, nodecl> = @record{
  flags: uint32,
  head: uint64,
  tail: uint64,
  sem: ma_semaphore,
  allocator: ma_slot_allocator,
  jobs: [1024]ma_job
}
global function ma_job_queue_init(flags: uint32, pQueue: *ma_job_queue): ma_result <cimport, nodecl> end
global function ma_job_queue_uninit(pQueue: *ma_job_queue): ma_result <cimport, nodecl> end
global function ma_job_queue_post(pQueue: *ma_job_queue, pJob: *ma_job): ma_result <cimport, nodecl> end
global function ma_job_queue_next(pQueue: *ma_job_queue, pJob: *ma_job): ma_result <cimport, nodecl> end
global ma_resource_manager_data_supply_type: type <cimport, nodecl, using> = @enum(cint){
  ma_resource_manager_data_supply_type_unknown = 0,
  ma_resource_manager_data_supply_type_encoded = 1,
  ma_resource_manager_data_supply_type_decoded = 2,
  ma_resource_manager_data_supply_type_decoded_paged = 3
}
global ma_resource_manager_data_supply: type <cimport, nodecl> = @record{
  type: ma_resource_manager_data_supply_type,
  __unnamed1: union{
    encoded: record{
      pData: pointer,
      sizeInBytes: csize
    },
    decoded: record{
      pData: pointer,
      totalFrameCount: uint64,
      decodedFrameCount: uint64,
      format: ma_format,
      channels: uint32,
      sampleRate: uint32
    },
    decodedPaged: record{
      data: ma_paged_audio_buffer_data,
      decodedFrameCount: uint64,
      sampleRate: uint32
    }
  }
}
ma_resource_manager_data_buffer_node = @record{
  hashedName32: uint32,
  refCount: uint32,
  result: ma_result,
  executionCounter: uint32,
  executionPointer: uint32,
  isDataOwnedByResourceManager: ma_bool32,
  data: ma_resource_manager_data_supply,
  pParent: *ma_resource_manager_data_buffer_node,
  pChildLo: *ma_resource_manager_data_buffer_node,
  pChildHi: *ma_resource_manager_data_buffer_node
}
ma_resource_manager_data_buffer = @record{
  ds: ma_data_source_base,
  pResourceManager: *ma_resource_manager,
  pNode: *ma_resource_manager_data_buffer_node,
  flags: uint32,
  executionCounter: uint32,
  executionPointer: uint32,
  seekTargetInPCMFrames: uint64,
  seekToCursorOnNextRead: ma_bool32,
  result: ma_result,
  isLooping: ma_bool32,
  isConnectorInitialized: ma_bool32,
  connector: union{
    decoder: ma_decoder,
    buffer: ma_audio_buffer,
    pagedBuffer: ma_paged_audio_buffer
  }
}
ma_resource_manager_data_stream = @record{
  ds: ma_data_source_base,
  pResourceManager: *ma_resource_manager,
  flags: uint32,
  decoder: ma_decoder,
  isDecoderInitialized: ma_bool32,
  totalLengthInPCMFrames: uint64,
  relativeCursor: uint32,
  absoluteCursor: uint64,
  currentPageIndex: uint32,
  executionCounter: uint32,
  executionPointer: uint32,
  isLooping: ma_bool32,
  pPageData: pointer,
  pageFrameCount: [2]uint32,
  result: ma_result,
  isDecoderAtEnd: ma_bool32,
  isPageValid: [2]ma_bool32,
  seekCounter: ma_bool32
}
ma_resource_manager_data_source = @record{
  __unnamed1: union{
    buffer: ma_resource_manager_data_buffer,
    stream: ma_resource_manager_data_stream
  },
  flags: uint32,
  executionCounter: uint32,
  executionPointer: uint32
}
global ma_resource_manager_config: type <cimport, nodecl> = @record{
  allocationCallbacks: ma_allocation_callbacks,
  pLog: *ma_log,
  decodedFormat: ma_format,
  decodedChannels: uint32,
  decodedSampleRate: uint32,
  jobThreadCount: uint32,
  flags: uint32,
  pVFS: pointer,
  ppCustomDecodingBackendVTables: **ma_decoding_backend_vtable,
  customDecodingBackendCount: uint32,
  pCustomDecodingBackendUserData: pointer
}
global function ma_resource_manager_config_init(): ma_resource_manager_config <cimport, nodecl> end
ma_resource_manager = @record{
  config: ma_resource_manager_config,
  pRootDataBufferNode: *ma_resource_manager_data_buffer_node,
  dataBufferBSTLock: ma_mutex,
  jobThreads: [64]ma_thread,
  jobQueue: ma_job_queue,
  defaultVFS: ma_default_vfs,
  log: ma_log
}
global function ma_resource_manager_init(pConfig: *ma_resource_manager_config, pResourceManager: *ma_resource_manager): ma_result <cimport, nodecl> end
global function ma_resource_manager_uninit(pResourceManager: *ma_resource_manager) <cimport, nodecl> end
global function ma_resource_manager_get_log(pResourceManager: *ma_resource_manager): *ma_log <cimport, nodecl> end
global function ma_resource_manager_register_file(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_register_file_w(pResourceManager: *ma_resource_manager, pFilePath: *cint, flags: uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_register_decoded_data(pResourceManager: *ma_resource_manager, pName: cstring, pData: pointer, frameCount: uint64, format: ma_format, channels: uint32, sampleRate: uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_register_decoded_data_w(pResourceManager: *ma_resource_manager, pName: *cint, pData: pointer, frameCount: uint64, format: ma_format, channels: uint32, sampleRate: uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_register_encoded_data(pResourceManager: *ma_resource_manager, pName: cstring, pData: pointer, sizeInBytes: csize): ma_result <cimport, nodecl> end
global function ma_resource_manager_register_encoded_data_w(pResourceManager: *ma_resource_manager, pName: *cint, pData: pointer, sizeInBytes: csize): ma_result <cimport, nodecl> end
global function ma_resource_manager_unregister_file(pResourceManager: *ma_resource_manager, pFilePath: cstring): ma_result <cimport, nodecl> end
global function ma_resource_manager_unregister_file_w(pResourceManager: *ma_resource_manager, pFilePath: *cint): ma_result <cimport, nodecl> end
global function ma_resource_manager_unregister_data(pResourceManager: *ma_resource_manager, pName: cstring): ma_result <cimport, nodecl> end
global function ma_resource_manager_unregister_data_w(pResourceManager: *ma_resource_manager, pName: *cint): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_init(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_init_w(pResourceManager: *ma_resource_manager, pFilePath: *cint, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_init_copy(pResourceManager: *ma_resource_manager, pExistingDataBuffer: *ma_resource_manager_data_buffer, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_uninit(pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_read_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_seek_to_pcm_frame(pDataBuffer: *ma_resource_manager_data_buffer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_get_data_format(pDataBuffer: *ma_resource_manager_data_buffer, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_get_length_in_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_result(pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_set_looping(pDataBuffer: *ma_resource_manager_data_buffer, isLooping: ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_get_looping(pDataBuffer: *ma_resource_manager_data_buffer, pIsLooping: *ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_buffer_get_available_frames(pDataBuffer: *ma_resource_manager_data_buffer, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_init(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataStream: *ma_resource_manager_data_stream): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_init_w(pResourceManager: *ma_resource_manager, pFilePath: *cint, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataStream: *ma_resource_manager_data_stream): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_uninit(pDataStream: *ma_resource_manager_data_stream): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_read_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_seek_to_pcm_frame(pDataStream: *ma_resource_manager_data_stream, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_map(pDataStream: *ma_resource_manager_data_stream, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_unmap(pDataStream: *ma_resource_manager_data_stream, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_get_data_format(pDataStream: *ma_resource_manager_data_stream, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_get_cursor_in_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_get_length_in_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_result(pDataStream: *ma_resource_manager_data_stream): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_set_looping(pDataStream: *ma_resource_manager_data_stream, isLooping: ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_get_looping(pDataStream: *ma_resource_manager_data_stream, pIsLooping: *ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_stream_get_available_frames(pDataStream: *ma_resource_manager_data_stream, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_init(pResourceManager: *ma_resource_manager, pName: cstring, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataSource: *ma_resource_manager_data_source): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_init_w(pResourceManager: *ma_resource_manager, pName: *cint, flags: uint32, pNotifications: *ma_pipeline_notifications, pDataSource: *ma_resource_manager_data_source): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_init_copy(pResourceManager: *ma_resource_manager, pExistingDataSource: *ma_resource_manager_data_source, pDataSource: *ma_resource_manager_data_source): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_uninit(pDataSource: *ma_resource_manager_data_source): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_read_pcm_frames(pDataSource: *ma_resource_manager_data_source, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_seek_to_pcm_frame(pDataSource: *ma_resource_manager_data_source, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_map(pDataSource: *ma_resource_manager_data_source, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_unmap(pDataSource: *ma_resource_manager_data_source, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_get_data_format(pDataSource: *ma_resource_manager_data_source, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_get_cursor_in_pcm_frames(pDataSource: *ma_resource_manager_data_source, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_get_length_in_pcm_frames(pDataSource: *ma_resource_manager_data_source, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_result(pDataSource: *ma_resource_manager_data_source): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_set_looping(pDataSource: *ma_resource_manager_data_source, isLooping: ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_get_looping(pDataSource: *ma_resource_manager_data_source, pIsLooping: *ma_bool32): ma_result <cimport, nodecl> end
global function ma_resource_manager_data_source_get_available_frames(pDataSource: *ma_resource_manager_data_source, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global function ma_resource_manager_post_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport, nodecl> end
global function ma_resource_manager_post_job_quit(pResourceManager: *ma_resource_manager): ma_result <cimport, nodecl> end
global function ma_resource_manager_next_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport, nodecl> end
global function ma_resource_manager_process_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport, nodecl> end
global function ma_resource_manager_process_next_job(pResourceManager: *ma_resource_manager): ma_result <cimport, nodecl> end
global ma_engine: type <cimport, nodecl, forwarddecl> = @record{}
global ma_sound: type <cimport, nodecl, forwarddecl> = @record{}
global ma_pan_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_pan_mode_balance = 0,
  ma_pan_mode_pan = 1
}
global ma_panner_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  mode: ma_pan_mode,
  pan: float32
}
global function ma_panner_config_init(format: ma_format, channels: uint32): ma_panner_config <cimport, nodecl> end
global ma_panner: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  mode: ma_pan_mode,
  pan: float32
}
global function ma_panner_init(pConfig: *ma_panner_config, pPanner: *ma_panner): ma_result <cimport, nodecl> end
global function ma_panner_process_pcm_frames(pPanner: *ma_panner, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_panner_set_mode(pPanner: *ma_panner, mode: ma_pan_mode) <cimport, nodecl> end
global function ma_panner_set_pan(pPanner: *ma_panner, pan: float32) <cimport, nodecl> end
global ma_fader_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32
}
global function ma_fader_config_init(format: ma_format, channels: uint32, sampleRate: uint32): ma_fader_config <cimport, nodecl> end
global ma_fader: type <cimport, nodecl> = @record{
  config: ma_fader_config,
  volumeBeg: float32,
  volumeEnd: float32,
  lengthInFrames: uint64,
  cursorInFrames: uint64
}
global function ma_fader_init(pConfig: *ma_fader_config, pFader: *ma_fader): ma_result <cimport, nodecl> end
global function ma_fader_process_pcm_frames(pFader: *ma_fader, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_fader_get_data_format(pFader: *ma_fader, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32) <cimport, nodecl> end
global function ma_fader_set_fade(pFader: *ma_fader, volumeBeg: float32, volumeEnd: float32, lengthInFrames: uint64) <cimport, nodecl> end
global function ma_fader_get_current_volume(pFader: *ma_fader): float32 <cimport, nodecl> end
global ma_vec3f: type <cimport, nodecl> = @record{
  x: float32,
  y: float32,
  z: float32
}
global ma_attenuation_model: type <cimport, nodecl, using> = @enum(cint){
  ma_attenuation_model_none = 0,
  ma_attenuation_model_inverse = 1,
  ma_attenuation_model_linear = 2,
  ma_attenuation_model_exponential = 3
}
global ma_positioning: type <cimport, nodecl, using> = @enum(cint){
  ma_positioning_absolute = 0,
  ma_positioning_relative = 1
}
global ma_handedness: type <cimport, nodecl, using> = @enum(cint){
  ma_handedness_right = 0,
  ma_handedness_left = 1
}
global ma_spatializer_listener_config: type <cimport, nodecl> = @record{
  channelsOut: uint32,
  pChannelMapOut: *cuchar,
  handedness: ma_handedness,
  coneInnerAngleInRadians: float32,
  coneOuterAngleInRadians: float32,
  coneOuterGain: float32,
  speedOfSound: float32,
  worldUp: ma_vec3f
}
global function ma_spatializer_listener_config_init(channelsOut: uint32): ma_spatializer_listener_config <cimport, nodecl> end
global ma_spatializer_listener: type <cimport, nodecl> = @record{
  config: ma_spatializer_listener_config,
  position: ma_vec3f,
  direction: ma_vec3f,
  velocity: ma_vec3f,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_spatializer_listener_get_heap_size(pConfig: *ma_spatializer_listener_config, pHeapSizeInBytes: *csize): ma_result <cimport, nodecl> end
global function ma_spatializer_listener_init_preallocated(pConfig: *ma_spatializer_listener_config, pHeap: pointer, pListener: *ma_spatializer_listener): ma_result <cimport, nodecl> end
global function ma_spatializer_listener_init(pConfig: *ma_spatializer_listener_config, pAllocationCallbacks: *ma_allocation_callbacks, pListener: *ma_spatializer_listener): ma_result <cimport, nodecl> end
global function ma_spatializer_listener_uninit(pListener: *ma_spatializer_listener, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_spatializer_listener_get_channel_map(pListener: *ma_spatializer_listener): *cuchar <cimport, nodecl> end
global function ma_spatializer_listener_set_cone(pListener: *ma_spatializer_listener, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_cone(pListener: *ma_spatializer_listener, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32) <cimport, nodecl> end
global function ma_spatializer_listener_set_position(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_position(pListener: *ma_spatializer_listener): ma_vec3f <cimport, nodecl> end
global function ma_spatializer_listener_set_direction(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_direction(pListener: *ma_spatializer_listener): ma_vec3f <cimport, nodecl> end
global function ma_spatializer_listener_set_velocity(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_velocity(pListener: *ma_spatializer_listener): ma_vec3f <cimport, nodecl> end
global function ma_spatializer_listener_set_speed_of_sound(pListener: *ma_spatializer_listener, speedOfSound: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_speed_of_sound(pListener: *ma_spatializer_listener): float32 <cimport, nodecl> end
global function ma_spatializer_listener_set_world_up(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_listener_get_world_up(pListener: *ma_spatializer_listener): ma_vec3f <cimport, nodecl> end
global ma_spatializer_config: type <cimport, nodecl> = @record{
  channelsIn: uint32,
  channelsOut: uint32,
  pChannelMapIn: *cuchar,
  attenuationModel: ma_attenuation_model,
  positioning: ma_positioning,
  handedness: ma_handedness,
  minGain: float32,
  maxGain: float32,
  minDistance: float32,
  maxDistance: float32,
  rolloff: float32,
  coneInnerAngleInRadians: float32,
  coneOuterAngleInRadians: float32,
  coneOuterGain: float32,
  dopplerFactor: float32,
  gainSmoothTimeInFrames: uint32
}
global function ma_spatializer_config_init(channelsIn: uint32, channelsOut: uint32): ma_spatializer_config <cimport, nodecl> end
global ma_spatializer: type <cimport, nodecl> = @record{
  config: ma_spatializer_config,
  position: ma_vec3f,
  direction: ma_vec3f,
  velocity: ma_vec3f,
  dopplerPitch: float32,
  gainer: ma_gainer,
  pNewChannelGainsOut: *float32,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_spatializer_get_heap_size(pConfig: *ma_spatializer_config, pHeapSizeInBytes: *csize): ma_result <cimport, nodecl> end
global function ma_spatializer_init_preallocated(pConfig: *ma_spatializer_config, pHeap: pointer, pSpatializer: *ma_spatializer): ma_result <cimport, nodecl> end
global function ma_spatializer_init(pConfig: *ma_spatializer_config, pAllocationCallbacks: *ma_allocation_callbacks, pSpatializer: *ma_spatializer): ma_result <cimport, nodecl> end
global function ma_spatializer_uninit(pSpatializer: *ma_spatializer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_spatializer_process_pcm_frames(pSpatializer: *ma_spatializer, pListener: *ma_spatializer_listener, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_spatializer_get_input_channels(pSpatializer: *ma_spatializer): uint32 <cimport, nodecl> end
global function ma_spatializer_get_output_channels(pSpatializer: *ma_spatializer): uint32 <cimport, nodecl> end
global function ma_spatializer_set_attenuation_model(pSpatializer: *ma_spatializer, attenuationModel: ma_attenuation_model) <cimport, nodecl> end
global function ma_spatializer_get_attenuation_model(pSpatializer: *ma_spatializer): ma_attenuation_model <cimport, nodecl> end
global function ma_spatializer_set_positioning(pSpatializer: *ma_spatializer, positioning: ma_positioning) <cimport, nodecl> end
global function ma_spatializer_get_positioning(pSpatializer: *ma_spatializer): ma_positioning <cimport, nodecl> end
global function ma_spatializer_set_rolloff(pSpatializer: *ma_spatializer, rolloff: float32) <cimport, nodecl> end
global function ma_spatializer_get_rolloff(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_min_gain(pSpatializer: *ma_spatializer, minGain: float32) <cimport, nodecl> end
global function ma_spatializer_get_min_gain(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_max_gain(pSpatializer: *ma_spatializer, maxGain: float32) <cimport, nodecl> end
global function ma_spatializer_get_max_gain(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_min_distance(pSpatializer: *ma_spatializer, minDistance: float32) <cimport, nodecl> end
global function ma_spatializer_get_min_distance(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_max_distance(pSpatializer: *ma_spatializer, maxDistance: float32) <cimport, nodecl> end
global function ma_spatializer_get_max_distance(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_cone(pSpatializer: *ma_spatializer, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32) <cimport, nodecl> end
global function ma_spatializer_get_cone(pSpatializer: *ma_spatializer, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32) <cimport, nodecl> end
global function ma_spatializer_set_doppler_factor(pSpatializer: *ma_spatializer, dopplerFactor: float32) <cimport, nodecl> end
global function ma_spatializer_get_doppler_factor(pSpatializer: *ma_spatializer): float32 <cimport, nodecl> end
global function ma_spatializer_set_position(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_get_position(pSpatializer: *ma_spatializer): ma_vec3f <cimport, nodecl> end
global function ma_spatializer_set_direction(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_get_direction(pSpatializer: *ma_spatializer): ma_vec3f <cimport, nodecl> end
global function ma_spatializer_set_velocity(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_spatializer_get_velocity(pSpatializer: *ma_spatializer): ma_vec3f <cimport, nodecl> end
global ma_engine_node_type: type <cimport, nodecl, using> = @enum(cint){
  ma_engine_node_type_sound = 0,
  ma_engine_node_type_group = 1
}
global ma_engine_node_config: type <cimport, nodecl> = @record{
  pEngine: *ma_engine,
  type: ma_engine_node_type,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRate: uint32,
  isPitchDisabled: ma_bool8,
  isSpatializationDisabled: ma_bool8,
  pinnedListenerIndex: uint8
}
global function ma_engine_node_config_init(pEngine: *ma_engine, type: ma_engine_node_type, flags: uint32): ma_engine_node_config <cimport, nodecl> end
global ma_engine_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  pEngine: *ma_engine,
  sampleRate: uint32,
  fader: ma_fader,
  resampler: ma_resampler,
  spatializer: ma_spatializer,
  panner: ma_panner,
  pitch: float32,
  oldPitch: float32,
  oldDopplerPitch: float32,
  isPitchDisabled: ma_bool8,
  isSpatializationDisabled: ma_bool8,
  pinnedListenerIndex: uint8,
  _ownsHeap: ma_bool8,
  _pHeap: pointer
}
global function ma_engine_node_get_heap_size(pConfig: *ma_engine_node_config, pHeapSizeInBytes: *csize): ma_result <cimport, nodecl> end
global function ma_engine_node_init_preallocated(pConfig: *ma_engine_node_config, pHeap: pointer, pEngineNode: *ma_engine_node): ma_result <cimport, nodecl> end
global function ma_engine_node_init(pConfig: *ma_engine_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pEngineNode: *ma_engine_node): ma_result <cimport, nodecl> end
global function ma_engine_node_uninit(pEngineNode: *ma_engine_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_sound_config: type <cimport, nodecl> = @record{
  pFilePath: cstring,
  pFilePathW: *cint,
  pDataSource: pointer,
  pInitialAttachment: pointer,
  initialAttachmentInputBusIndex: uint32,
  channelsIn: uint32,
  channelsOut: uint32,
  flags: uint32,
  pDoneFence: *ma_fence
}
global function ma_sound_config_init(): ma_sound_config <cimport, nodecl> end
ma_sound = @record{
  engineNode: ma_engine_node,
  pDataSource: pointer,
  seekTarget: uint64,
  isLooping: ma_bool8,
  atEnd: ma_bool8,
  ownsDataSource: ma_bool8,
  pResourceManagerDataSource: *ma_resource_manager_data_source
}
global ma_sound_inlined: type <cimport, nodecl, forwarddecl> = @record{}
ma_sound_inlined = @record{
  sound: ma_sound,
  pNext: *ma_sound_inlined,
  pPrev: *ma_sound_inlined
}
global ma_sound_group_config: type = @ma_sound_config
global ma_sound_group: type = @ma_sound
global function ma_sound_group_config_init(): ma_sound_group_config <cimport, nodecl> end
global ma_engine_config: type <cimport, nodecl> = @record{
  pResourceManager: *ma_resource_manager,
  pContext: *ma_context,
  pDevice: *ma_device,
  pLog: *ma_log,
  listenerCount: uint32,
  channels: uint32,
  sampleRate: uint32,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  gainSmoothTimeInFrames: uint32,
  gainSmoothTimeInMilliseconds: uint32,
  pPlaybackDeviceID: *ma_device_id,
  allocationCallbacks: ma_allocation_callbacks,
  noAutoStart: ma_bool32,
  pResourceManagerVFS: pointer
}
global function ma_engine_config_init(): ma_engine_config <cimport, nodecl> end
ma_engine = @record{
  nodeGraph: ma_node_graph,
  pResourceManager: *ma_resource_manager,
  pDevice: *ma_device,
  pLog: *ma_log,
  listenerCount: uint32,
  listeners: [4]ma_spatializer_listener,
  allocationCallbacks: ma_allocation_callbacks,
  ownsResourceManager: ma_bool8,
  ownsDevice: ma_bool8,
  inlinedSoundLock: ma_mutex,
  pInlinedSoundHead: *ma_sound_inlined,
  inlinedSoundCount: uint32,
  gainSmoothTimeInFrames: uint32
}
global function ma_engine_init(pConfig: *ma_engine_config, pEngine: *ma_engine): ma_result <cimport, nodecl> end
global function ma_engine_uninit(pEngine: *ma_engine) <cimport, nodecl> end
global function ma_engine_data_callback(pEngine: *ma_engine, pOutput: pointer, pInput: pointer, frameCount: uint32) <cimport, nodecl> end
global function ma_engine_get_device(pEngine: *ma_engine): *ma_device <cimport, nodecl> end
global function ma_engine_get_log(pEngine: *ma_engine): *ma_log <cimport, nodecl> end
global function ma_engine_get_endpoint(pEngine: *ma_engine): pointer <cimport, nodecl> end
global function ma_engine_get_time(pEngine: *ma_engine): uint64 <cimport, nodecl> end
global function ma_engine_set_time(pEngine: *ma_engine, globalTime: uint64): uint64 <cimport, nodecl> end
global function ma_engine_get_channels(pEngine: *ma_engine): uint32 <cimport, nodecl> end
global function ma_engine_get_sample_rate(pEngine: *ma_engine): uint32 <cimport, nodecl> end
global function ma_engine_start(pEngine: *ma_engine): ma_result <cimport, nodecl> end
global function ma_engine_stop(pEngine: *ma_engine): ma_result <cimport, nodecl> end
global function ma_engine_set_volume(pEngine: *ma_engine, volume: float32): ma_result <cimport, nodecl> end
global function ma_engine_set_gain_db(pEngine: *ma_engine, gainDB: float32): ma_result <cimport, nodecl> end
global function ma_engine_get_listener_count(pEngine: *ma_engine): uint32 <cimport, nodecl> end
global function ma_engine_find_closest_listener(pEngine: *ma_engine, absolutePosX: float32, absolutePosY: float32, absolutePosZ: float32): uint32 <cimport, nodecl> end
global function ma_engine_listener_set_position(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_engine_listener_get_position(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport, nodecl> end
global function ma_engine_listener_set_direction(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_engine_listener_get_direction(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport, nodecl> end
global function ma_engine_listener_set_velocity(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_engine_listener_get_velocity(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport, nodecl> end
global function ma_engine_listener_set_cone(pEngine: *ma_engine, listenerIndex: uint32, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32) <cimport, nodecl> end
global function ma_engine_listener_get_cone(pEngine: *ma_engine, listenerIndex: uint32, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32) <cimport, nodecl> end
global function ma_engine_listener_set_world_up(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_engine_listener_get_world_up(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport, nodecl> end
global function ma_engine_play_sound(pEngine: *ma_engine, pFilePath: cstring, pGroup: *ma_sound_group): ma_result <cimport, nodecl> end
global function ma_sound_init_from_file(pEngine: *ma_engine, pFilePath: cstring, flags: uint32, pGroup: *ma_sound_group, pDoneFence: *ma_fence, pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_init_from_file_w(pEngine: *ma_engine, pFilePath: *cint, flags: uint32, pGroup: *ma_sound_group, pDoneFence: *ma_fence, pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_init_copy(pEngine: *ma_engine, pExistingSound: *ma_sound, flags: uint32, pGroup: *ma_sound_group, pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_init_from_data_source(pEngine: *ma_engine, pDataSource: pointer, flags: uint32, pGroup: *ma_sound_group, pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_init_ex(pEngine: *ma_engine, pConfig: *ma_sound_config, pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_uninit(pSound: *ma_sound) <cimport, nodecl> end
global function ma_sound_get_engine(pSound: *ma_sound): *ma_engine <cimport, nodecl> end
global function ma_sound_get_data_source(pSound: *ma_sound): pointer <cimport, nodecl> end
global function ma_sound_start(pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_stop(pSound: *ma_sound): ma_result <cimport, nodecl> end
global function ma_sound_set_volume(pSound: *ma_sound, volume: float32): ma_result <cimport, nodecl> end
global function ma_sound_set_gain_db(pSound: *ma_sound, gainDB: float32): ma_result <cimport, nodecl> end
global function ma_sound_set_pan(pSound: *ma_sound, pan: float32) <cimport, nodecl> end
global function ma_sound_set_pan_mode(pSound: *ma_sound, panMode: ma_pan_mode) <cimport, nodecl> end
global function ma_sound_set_pitch(pSound: *ma_sound, pitch: float32) <cimport, nodecl> end
global function ma_sound_set_spatialization_enabled(pSound: *ma_sound, enabled: ma_bool32) <cimport, nodecl> end
global function ma_sound_set_pinned_listener_index(pSound: *ma_sound, listenerIndex: uint8) <cimport, nodecl> end
global function ma_sound_get_pinned_listener_index(pSound: *ma_sound): uint8 <cimport, nodecl> end
global function ma_sound_set_position(pSound: *ma_sound, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_get_position(pSound: *ma_sound): ma_vec3f <cimport, nodecl> end
global function ma_sound_set_direction(pSound: *ma_sound, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_get_direction(pSound: *ma_sound): ma_vec3f <cimport, nodecl> end
global function ma_sound_set_velocity(pSound: *ma_sound, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_get_velocity(pSound: *ma_sound): ma_vec3f <cimport, nodecl> end
global function ma_sound_set_attenuation_model(pSound: *ma_sound, attenuationModel: ma_attenuation_model) <cimport, nodecl> end
global function ma_sound_get_attenuation_model(pSound: *ma_sound): ma_attenuation_model <cimport, nodecl> end
global function ma_sound_set_positioning(pSound: *ma_sound, positioning: ma_positioning) <cimport, nodecl> end
global function ma_sound_get_positioning(pSound: *ma_sound): ma_positioning <cimport, nodecl> end
global function ma_sound_set_rolloff(pSound: *ma_sound, rolloff: float32) <cimport, nodecl> end
global function ma_sound_get_rolloff(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_min_gain(pSound: *ma_sound, minGain: float32) <cimport, nodecl> end
global function ma_sound_get_min_gain(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_max_gain(pSound: *ma_sound, maxGain: float32) <cimport, nodecl> end
global function ma_sound_get_max_gain(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_min_distance(pSound: *ma_sound, minDistance: float32) <cimport, nodecl> end
global function ma_sound_get_min_distance(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_max_distance(pSound: *ma_sound, maxDistance: float32) <cimport, nodecl> end
global function ma_sound_get_max_distance(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_cone(pSound: *ma_sound, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32) <cimport, nodecl> end
global function ma_sound_get_cone(pSound: *ma_sound, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32) <cimport, nodecl> end
global function ma_sound_set_doppler_factor(pSound: *ma_sound, dopplerFactor: float32) <cimport, nodecl> end
global function ma_sound_get_doppler_factor(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_fade_in_pcm_frames(pSound: *ma_sound, volumeBeg: float32, volumeEnd: float32, fadeLengthInFrames: uint64) <cimport, nodecl> end
global function ma_sound_set_fade_in_milliseconds(pSound: *ma_sound, volumeBeg: float32, volumeEnd: float32, fadeLengthInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_get_current_fade_volume(pSound: *ma_sound): float32 <cimport, nodecl> end
global function ma_sound_set_start_time_in_pcm_frames(pSound: *ma_sound, absoluteGlobalTimeInFrames: uint64) <cimport, nodecl> end
global function ma_sound_set_start_time_in_milliseconds(pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_set_stop_time_in_pcm_frames(pSound: *ma_sound, absoluteGlobalTimeInFrames: uint64) <cimport, nodecl> end
global function ma_sound_set_stop_time_in_milliseconds(pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_is_playing(pSound: *ma_sound): ma_bool32 <cimport, nodecl> end
global function ma_sound_get_time_in_pcm_frames(pSound: *ma_sound): uint64 <cimport, nodecl> end
global function ma_sound_set_looping(pSound: *ma_sound, isLooping: ma_bool8) <cimport, nodecl> end
global function ma_sound_is_looping(pSound: *ma_sound): ma_bool32 <cimport, nodecl> end
global function ma_sound_at_end(pSound: *ma_sound): ma_bool32 <cimport, nodecl> end
global function ma_sound_seek_to_pcm_frame(pSound: *ma_sound, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_sound_get_data_format(pSound: *ma_sound, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_sound_get_cursor_in_pcm_frames(pSound: *ma_sound, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_sound_get_length_in_pcm_frames(pSound: *ma_sound, pLength: *uint64): ma_result <cimport, nodecl> end
global function ma_sound_group_init(pEngine: *ma_engine, flags: uint32, pParentGroup: *ma_sound_group, pGroup: *ma_sound_group): ma_result <cimport, nodecl> end
global function ma_sound_group_init_ex(pEngine: *ma_engine, pConfig: *ma_sound_group_config, pGroup: *ma_sound_group): ma_result <cimport, nodecl> end
global function ma_sound_group_uninit(pGroup: *ma_sound_group) <cimport, nodecl> end
global function ma_sound_group_get_engine(pGroup: *ma_sound_group): *ma_engine <cimport, nodecl> end
global function ma_sound_group_start(pGroup: *ma_sound_group): ma_result <cimport, nodecl> end
global function ma_sound_group_stop(pGroup: *ma_sound_group): ma_result <cimport, nodecl> end
global function ma_sound_group_set_volume(pGroup: *ma_sound_group, volume: float32): ma_result <cimport, nodecl> end
global function ma_sound_group_set_gain_db(pGroup: *ma_sound_group, gainDB: float32): ma_result <cimport, nodecl> end
global function ma_sound_group_set_pan(pGroup: *ma_sound_group, pan: float32) <cimport, nodecl> end
global function ma_sound_group_set_pan_mode(pGroup: *ma_sound_group, panMode: ma_pan_mode) <cimport, nodecl> end
global function ma_sound_group_set_pitch(pGroup: *ma_sound_group, pitch: float32) <cimport, nodecl> end
global function ma_sound_group_set_spatialization_enabled(pGroup: *ma_sound_group, enabled: ma_bool32) <cimport, nodecl> end
global function ma_sound_group_set_pinned_listener_index(pGroup: *ma_sound_group, listenerIndex: uint8) <cimport, nodecl> end
global function ma_sound_group_get_pinned_listener_index(pGroup: *ma_sound_group): uint8 <cimport, nodecl> end
global function ma_sound_group_set_position(pGroup: *ma_sound_group, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_group_get_position(pGroup: *ma_sound_group): ma_vec3f <cimport, nodecl> end
global function ma_sound_group_set_direction(pGroup: *ma_sound_group, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_group_get_direction(pGroup: *ma_sound_group): ma_vec3f <cimport, nodecl> end
global function ma_sound_group_set_velocity(pGroup: *ma_sound_group, x: float32, y: float32, z: float32) <cimport, nodecl> end
global function ma_sound_group_get_velocity(pGroup: *ma_sound_group): ma_vec3f <cimport, nodecl> end
global function ma_sound_group_set_attenuation_model(pGroup: *ma_sound_group, attenuationModel: ma_attenuation_model) <cimport, nodecl> end
global function ma_sound_group_get_attenuation_model(pGroup: *ma_sound_group): ma_attenuation_model <cimport, nodecl> end
global function ma_sound_group_set_positioning(pGroup: *ma_sound_group, positioning: ma_positioning) <cimport, nodecl> end
global function ma_sound_group_get_positioning(pGroup: *ma_sound_group): ma_positioning <cimport, nodecl> end
global function ma_sound_group_set_rolloff(pGroup: *ma_sound_group, rolloff: float32) <cimport, nodecl> end
global function ma_sound_group_get_rolloff(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_min_gain(pGroup: *ma_sound_group, minGain: float32) <cimport, nodecl> end
global function ma_sound_group_get_min_gain(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_max_gain(pGroup: *ma_sound_group, maxGain: float32) <cimport, nodecl> end
global function ma_sound_group_get_max_gain(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_min_distance(pGroup: *ma_sound_group, minDistance: float32) <cimport, nodecl> end
global function ma_sound_group_get_min_distance(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_max_distance(pGroup: *ma_sound_group, maxDistance: float32) <cimport, nodecl> end
global function ma_sound_group_get_max_distance(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_cone(pGroup: *ma_sound_group, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32) <cimport, nodecl> end
global function ma_sound_group_get_cone(pGroup: *ma_sound_group, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32) <cimport, nodecl> end
global function ma_sound_group_set_doppler_factor(pGroup: *ma_sound_group, dopplerFactor: float32) <cimport, nodecl> end
global function ma_sound_group_get_doppler_factor(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_fade_in_pcm_frames(pGroup: *ma_sound_group, volumeBeg: float32, volumeEnd: float32, fadeLengthInFrames: uint64) <cimport, nodecl> end
global function ma_sound_group_set_fade_in_milliseconds(pGroup: *ma_sound_group, volumeBeg: float32, volumeEnd: float32, fadeLengthInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_group_get_current_fade_volume(pGroup: *ma_sound_group): float32 <cimport, nodecl> end
global function ma_sound_group_set_start_time_in_pcm_frames(pGroup: *ma_sound_group, absoluteGlobalTimeInFrames: uint64) <cimport, nodecl> end
global function ma_sound_group_set_start_time_in_milliseconds(pGroup: *ma_sound_group, absoluteGlobalTimeInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_group_set_stop_time_in_pcm_frames(pGroup: *ma_sound_group, absoluteGlobalTimeInFrames: uint64) <cimport, nodecl> end
global function ma_sound_group_set_stop_time_in_milliseconds(pGroup: *ma_sound_group, absoluteGlobalTimeInMilliseconds: uint64) <cimport, nodecl> end
global function ma_sound_group_is_playing(pGroup: *ma_sound_group): ma_bool32 <cimport, nodecl> end
global function ma_sound_group_get_time_in_pcm_frames(pGroup: *ma_sound_group): uint64 <cimport, nodecl> end
global ma_biquad_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  biquad: ma_biquad_config
}
global function ma_biquad_node_config_init(channels: uint32, b0: float32, b1: float32, b2: float32, a0: float32, a1: float32, a2: float32): ma_biquad_node_config <cimport, nodecl> end
global ma_biquad_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  biquad: ma_biquad
}
global function ma_biquad_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_biquad_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_biquad_node): ma_result <cimport, nodecl> end
global function ma_biquad_node_reinit(pConfig: *ma_biquad_config, pNode: *ma_biquad_node): ma_result <cimport, nodecl> end
global function ma_biquad_node_uninit(pNode: *ma_biquad_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_lpf_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  lpf: ma_lpf_config
}
global function ma_lpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_lpf_node_config <cimport, nodecl> end
global ma_lpf_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  lpf: ma_lpf
}
global function ma_lpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_lpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_lpf_node): ma_result <cimport, nodecl> end
global function ma_lpf_node_reinit(pConfig: *ma_lpf_config, pNode: *ma_lpf_node): ma_result <cimport, nodecl> end
global function ma_lpf_node_uninit(pNode: *ma_lpf_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_hpf_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  hpf: ma_hpf_config
}
global function ma_hpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_hpf_node_config <cimport, nodecl> end
global ma_hpf_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  hpf: ma_hpf
}
global function ma_hpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_hpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_hpf_node): ma_result <cimport, nodecl> end
global function ma_hpf_node_reinit(pConfig: *ma_hpf_config, pNode: *ma_hpf_node): ma_result <cimport, nodecl> end
global function ma_hpf_node_uninit(pNode: *ma_hpf_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_bpf_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  bpf: ma_bpf_config
}
global function ma_bpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_bpf_node_config <cimport, nodecl> end
global ma_bpf_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  bpf: ma_bpf
}
global function ma_bpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_bpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_bpf_node): ma_result <cimport, nodecl> end
global function ma_bpf_node_reinit(pConfig: *ma_bpf_config, pNode: *ma_bpf_node): ma_result <cimport, nodecl> end
global function ma_bpf_node_uninit(pNode: *ma_bpf_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_notch_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  notch: ma_notch_config
}
global function ma_notch_node_config_init(channels: uint32, sampleRate: uint32, q: float64, frequency: float64): ma_notch_node_config <cimport, nodecl> end
global ma_notch_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  notch: ma_notch2
}
global function ma_notch_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_notch_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_notch_node): ma_result <cimport, nodecl> end
global function ma_notch_node_reinit(pConfig: *ma_notch_config, pNode: *ma_notch_node): ma_result <cimport, nodecl> end
global function ma_notch_node_uninit(pNode: *ma_notch_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_peak_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  peak: ma_peak_config
}
global function ma_peak_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_peak_node_config <cimport, nodecl> end
global ma_peak_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  peak: ma_peak2
}
global function ma_peak_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_peak_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_peak_node): ma_result <cimport, nodecl> end
global function ma_peak_node_reinit(pConfig: *ma_peak_config, pNode: *ma_peak_node): ma_result <cimport, nodecl> end
global function ma_peak_node_uninit(pNode: *ma_peak_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_loshelf_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  loshelf: ma_loshelf_config
}
global function ma_loshelf_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_loshelf_node_config <cimport, nodecl> end
global ma_loshelf_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  loshelf: ma_loshelf2
}
global function ma_loshelf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_loshelf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_loshelf_node): ma_result <cimport, nodecl> end
global function ma_loshelf_node_reinit(pConfig: *ma_loshelf_config, pNode: *ma_loshelf_node): ma_result <cimport, nodecl> end
global function ma_loshelf_node_uninit(pNode: *ma_loshelf_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_hishelf_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  hishelf: ma_hishelf_config
}
global function ma_hishelf_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_hishelf_node_config <cimport, nodecl> end
global ma_hishelf_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  hishelf: ma_hishelf2
}
global function ma_hishelf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_hishelf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_hishelf_node): ma_result <cimport, nodecl> end
global function ma_hishelf_node_reinit(pConfig: *ma_hishelf_config, pNode: *ma_hishelf_node): ma_result <cimport, nodecl> end
global function ma_hishelf_node_uninit(pNode: *ma_hishelf_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global ma_delay_config: type <cimport, nodecl> = @record{
  channels: uint32,
  sampleRate: uint32,
  delayInFrames: uint32,
  delayStart: ma_bool32,
  wet: float32,
  dry: float32,
  decay: float32
}
global function ma_delay_config_init(channels: uint32, sampleRate: uint32, delayInFrames: uint32, decay: float32): ma_delay_config <cimport, nodecl> end
global ma_delay: type <cimport, nodecl> = @record{
  config: ma_delay_config,
  cursor: uint32,
  bufferSizeInFrames: uint32,
  pBuffer: *float32
}
global function ma_delay_init(pConfig: *ma_delay_config, pAllocationCallbacks: *ma_allocation_callbacks, pDelay: *ma_delay): ma_result <cimport, nodecl> end
global function ma_delay_uninit(pDelay: *ma_delay, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_delay_process_pcm_frames(pDelay: *ma_delay, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint32): ma_result <cimport, nodecl> end
global function ma_delay_set_wet(pDelay: *ma_delay, value: float32) <cimport, nodecl> end
global function ma_delay_get_wet(pDelay: *ma_delay): float32 <cimport, nodecl> end
global function ma_delay_set_dry(pDelay: *ma_delay, value: float32) <cimport, nodecl> end
global function ma_delay_get_dry(pDelay: *ma_delay): float32 <cimport, nodecl> end
global function ma_delay_set_decay(pDelay: *ma_delay, value: float32) <cimport, nodecl> end
global function ma_delay_get_decay(pDelay: *ma_delay): float32 <cimport, nodecl> end
global ma_delay_node_config: type <cimport, nodecl> = @record{
  nodeConfig: ma_node_config,
  delay: ma_delay_config
}
global function ma_delay_node_config_init(channels: uint32, sampleRate: uint32, delayInFrames: uint32, decay: float32): ma_delay_node_config <cimport, nodecl> end
global ma_delay_node: type <cimport, nodecl> = @record{
  baseNode: ma_node_base,
  delay: ma_delay
}
global function ma_delay_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_delay_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pDelayNode: *ma_delay_node): ma_result <cimport, nodecl> end
global function ma_delay_node_uninit(pDelayNode: *ma_delay_node, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_delay_node_set_wet(pDelayNode: *ma_delay_node, value: float32) <cimport, nodecl> end
global function ma_delay_node_get_wet(pDelayNode: *ma_delay_node): float32 <cimport, nodecl> end
global function ma_delay_node_set_dry(pDelayNode: *ma_delay_node, value: float32) <cimport, nodecl> end
global function ma_delay_node_get_dry(pDelayNode: *ma_delay_node): float32 <cimport, nodecl> end
global function ma_delay_node_set_decay(pDelayNode: *ma_delay_node, value: float32) <cimport, nodecl> end
global function ma_delay_node_get_decay(pDelayNode: *ma_delay_node): float32 <cimport, nodecl> end
global MA_VERSION_MAJOR: cint <cimport, nodecl, const>
global MA_VERSION_MINOR: cint <cimport, nodecl, const>
global MA_VERSION_REVISION: cint <cimport, nodecl, const>
global MA_VERSION_STRING: cstring <cimport, nodecl, const>
global MA_TRUE: cint <comptime> = 1
global MA_FALSE: cint <comptime> = 0
global MA_LOG_LEVEL_DEBUG: cint <comptime> = 4
global MA_LOG_LEVEL_INFO: cint <comptime> = 3
global MA_LOG_LEVEL_WARNING: cint <comptime> = 2
global MA_LOG_LEVEL_ERROR: cint <comptime> = 1
global MA_LOG_LEVEL_VERBOSE: cint <comptime> = MA_LOG_LEVEL_DEBUG
global MA_LOG_LEVEL: cint <comptime> = MA_LOG_LEVEL_ERROR
global MA_CHANNEL_NONE: cint <comptime> = 0
global MA_CHANNEL_MONO: cint <comptime> = 1
global MA_CHANNEL_FRONT_LEFT: cint <comptime> = 2
global MA_CHANNEL_FRONT_RIGHT: cint <comptime> = 3
global MA_CHANNEL_FRONT_CENTER: cint <comptime> = 4
global MA_CHANNEL_LFE: cint <comptime> = 5
global MA_CHANNEL_BACK_LEFT: cint <comptime> = 6
global MA_CHANNEL_BACK_RIGHT: cint <comptime> = 7
global MA_CHANNEL_FRONT_LEFT_CENTER: cint <comptime> = 8
global MA_CHANNEL_FRONT_RIGHT_CENTER: cint <comptime> = 9
global MA_CHANNEL_BACK_CENTER: cint <comptime> = 10
global MA_CHANNEL_SIDE_LEFT: cint <comptime> = 11
global MA_CHANNEL_SIDE_RIGHT: cint <comptime> = 12
global MA_CHANNEL_TOP_CENTER: cint <comptime> = 13
global MA_CHANNEL_TOP_FRONT_LEFT: cint <comptime> = 14
global MA_CHANNEL_TOP_FRONT_CENTER: cint <comptime> = 15
global MA_CHANNEL_TOP_FRONT_RIGHT: cint <comptime> = 16
global MA_CHANNEL_TOP_BACK_LEFT: cint <comptime> = 17
global MA_CHANNEL_TOP_BACK_CENTER: cint <comptime> = 18
global MA_CHANNEL_TOP_BACK_RIGHT: cint <comptime> = 19
global MA_CHANNEL_AUX_0: cint <comptime> = 20
global MA_CHANNEL_AUX_1: cint <comptime> = 21
global MA_CHANNEL_AUX_2: cint <comptime> = 22
global MA_CHANNEL_AUX_3: cint <comptime> = 23
global MA_CHANNEL_AUX_4: cint <comptime> = 24
global MA_CHANNEL_AUX_5: cint <comptime> = 25
global MA_CHANNEL_AUX_6: cint <comptime> = 26
global MA_CHANNEL_AUX_7: cint <comptime> = 27
global MA_CHANNEL_AUX_8: cint <comptime> = 28
global MA_CHANNEL_AUX_9: cint <comptime> = 29
global MA_CHANNEL_AUX_10: cint <comptime> = 30
global MA_CHANNEL_AUX_11: cint <comptime> = 31
global MA_CHANNEL_AUX_12: cint <comptime> = 32
global MA_CHANNEL_AUX_13: cint <comptime> = 33
global MA_CHANNEL_AUX_14: cint <comptime> = 34
global MA_CHANNEL_AUX_15: cint <comptime> = 35
global MA_CHANNEL_AUX_16: cint <comptime> = 36
global MA_CHANNEL_AUX_17: cint <comptime> = 37
global MA_CHANNEL_AUX_18: cint <comptime> = 38
global MA_CHANNEL_AUX_19: cint <comptime> = 39
global MA_CHANNEL_AUX_20: cint <comptime> = 40
global MA_CHANNEL_AUX_21: cint <comptime> = 41
global MA_CHANNEL_AUX_22: cint <comptime> = 42
global MA_CHANNEL_AUX_23: cint <comptime> = 43
global MA_CHANNEL_AUX_24: cint <comptime> = 44
global MA_CHANNEL_AUX_25: cint <comptime> = 45
global MA_CHANNEL_AUX_26: cint <comptime> = 46
global MA_CHANNEL_AUX_27: cint <comptime> = 47
global MA_CHANNEL_AUX_28: cint <comptime> = 48
global MA_CHANNEL_AUX_29: cint <comptime> = 49
global MA_CHANNEL_AUX_30: cint <comptime> = 50
global MA_CHANNEL_AUX_31: cint <comptime> = 51
global MA_CHANNEL_LEFT: cint <comptime> = MA_CHANNEL_FRONT_LEFT
global MA_CHANNEL_RIGHT: cint <comptime> = MA_CHANNEL_FRONT_RIGHT
global MA_CHANNEL_POSITION_COUNT: cint <cimport, nodecl, const>
global MA_SUCCESS: cint <comptime> = 0
global MA_ERROR: cint <comptime> = -1
global MA_INVALID_ARGS: cint <comptime> = -2
global MA_INVALID_OPERATION: cint <comptime> = -3
global MA_OUT_OF_MEMORY: cint <comptime> = -4
global MA_OUT_OF_RANGE: cint <comptime> = -5
global MA_ACCESS_DENIED: cint <comptime> = -6
global MA_DOES_NOT_EXIST: cint <comptime> = -7
global MA_ALREADY_EXISTS: cint <comptime> = -8
global MA_TOO_MANY_OPEN_FILES: cint <comptime> = -9
global MA_INVALID_FILE: cint <comptime> = -10
global MA_TOO_BIG: cint <comptime> = -11
global MA_PATH_TOO_LONG: cint <comptime> = -12
global MA_NAME_TOO_LONG: cint <comptime> = -13
global MA_NOT_DIRECTORY: cint <comptime> = -14
global MA_IS_DIRECTORY: cint <comptime> = -15
global MA_DIRECTORY_NOT_EMPTY: cint <comptime> = -16
global MA_AT_END: cint <comptime> = -17
global MA_NO_SPACE: cint <comptime> = -18
global MA_BUSY: cint <comptime> = -19
global MA_IO_ERROR: cint <comptime> = -20
global MA_INTERRUPT: cint <comptime> = -21
global MA_UNAVAILABLE: cint <comptime> = -22
global MA_ALREADY_IN_USE: cint <comptime> = -23
global MA_BAD_ADDRESS: cint <comptime> = -24
global MA_BAD_SEEK: cint <comptime> = -25
global MA_BAD_PIPE: cint <comptime> = -26
global MA_DEADLOCK: cint <comptime> = -27
global MA_TOO_MANY_LINKS: cint <comptime> = -28
global MA_NOT_IMPLEMENTED: cint <comptime> = -29
global MA_NO_MESSAGE: cint <comptime> = -30
global MA_BAD_MESSAGE: cint <comptime> = -31
global MA_NO_DATA_AVAILABLE: cint <comptime> = -32
global MA_INVALID_DATA: cint <comptime> = -33
global MA_TIMEOUT: cint <comptime> = -34
global MA_NO_NETWORK: cint <comptime> = -35
global MA_NOT_UNIQUE: cint <comptime> = -36
global MA_NOT_SOCKET: cint <comptime> = -37
global MA_NO_ADDRESS: cint <comptime> = -38
global MA_BAD_PROTOCOL: cint <comptime> = -39
global MA_PROTOCOL_UNAVAILABLE: cint <comptime> = -40
global MA_PROTOCOL_NOT_SUPPORTED: cint <comptime> = -41
global MA_PROTOCOL_FAMILY_NOT_SUPPORTED: cint <comptime> = -42
global MA_ADDRESS_FAMILY_NOT_SUPPORTED: cint <comptime> = -43
global MA_SOCKET_NOT_SUPPORTED: cint <comptime> = -44
global MA_CONNECTION_RESET: cint <comptime> = -45
global MA_ALREADY_CONNECTED: cint <comptime> = -46
global MA_NOT_CONNECTED: cint <comptime> = -47
global MA_CONNECTION_REFUSED: cint <comptime> = -48
global MA_NO_HOST: cint <comptime> = -49
global MA_IN_PROGRESS: cint <comptime> = -50
global MA_CANCELLED: cint <comptime> = -51
global MA_MEMORY_ALREADY_MAPPED: cint <comptime> = -52
global MA_FORMAT_NOT_SUPPORTED: cint <comptime> = -100
global MA_DEVICE_TYPE_NOT_SUPPORTED: cint <comptime> = -101
global MA_SHARE_MODE_NOT_SUPPORTED: cint <comptime> = -102
global MA_NO_BACKEND: cint <comptime> = -103
global MA_NO_DEVICE: cint <comptime> = -104
global MA_API_NOT_FOUND: cint <comptime> = -105
global MA_INVALID_DEVICE_CONFIG: cint <comptime> = -106
global MA_LOOP: cint <comptime> = -107
global MA_DEVICE_NOT_INITIALIZED: cint <comptime> = -200
global MA_DEVICE_ALREADY_INITIALIZED: cint <comptime> = -201
global MA_DEVICE_NOT_STARTED: cint <comptime> = -202
global MA_DEVICE_NOT_STOPPED: cint <comptime> = -203
global MA_FAILED_TO_INIT_BACKEND: cint <comptime> = -300
global MA_FAILED_TO_OPEN_BACKEND_DEVICE: cint <comptime> = -301
global MA_FAILED_TO_START_BACKEND_DEVICE: cint <comptime> = -302
global MA_FAILED_TO_STOP_BACKEND_DEVICE: cint <comptime> = -303
global MA_MIN_CHANNELS: cint <comptime> = 1
global MA_MAX_CHANNELS: cint <comptime> = 32
global MA_MAX_FILTER_ORDER: cint <comptime> = 8
global MA_MIN_SAMPLE_RATE: cint <cimport, nodecl, const>
global MA_MAX_SAMPLE_RATE: cint <cimport, nodecl, const>
global MA_MAX_LOG_CALLBACKS: cint <comptime> = 4
global MA_CHANNEL_INDEX_NULL: cint <comptime> = 255
global MA_STATE_UNINITIALIZED: cint <comptime> = 0
global MA_STATE_STOPPED: cint <comptime> = 1
global MA_STATE_STARTED: cint <comptime> = 2
global MA_STATE_STARTING: cint <comptime> = 3
global MA_STATE_STOPPING: cint <comptime> = 4
global MA_BACKEND_COUNT: cint <cimport, nodecl, const>
global MA_DATA_FORMAT_FLAG_EXCLUSIVE_MODE: cint <cimport, nodecl, const>
global MA_OPEN_MODE_READ: cint <comptime> = 0x00000001
global MA_OPEN_MODE_WRITE: cint <comptime> = 0x00000002
global MA_ALLOCATION_TYPE_GENERAL: cint <comptime> = 0x00000001
global MA_ALLOCATION_TYPE_CONTEXT: cint <comptime> = 0x00000002
global MA_ALLOCATION_TYPE_DEVICE: cint <comptime> = 0x00000003
global MA_ALLOCATION_TYPE_DECODER: cint <comptime> = 0x00000004
global MA_ALLOCATION_TYPE_AUDIO_BUFFER: cint <comptime> = 0x00000005
global MA_ALLOCATION_TYPE_ENCODED_BUFFER: cint <comptime> = 0x00000006
global MA_ALLOCATION_TYPE_DECODED_BUFFER: cint <comptime> = 0x00000007
global MA_ALLOCATION_TYPE_RESOURCE_MANAGER_DATA_BUFFER_NODE: cint <comptime> = 0x00000010
global MA_ALLOCATION_TYPE_RESOURCE_MANAGER_DATA_BUFFER: cint <comptime> = 0x00000011
global MA_ALLOCATION_TYPE_RESOURCE_MANAGER_DATA_STREAM: cint <comptime> = 0x00000012
global MA_ALLOCATION_TYPE_RESOURCE_MANAGER_DATA_SOURCE: cint <comptime> = 0x00000013
global MA_MAX_NODE_BUS_COUNT: cint <comptime> = 254
global MA_MAX_NODE_LOCAL_BUS_COUNT: cint <comptime> = 2
global MA_NODE_BUS_COUNT_UNKNOWN: cint <comptime> = 255
global MA_NODE_FLAG_PASSTHROUGH: cint <comptime> = 0x00000001
global MA_NODE_FLAG_CONTINUOUS_PROCESSING: cint <comptime> = 0x00000002
global MA_NODE_FLAG_ALLOW_NULL_INPUT: cint <comptime> = 0x00000004
global MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES: cint <comptime> = 0x00000008
global MA_NODE_OUTPUT_BUS_FLAG_HAS_READ: cint <comptime> = 0x01
global MA_DATA_SOURCE_FLAG_STREAM: cint <comptime> = 0x00000001
global MA_DATA_SOURCE_FLAG_DECODE: cint <comptime> = 0x00000002
global MA_DATA_SOURCE_FLAG_ASYNC: cint <comptime> = 0x00000004
global MA_DATA_SOURCE_FLAG_WAIT_INIT: cint <comptime> = 0x00000008
global MA_RESOURCE_MANAGER_JOB_QUEUE_CAPACITY: cint <comptime> = 1024
global MA_JOB_QUIT: cint <comptime> = 0x00000000
global MA_JOB_LOAD_DATA_BUFFER_NODE: cint <comptime> = 0x00000001
global MA_JOB_FREE_DATA_BUFFER_NODE: cint <comptime> = 0x00000002
global MA_JOB_PAGE_DATA_BUFFER_NODE: cint <comptime> = 0x00000003
global MA_JOB_LOAD_DATA_BUFFER: cint <comptime> = 0x00000004
global MA_JOB_FREE_DATA_BUFFER: cint <comptime> = 0x00000005
global MA_JOB_LOAD_DATA_STREAM: cint <comptime> = 0x00000006
global MA_JOB_FREE_DATA_STREAM: cint <comptime> = 0x00000007
global MA_JOB_PAGE_DATA_STREAM: cint <comptime> = 0x00000008
global MA_JOB_SEEK_DATA_STREAM: cint <comptime> = 0x00000009
global MA_JOB_CUSTOM: cint <comptime> = 0x00000100
global MA_JOB_QUEUE_FLAG_NON_BLOCKING: cint <comptime> = 0x00000001
global MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT: cint <comptime> = 64
global MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING: cint <comptime> = 0x00000001
global MA_RESOURCE_MANAGER_FLAG_NO_THREADING: cint <comptime> = 0x00000002
global MA_SOUND_FLAG_STREAM: cint <comptime> = MA_DATA_SOURCE_FLAG_STREAM
global MA_SOUND_FLAG_DECODE: cint <comptime> = MA_DATA_SOURCE_FLAG_DECODE
global MA_SOUND_FLAG_ASYNC: cint <comptime> = MA_DATA_SOURCE_FLAG_ASYNC
global MA_SOUND_FLAG_WAIT_INIT: cint <comptime> = MA_DATA_SOURCE_FLAG_WAIT_INIT
global MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT: cint <comptime> = 0x00000010
global MA_SOUND_FLAG_NO_PITCH: cint <comptime> = 0x00000020
global MA_SOUND_FLAG_NO_SPATIALIZATION: cint <comptime> = 0x00000040
global MA_ENGINE_MAX_LISTENERS: cint <comptime> = 4
global MA_LISTENER_INDEX_CLOSEST: cint <cimport, nodecl, const>
