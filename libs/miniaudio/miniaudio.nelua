##[[
if not MINIAUDIO_NO_IMPL then
  cdefine 'MA_API static'
  cdefine 'MA_NO_PTHREAD_IN_HEADER'
  cdefine 'MINIAUDIO_IMPLEMENTATION'
end
cinclude 'miniaudio.h'
if ccinfo.is_linux then
  linklib 'dl'
  linklib 'm'
  cflags '-pthread'
elseif ccinfo.is_windows then
  linklib 'ole32'
end
]]
global ma_bool8: type = @cuchar
global ma_bool32: type = @cuint
global ma_handle: type = @pointer
global ma_ptr: type = @pointer
global ma_proc: type <cimport,nodecl> = @function(): void
global ma_pthread_mutex_t: type <cimport,nodecl> = @union{
  __data: [40]cchar,
  __alignment: uint64
}
global ma_pthread_cond_t: type <cimport,nodecl> = @union{
  __data: [48]cchar,
  __alignment: uint64
}
global ma_log_level: type <cimport,nodecl,using> = @enum(cint){
  MA_LOG_LEVEL_DEBUG = 4,
  MA_LOG_LEVEL_INFO = 3,
  MA_LOG_LEVEL_WARNING = 2,
  MA_LOG_LEVEL_ERROR = 1
}
global ma_context: type <cimport,nodecl,forwarddecl> = @record{}
global ma_device: type <cimport,nodecl,forwarddecl> = @record{}
global ma_channel: type = @cuchar
global ma_result: type <cimport,nodecl,using> = @enum(cint){
  MA_SUCCESS = 0,
  MA_ERROR = -1,
  MA_INVALID_ARGS = -2,
  MA_INVALID_OPERATION = -3,
  MA_OUT_OF_MEMORY = -4,
  MA_OUT_OF_RANGE = -5,
  MA_ACCESS_DENIED = -6,
  MA_DOES_NOT_EXIST = -7,
  MA_ALREADY_EXISTS = -8,
  MA_TOO_MANY_OPEN_FILES = -9,
  MA_INVALID_FILE = -10,
  MA_TOO_BIG = -11,
  MA_PATH_TOO_LONG = -12,
  MA_NAME_TOO_LONG = -13,
  MA_NOT_DIRECTORY = -14,
  MA_IS_DIRECTORY = -15,
  MA_DIRECTORY_NOT_EMPTY = -16,
  MA_AT_END = -17,
  MA_NO_SPACE = -18,
  MA_BUSY = -19,
  MA_IO_ERROR = -20,
  MA_INTERRUPT = -21,
  MA_UNAVAILABLE = -22,
  MA_ALREADY_IN_USE = -23,
  MA_BAD_ADDRESS = -24,
  MA_BAD_SEEK = -25,
  MA_BAD_PIPE = -26,
  MA_DEADLOCK = -27,
  MA_TOO_MANY_LINKS = -28,
  MA_NOT_IMPLEMENTED = -29,
  MA_NO_MESSAGE = -30,
  MA_BAD_MESSAGE = -31,
  MA_NO_DATA_AVAILABLE = -32,
  MA_INVALID_DATA = -33,
  MA_TIMEOUT = -34,
  MA_NO_NETWORK = -35,
  MA_NOT_UNIQUE = -36,
  MA_NOT_SOCKET = -37,
  MA_NO_ADDRESS = -38,
  MA_BAD_PROTOCOL = -39,
  MA_PROTOCOL_UNAVAILABLE = -40,
  MA_PROTOCOL_NOT_SUPPORTED = -41,
  MA_PROTOCOL_FAMILY_NOT_SUPPORTED = -42,
  MA_ADDRESS_FAMILY_NOT_SUPPORTED = -43,
  MA_SOCKET_NOT_SUPPORTED = -44,
  MA_CONNECTION_RESET = -45,
  MA_ALREADY_CONNECTED = -46,
  MA_NOT_CONNECTED = -47,
  MA_CONNECTION_REFUSED = -48,
  MA_NO_HOST = -49,
  MA_IN_PROGRESS = -50,
  MA_CANCELLED = -51,
  MA_MEMORY_ALREADY_MAPPED = -52,
  MA_FORMAT_NOT_SUPPORTED = -100,
  MA_DEVICE_TYPE_NOT_SUPPORTED = -101,
  MA_SHARE_MODE_NOT_SUPPORTED = -102,
  MA_NO_BACKEND = -103,
  MA_NO_DEVICE = -104,
  MA_API_NOT_FOUND = -105,
  MA_INVALID_DEVICE_CONFIG = -106,
  MA_LOOP = -107,
  MA_BACKEND_NOT_ENABLED = -108,
  MA_DEVICE_NOT_INITIALIZED = -200,
  MA_DEVICE_ALREADY_INITIALIZED = -201,
  MA_DEVICE_NOT_STARTED = -202,
  MA_DEVICE_NOT_STOPPED = -203,
  MA_FAILED_TO_INIT_BACKEND = -300,
  MA_FAILED_TO_OPEN_BACKEND_DEVICE = -301,
  MA_FAILED_TO_START_BACKEND_DEVICE = -302,
  MA_FAILED_TO_STOP_BACKEND_DEVICE = -303
}
global ma_stream_format: type <cimport,nodecl,using> = @enum(cint){
  ma_stream_format_pcm = 0
}
global ma_stream_layout: type <cimport,nodecl,using> = @enum(cint){
  ma_stream_layout_interleaved = 0,
  ma_stream_layout_deinterleaved = 1
}
global ma_dither_mode: type <cimport,nodecl,using> = @enum(cint){
  ma_dither_mode_none = 0,
  ma_dither_mode_rectangle = 1,
  ma_dither_mode_triangle = 2
}
global ma_format: type <cimport,nodecl,using> = @enum(cint){
  ma_format_unknown = 0,
  ma_format_u8 = 1,
  ma_format_s16 = 2,
  ma_format_s24 = 3,
  ma_format_s32 = 4,
  ma_format_f32 = 5,
  ma_format_count = 6
}
global ma_standard_sample_rate: type <cimport,nodecl,using> = @enum(cint){
  ma_standard_sample_rate_48000 = 48000,
  ma_standard_sample_rate_44100 = 44100,
  ma_standard_sample_rate_32000 = 32000,
  ma_standard_sample_rate_24000 = 24000,
  ma_standard_sample_rate_22050 = 22050,
  ma_standard_sample_rate_88200 = 88200,
  ma_standard_sample_rate_96000 = 96000,
  ma_standard_sample_rate_176400 = 176400,
  ma_standard_sample_rate_192000 = 192000,
  ma_standard_sample_rate_16000 = 16000,
  ma_standard_sample_rate_11025 = 11250,
  ma_standard_sample_rate_8000 = 8000,
  ma_standard_sample_rate_352800 = 352800,
  ma_standard_sample_rate_384000 = 384000,
  ma_standard_sample_rate_min = 8000,
  ma_standard_sample_rate_max = 384000,
  ma_standard_sample_rate_count = 14
}
global ma_channel_mix_mode: type <cimport,nodecl,using> = @enum(cint){
  ma_channel_mix_mode_rectangular = 0,
  ma_channel_mix_mode_simple = 1,
  ma_channel_mix_mode_custom_weights = 2,
  ma_channel_mix_mode_default = 0
}
global ma_standard_channel_map: type <cimport,nodecl,using> = @enum(cint){
  ma_standard_channel_map_microsoft = 0,
  ma_standard_channel_map_alsa = 1,
  ma_standard_channel_map_rfc3551 = 2,
  ma_standard_channel_map_flac = 3,
  ma_standard_channel_map_vorbis = 4,
  ma_standard_channel_map_sound4 = 5,
  ma_standard_channel_map_sndio = 6,
  ma_standard_channel_map_webaudio = 3,
  ma_standard_channel_map_default = 0
}
global ma_performance_profile: type <cimport,nodecl,using> = @enum(cint){
  ma_performance_profile_low_latency = 0,
  ma_performance_profile_conservative = 1
}
global ma_allocation_callbacks: type <cimport,nodecl> = @record{
  pUserData: pointer,
  onMalloc: function(csize, pointer): pointer,
  onRealloc: function(pointer, csize, pointer): pointer,
  onFree: function(pointer, pointer): void
}
global ma_lcg: type <cimport,nodecl> = @record{
  state: int32
}
global ma_atomic_uint32: type <cimport,nodecl,aligned(4)> = @record{
  value: uint32
}
global ma_atomic_int32: type <cimport,nodecl,aligned(4)> = @record{
  value: int32
}
global ma_atomic_uint64: type <cimport,nodecl,aligned(8)> = @record{
  value: uint64
}
global ma_atomic_float: type <cimport,nodecl,aligned(4)> = @record{
  value: float32
}
global ma_atomic_bool32: type <cimport,nodecl,aligned(4)> = @record{
  value: ma_bool32
}
global ma_thread_priority: type <cimport,nodecl,using> = @enum(cint){
  ma_thread_priority_idle = -5,
  ma_thread_priority_lowest = -4,
  ma_thread_priority_low = -3,
  ma_thread_priority_normal = -2,
  ma_thread_priority_high = -1,
  ma_thread_priority_highest = 0,
  ma_thread_priority_realtime = 1,
  ma_thread_priority_default = 0
}
global ma_mutex: type = @ma_pthread_mutex_t
global ma_event: type <cimport,nodecl> = @record{
  value: uint32,
  lock: ma_pthread_mutex_t,
  cond: ma_pthread_cond_t
}
global ma_semaphore: type <cimport,nodecl> = @record{
  value: cint,
  lock: ma_pthread_mutex_t,
  cond: ma_pthread_cond_t
}
global function ma_version(pMajor: *uint32, pMinor: *uint32, pRevision: *uint32): void <cimport,nodecl> end
global function ma_version_string(): cstring <cimport,nodecl> end
global ma_log_callback_proc: type <cimport,nodecl> = @function(pointer, uint32, cstring): void
global ma_log_callback: type <cimport,nodecl> = @record{
  onLog: ma_log_callback_proc,
  pUserData: pointer
}
global function ma_log_callback_init(onLog: ma_log_callback_proc, pUserData: pointer): ma_log_callback <cimport,nodecl> end
global ma_log: type <cimport,nodecl> = @record{
  callbacks: [4]ma_log_callback,
  callbackCount: uint32,
  allocationCallbacks: ma_allocation_callbacks,
  lock: ma_mutex
}
global function ma_log_init(pAllocationCallbacks: *ma_allocation_callbacks, pLog: *ma_log): ma_result <cimport,nodecl> end
global function ma_log_uninit(pLog: *ma_log): void <cimport,nodecl> end
global function ma_log_register_callback(pLog: *ma_log, callback: ma_log_callback): ma_result <cimport,nodecl> end
global function ma_log_unregister_callback(pLog: *ma_log, callback: ma_log_callback): ma_result <cimport,nodecl> end
global function ma_log_post(pLog: *ma_log, level: uint32, pMessage: cstring): ma_result <cimport,nodecl> end
global function ma_log_postv(pLog: *ma_log, level: uint32, pFormat: cstring, args: cvalist): ma_result <cimport,nodecl> end
global function ma_log_postf(pLog: *ma_log, level: uint32, pFormat: cstring, ...: cvarargs): ma_result <cimport,nodecl> end
global ma_biquad_coefficient: type <cimport,nodecl> = @union{
  f32: float32,
  s32: int32
}
global ma_biquad_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: float64,
  b1: float64,
  b2: float64,
  a0: float64,
  a1: float64,
  a2: float64
}
global function ma_biquad_config_init(format: ma_format, channels: uint32, b0: float64, b1: float64, b2: float64, a0: float64, a1: float64, a2: float64): ma_biquad_config <cimport,nodecl> end
global ma_biquad: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: ma_biquad_coefficient,
  b1: ma_biquad_coefficient,
  b2: ma_biquad_coefficient,
  a1: ma_biquad_coefficient,
  a2: ma_biquad_coefficient,
  pR1: *ma_biquad_coefficient,
  pR2: *ma_biquad_coefficient,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_biquad_get_heap_size(pConfig: *ma_biquad_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_biquad_init_preallocated(pConfig: *ma_biquad_config, pHeap: pointer, pBQ: *ma_biquad): ma_result <cimport,nodecl> end
global function ma_biquad_init(pConfig: *ma_biquad_config, pAllocationCallbacks: *ma_allocation_callbacks, pBQ: *ma_biquad): ma_result <cimport,nodecl> end
global function ma_biquad_uninit(pBQ: *ma_biquad, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_biquad_reinit(pConfig: *ma_biquad_config, pBQ: *ma_biquad): ma_result <cimport,nodecl> end
global function ma_biquad_clear_cache(pBQ: *ma_biquad): ma_result <cimport,nodecl> end
global function ma_biquad_process_pcm_frames(pBQ: *ma_biquad, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_biquad_get_latency(pBQ: *ma_biquad): uint32 <cimport,nodecl> end
global ma_lpf1_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_lpf2_config: type = @ma_lpf1_config
global function ma_lpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_lpf1_config <cimport,nodecl> end
global function ma_lpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_lpf2_config <cimport,nodecl> end
global ma_lpf1: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  pR1: *ma_biquad_coefficient,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_lpf1_get_heap_size(pConfig: *ma_lpf1_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_lpf1_init_preallocated(pConfig: *ma_lpf1_config, pHeap: pointer, pLPF: *ma_lpf1): ma_result <cimport,nodecl> end
global function ma_lpf1_init(pConfig: *ma_lpf1_config, pAllocationCallbacks: *ma_allocation_callbacks, pLPF: *ma_lpf1): ma_result <cimport,nodecl> end
global function ma_lpf1_uninit(pLPF: *ma_lpf1, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_lpf1_reinit(pConfig: *ma_lpf1_config, pLPF: *ma_lpf1): ma_result <cimport,nodecl> end
global function ma_lpf1_clear_cache(pLPF: *ma_lpf1): ma_result <cimport,nodecl> end
global function ma_lpf1_process_pcm_frames(pLPF: *ma_lpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_lpf1_get_latency(pLPF: *ma_lpf1): uint32 <cimport,nodecl> end
global ma_lpf2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_lpf2_get_heap_size(pConfig: *ma_lpf2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_lpf2_init_preallocated(pConfig: *ma_lpf2_config, pHeap: pointer, pHPF: *ma_lpf2): ma_result <cimport,nodecl> end
global function ma_lpf2_init(pConfig: *ma_lpf2_config, pAllocationCallbacks: *ma_allocation_callbacks, pLPF: *ma_lpf2): ma_result <cimport,nodecl> end
global function ma_lpf2_uninit(pLPF: *ma_lpf2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_lpf2_reinit(pConfig: *ma_lpf2_config, pLPF: *ma_lpf2): ma_result <cimport,nodecl> end
global function ma_lpf2_clear_cache(pLPF: *ma_lpf2): ma_result <cimport,nodecl> end
global function ma_lpf2_process_pcm_frames(pLPF: *ma_lpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_lpf2_get_latency(pLPF: *ma_lpf2): uint32 <cimport,nodecl> end
global ma_lpf_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_lpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_lpf_config <cimport,nodecl> end
global ma_lpf: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  lpf1Count: uint32,
  lpf2Count: uint32,
  pLPF1: *ma_lpf1,
  pLPF2: *ma_lpf2,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_lpf_get_heap_size(pConfig: *ma_lpf_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_lpf_init_preallocated(pConfig: *ma_lpf_config, pHeap: pointer, pLPF: *ma_lpf): ma_result <cimport,nodecl> end
global function ma_lpf_init(pConfig: *ma_lpf_config, pAllocationCallbacks: *ma_allocation_callbacks, pLPF: *ma_lpf): ma_result <cimport,nodecl> end
global function ma_lpf_uninit(pLPF: *ma_lpf, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_lpf_reinit(pConfig: *ma_lpf_config, pLPF: *ma_lpf): ma_result <cimport,nodecl> end
global function ma_lpf_clear_cache(pLPF: *ma_lpf): ma_result <cimport,nodecl> end
global function ma_lpf_process_pcm_frames(pLPF: *ma_lpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_lpf_get_latency(pLPF: *ma_lpf): uint32 <cimport,nodecl> end
global ma_hpf1_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_hpf2_config: type = @ma_hpf1_config
global function ma_hpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_hpf1_config <cimport,nodecl> end
global function ma_hpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_hpf2_config <cimport,nodecl> end
global ma_hpf1: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  pR1: *ma_biquad_coefficient,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_hpf1_get_heap_size(pConfig: *ma_hpf1_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_hpf1_init_preallocated(pConfig: *ma_hpf1_config, pHeap: pointer, pLPF: *ma_hpf1): ma_result <cimport,nodecl> end
global function ma_hpf1_init(pConfig: *ma_hpf1_config, pAllocationCallbacks: *ma_allocation_callbacks, pHPF: *ma_hpf1): ma_result <cimport,nodecl> end
global function ma_hpf1_uninit(pHPF: *ma_hpf1, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_hpf1_reinit(pConfig: *ma_hpf1_config, pHPF: *ma_hpf1): ma_result <cimport,nodecl> end
global function ma_hpf1_process_pcm_frames(pHPF: *ma_hpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_hpf1_get_latency(pHPF: *ma_hpf1): uint32 <cimport,nodecl> end
global ma_hpf2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_hpf2_get_heap_size(pConfig: *ma_hpf2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_hpf2_init_preallocated(pConfig: *ma_hpf2_config, pHeap: pointer, pHPF: *ma_hpf2): ma_result <cimport,nodecl> end
global function ma_hpf2_init(pConfig: *ma_hpf2_config, pAllocationCallbacks: *ma_allocation_callbacks, pHPF: *ma_hpf2): ma_result <cimport,nodecl> end
global function ma_hpf2_uninit(pHPF: *ma_hpf2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_hpf2_reinit(pConfig: *ma_hpf2_config, pHPF: *ma_hpf2): ma_result <cimport,nodecl> end
global function ma_hpf2_process_pcm_frames(pHPF: *ma_hpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_hpf2_get_latency(pHPF: *ma_hpf2): uint32 <cimport,nodecl> end
global ma_hpf_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_hpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_hpf_config <cimport,nodecl> end
global ma_hpf: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  hpf1Count: uint32,
  hpf2Count: uint32,
  pHPF1: *ma_hpf1,
  pHPF2: *ma_hpf2,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_hpf_get_heap_size(pConfig: *ma_hpf_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_hpf_init_preallocated(pConfig: *ma_hpf_config, pHeap: pointer, pLPF: *ma_hpf): ma_result <cimport,nodecl> end
global function ma_hpf_init(pConfig: *ma_hpf_config, pAllocationCallbacks: *ma_allocation_callbacks, pHPF: *ma_hpf): ma_result <cimport,nodecl> end
global function ma_hpf_uninit(pHPF: *ma_hpf, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_hpf_reinit(pConfig: *ma_hpf_config, pHPF: *ma_hpf): ma_result <cimport,nodecl> end
global function ma_hpf_process_pcm_frames(pHPF: *ma_hpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_hpf_get_latency(pHPF: *ma_hpf): uint32 <cimport,nodecl> end
global ma_bpf2_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global function ma_bpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_bpf2_config <cimport,nodecl> end
global ma_bpf2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_bpf2_get_heap_size(pConfig: *ma_bpf2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_bpf2_init_preallocated(pConfig: *ma_bpf2_config, pHeap: pointer, pBPF: *ma_bpf2): ma_result <cimport,nodecl> end
global function ma_bpf2_init(pConfig: *ma_bpf2_config, pAllocationCallbacks: *ma_allocation_callbacks, pBPF: *ma_bpf2): ma_result <cimport,nodecl> end
global function ma_bpf2_uninit(pBPF: *ma_bpf2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_bpf2_reinit(pConfig: *ma_bpf2_config, pBPF: *ma_bpf2): ma_result <cimport,nodecl> end
global function ma_bpf2_process_pcm_frames(pBPF: *ma_bpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_bpf2_get_latency(pBPF: *ma_bpf2): uint32 <cimport,nodecl> end
global ma_bpf_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_bpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_bpf_config <cimport,nodecl> end
global ma_bpf: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  bpf2Count: uint32,
  pBPF2: *ma_bpf2,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_bpf_get_heap_size(pConfig: *ma_bpf_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_bpf_init_preallocated(pConfig: *ma_bpf_config, pHeap: pointer, pBPF: *ma_bpf): ma_result <cimport,nodecl> end
global function ma_bpf_init(pConfig: *ma_bpf_config, pAllocationCallbacks: *ma_allocation_callbacks, pBPF: *ma_bpf): ma_result <cimport,nodecl> end
global function ma_bpf_uninit(pBPF: *ma_bpf, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_bpf_reinit(pConfig: *ma_bpf_config, pBPF: *ma_bpf): ma_result <cimport,nodecl> end
global function ma_bpf_process_pcm_frames(pBPF: *ma_bpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_bpf_get_latency(pBPF: *ma_bpf): uint32 <cimport,nodecl> end
global ma_notch2_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  q: float64,
  frequency: float64
}
global ma_notch_config: type = @ma_notch2_config
global function ma_notch2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, q: float64, frequency: float64): ma_notch2_config <cimport,nodecl> end
global ma_notch2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_notch2_get_heap_size(pConfig: *ma_notch2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_notch2_init_preallocated(pConfig: *ma_notch2_config, pHeap: pointer, pFilter: *ma_notch2): ma_result <cimport,nodecl> end
global function ma_notch2_init(pConfig: *ma_notch2_config, pAllocationCallbacks: *ma_allocation_callbacks, pFilter: *ma_notch2): ma_result <cimport,nodecl> end
global function ma_notch2_uninit(pFilter: *ma_notch2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_notch2_reinit(pConfig: *ma_notch2_config, pFilter: *ma_notch2): ma_result <cimport,nodecl> end
global function ma_notch2_process_pcm_frames(pFilter: *ma_notch2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_notch2_get_latency(pFilter: *ma_notch2): uint32 <cimport,nodecl> end
global ma_peak2_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  q: float64,
  frequency: float64
}
global ma_peak_config: type = @ma_peak2_config
global function ma_peak2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_peak2_config <cimport,nodecl> end
global ma_peak2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_peak2_get_heap_size(pConfig: *ma_peak2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_peak2_init_preallocated(pConfig: *ma_peak2_config, pHeap: pointer, pFilter: *ma_peak2): ma_result <cimport,nodecl> end
global function ma_peak2_init(pConfig: *ma_peak2_config, pAllocationCallbacks: *ma_allocation_callbacks, pFilter: *ma_peak2): ma_result <cimport,nodecl> end
global function ma_peak2_uninit(pFilter: *ma_peak2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_peak2_reinit(pConfig: *ma_peak2_config, pFilter: *ma_peak2): ma_result <cimport,nodecl> end
global function ma_peak2_process_pcm_frames(pFilter: *ma_peak2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_peak2_get_latency(pFilter: *ma_peak2): uint32 <cimport,nodecl> end
global ma_loshelf2_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global ma_loshelf_config: type = @ma_loshelf2_config
global function ma_loshelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_loshelf2_config <cimport,nodecl> end
global ma_loshelf2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_loshelf2_get_heap_size(pConfig: *ma_loshelf2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_loshelf2_init_preallocated(pConfig: *ma_loshelf2_config, pHeap: pointer, pFilter: *ma_loshelf2): ma_result <cimport,nodecl> end
global function ma_loshelf2_init(pConfig: *ma_loshelf2_config, pAllocationCallbacks: *ma_allocation_callbacks, pFilter: *ma_loshelf2): ma_result <cimport,nodecl> end
global function ma_loshelf2_uninit(pFilter: *ma_loshelf2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_loshelf2_reinit(pConfig: *ma_loshelf2_config, pFilter: *ma_loshelf2): ma_result <cimport,nodecl> end
global function ma_loshelf2_process_pcm_frames(pFilter: *ma_loshelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_loshelf2_get_latency(pFilter: *ma_loshelf2): uint32 <cimport,nodecl> end
global ma_hishelf2_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global ma_hishelf_config: type = @ma_hishelf2_config
global function ma_hishelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_hishelf2_config <cimport,nodecl> end
global ma_hishelf2: type <cimport,nodecl> = @record{
  bq: ma_biquad
}
global function ma_hishelf2_get_heap_size(pConfig: *ma_hishelf2_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_hishelf2_init_preallocated(pConfig: *ma_hishelf2_config, pHeap: pointer, pFilter: *ma_hishelf2): ma_result <cimport,nodecl> end
global function ma_hishelf2_init(pConfig: *ma_hishelf2_config, pAllocationCallbacks: *ma_allocation_callbacks, pFilter: *ma_hishelf2): ma_result <cimport,nodecl> end
global function ma_hishelf2_uninit(pFilter: *ma_hishelf2, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_hishelf2_reinit(pConfig: *ma_hishelf2_config, pFilter: *ma_hishelf2): ma_result <cimport,nodecl> end
global function ma_hishelf2_process_pcm_frames(pFilter: *ma_hishelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_hishelf2_get_latency(pFilter: *ma_hishelf2): uint32 <cimport,nodecl> end
global ma_delay_config: type <cimport,nodecl> = @record{
  channels: uint32,
  sampleRate: uint32,
  delayInFrames: uint32,
  delayStart: ma_bool32,
  wet: float32,
  dry: float32,
  decay: float32
}
global function ma_delay_config_init(channels: uint32, sampleRate: uint32, delayInFrames: uint32, decay: float32): ma_delay_config <cimport,nodecl> end
global ma_delay: type <cimport,nodecl> = @record{
  config: ma_delay_config,
  cursor: uint32,
  bufferSizeInFrames: uint32,
  pBuffer: *float32
}
global function ma_delay_init(pConfig: *ma_delay_config, pAllocationCallbacks: *ma_allocation_callbacks, pDelay: *ma_delay): ma_result <cimport,nodecl> end
global function ma_delay_uninit(pDelay: *ma_delay, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_delay_process_pcm_frames(pDelay: *ma_delay, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint32): ma_result <cimport,nodecl> end
global function ma_delay_set_wet(pDelay: *ma_delay, value: float32): void <cimport,nodecl> end
global function ma_delay_get_wet(pDelay: *ma_delay): float32 <cimport,nodecl> end
global function ma_delay_set_dry(pDelay: *ma_delay, value: float32): void <cimport,nodecl> end
global function ma_delay_get_dry(pDelay: *ma_delay): float32 <cimport,nodecl> end
global function ma_delay_set_decay(pDelay: *ma_delay, value: float32): void <cimport,nodecl> end
global function ma_delay_get_decay(pDelay: *ma_delay): float32 <cimport,nodecl> end
global ma_gainer_config: type <cimport,nodecl> = @record{
  channels: uint32,
  smoothTimeInFrames: uint32
}
global function ma_gainer_config_init(channels: uint32, smoothTimeInFrames: uint32): ma_gainer_config <cimport,nodecl> end
global ma_gainer: type <cimport,nodecl> = @record{
  config: ma_gainer_config,
  t: uint32,
  masterVolume: float32,
  pOldGains: *float32,
  pNewGains: *float32,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_gainer_get_heap_size(pConfig: *ma_gainer_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_gainer_init_preallocated(pConfig: *ma_gainer_config, pHeap: pointer, pGainer: *ma_gainer): ma_result <cimport,nodecl> end
global function ma_gainer_init(pConfig: *ma_gainer_config, pAllocationCallbacks: *ma_allocation_callbacks, pGainer: *ma_gainer): ma_result <cimport,nodecl> end
global function ma_gainer_uninit(pGainer: *ma_gainer, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_gainer_process_pcm_frames(pGainer: *ma_gainer, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_gainer_set_gain(pGainer: *ma_gainer, newGain: float32): ma_result <cimport,nodecl> end
global function ma_gainer_set_gains(pGainer: *ma_gainer, pNewGains: *float32): ma_result <cimport,nodecl> end
global function ma_gainer_set_master_volume(pGainer: *ma_gainer, volume: float32): ma_result <cimport,nodecl> end
global function ma_gainer_get_master_volume(pGainer: *ma_gainer, pVolume: *float32): ma_result <cimport,nodecl> end
global ma_pan_mode: type <cimport,nodecl,using> = @enum(cint){
  ma_pan_mode_balance = 0,
  ma_pan_mode_pan = 1
}
global ma_panner_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  mode: ma_pan_mode,
  pan: float32
}
global function ma_panner_config_init(format: ma_format, channels: uint32): ma_panner_config <cimport,nodecl> end
global ma_panner: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  mode: ma_pan_mode,
  pan: float32
}
global function ma_panner_init(pConfig: *ma_panner_config, pPanner: *ma_panner): ma_result <cimport,nodecl> end
global function ma_panner_process_pcm_frames(pPanner: *ma_panner, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_panner_set_mode(pPanner: *ma_panner, mode: ma_pan_mode): void <cimport,nodecl> end
global function ma_panner_get_mode(pPanner: *ma_panner): ma_pan_mode <cimport,nodecl> end
global function ma_panner_set_pan(pPanner: *ma_panner, pan: float32): void <cimport,nodecl> end
global function ma_panner_get_pan(pPanner: *ma_panner): float32 <cimport,nodecl> end
global ma_fader_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32
}
global function ma_fader_config_init(format: ma_format, channels: uint32, sampleRate: uint32): ma_fader_config <cimport,nodecl> end
global ma_fader: type <cimport,nodecl> = @record{
  config: ma_fader_config,
  volumeBeg: float32,
  volumeEnd: float32,
  lengthInFrames: uint64,
  cursorInFrames: uint64
}
global function ma_fader_init(pConfig: *ma_fader_config, pFader: *ma_fader): ma_result <cimport,nodecl> end
global function ma_fader_process_pcm_frames(pFader: *ma_fader, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_fader_get_data_format(pFader: *ma_fader, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): void <cimport,nodecl> end
global function ma_fader_set_fade(pFader: *ma_fader, volumeBeg: float32, volumeEnd: float32, lengthInFrames: uint64): void <cimport,nodecl> end
global function ma_fader_get_current_volume(pFader: *ma_fader): float32 <cimport,nodecl> end
global ma_vec3f: type <cimport,nodecl> = @record{
  x: float32,
  y: float32,
  z: float32
}
global ma_atomic_vec3f: type <cimport,nodecl> = @record{
  v: ma_vec3f,
  lock: cuint
}
global ma_attenuation_model: type <cimport,nodecl,using> = @enum(cint){
  ma_attenuation_model_none = 0,
  ma_attenuation_model_inverse = 1,
  ma_attenuation_model_linear = 2,
  ma_attenuation_model_exponential = 3
}
global ma_positioning: type <cimport,nodecl,using> = @enum(cint){
  ma_positioning_absolute = 0,
  ma_positioning_relative = 1
}
global ma_handedness: type <cimport,nodecl,using> = @enum(cint){
  ma_handedness_right = 0,
  ma_handedness_left = 1
}
global ma_spatializer_listener_config: type <cimport,nodecl> = @record{
  channelsOut: uint32,
  pChannelMapOut: *ma_channel,
  handedness: ma_handedness,
  coneInnerAngleInRadians: float32,
  coneOuterAngleInRadians: float32,
  coneOuterGain: float32,
  speedOfSound: float32,
  worldUp: ma_vec3f
}
global function ma_spatializer_listener_config_init(channelsOut: uint32): ma_spatializer_listener_config <cimport,nodecl> end
global ma_spatializer_listener: type <cimport,nodecl> = @record{
  config: ma_spatializer_listener_config,
  position: ma_atomic_vec3f,
  direction: ma_atomic_vec3f,
  velocity: ma_atomic_vec3f,
  isEnabled: ma_bool32,
  _ownsHeap: ma_bool32,
  _pHeap: pointer
}
global function ma_spatializer_listener_get_heap_size(pConfig: *ma_spatializer_listener_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_spatializer_listener_init_preallocated(pConfig: *ma_spatializer_listener_config, pHeap: pointer, pListener: *ma_spatializer_listener): ma_result <cimport,nodecl> end
global function ma_spatializer_listener_init(pConfig: *ma_spatializer_listener_config, pAllocationCallbacks: *ma_allocation_callbacks, pListener: *ma_spatializer_listener): ma_result <cimport,nodecl> end
global function ma_spatializer_listener_uninit(pListener: *ma_spatializer_listener, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_spatializer_listener_get_channel_map(pListener: *ma_spatializer_listener): *ma_channel <cimport,nodecl> end
global function ma_spatializer_listener_set_cone(pListener: *ma_spatializer_listener, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_cone(pListener: *ma_spatializer_listener, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32): void <cimport,nodecl> end
global function ma_spatializer_listener_set_position(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_position(pListener: *ma_spatializer_listener): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_listener_set_direction(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_direction(pListener: *ma_spatializer_listener): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_listener_set_velocity(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_velocity(pListener: *ma_spatializer_listener): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_listener_set_speed_of_sound(pListener: *ma_spatializer_listener, speedOfSound: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_speed_of_sound(pListener: *ma_spatializer_listener): float32 <cimport,nodecl> end
global function ma_spatializer_listener_set_world_up(pListener: *ma_spatializer_listener, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_listener_get_world_up(pListener: *ma_spatializer_listener): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_listener_set_enabled(pListener: *ma_spatializer_listener, isEnabled: ma_bool32): void <cimport,nodecl> end
global function ma_spatializer_listener_is_enabled(pListener: *ma_spatializer_listener): ma_bool32 <cimport,nodecl> end
global ma_spatializer_config: type <cimport,nodecl> = @record{
  channelsIn: uint32,
  channelsOut: uint32,
  pChannelMapIn: *ma_channel,
  attenuationModel: ma_attenuation_model,
  positioning: ma_positioning,
  handedness: ma_handedness,
  minGain: float32,
  maxGain: float32,
  minDistance: float32,
  maxDistance: float32,
  rolloff: float32,
  coneInnerAngleInRadians: float32,
  coneOuterAngleInRadians: float32,
  coneOuterGain: float32,
  dopplerFactor: float32,
  directionalAttenuationFactor: float32,
  minSpatializationChannelGain: float32,
  gainSmoothTimeInFrames: uint32
}
global function ma_spatializer_config_init(channelsIn: uint32, channelsOut: uint32): ma_spatializer_config <cimport,nodecl> end
global ma_spatializer: type <cimport,nodecl> = @record{
  channelsIn: uint32,
  channelsOut: uint32,
  pChannelMapIn: *ma_channel,
  attenuationModel: ma_attenuation_model,
  positioning: ma_positioning,
  handedness: ma_handedness,
  minGain: float32,
  maxGain: float32,
  minDistance: float32,
  maxDistance: float32,
  rolloff: float32,
  coneInnerAngleInRadians: float32,
  coneOuterAngleInRadians: float32,
  coneOuterGain: float32,
  dopplerFactor: float32,
  directionalAttenuationFactor: float32,
  gainSmoothTimeInFrames: uint32,
  position: ma_atomic_vec3f,
  direction: ma_atomic_vec3f,
  velocity: ma_atomic_vec3f,
  dopplerPitch: float32,
  minSpatializationChannelGain: float32,
  gainer: ma_gainer,
  pNewChannelGainsOut: *float32,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_spatializer_get_heap_size(pConfig: *ma_spatializer_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_spatializer_init_preallocated(pConfig: *ma_spatializer_config, pHeap: pointer, pSpatializer: *ma_spatializer): ma_result <cimport,nodecl> end
global function ma_spatializer_init(pConfig: *ma_spatializer_config, pAllocationCallbacks: *ma_allocation_callbacks, pSpatializer: *ma_spatializer): ma_result <cimport,nodecl> end
global function ma_spatializer_uninit(pSpatializer: *ma_spatializer, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_spatializer_process_pcm_frames(pSpatializer: *ma_spatializer, pListener: *ma_spatializer_listener, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_spatializer_set_master_volume(pSpatializer: *ma_spatializer, volume: float32): ma_result <cimport,nodecl> end
global function ma_spatializer_get_master_volume(pSpatializer: *ma_spatializer, pVolume: *float32): ma_result <cimport,nodecl> end
global function ma_spatializer_get_input_channels(pSpatializer: *ma_spatializer): uint32 <cimport,nodecl> end
global function ma_spatializer_get_output_channels(pSpatializer: *ma_spatializer): uint32 <cimport,nodecl> end
global function ma_spatializer_set_attenuation_model(pSpatializer: *ma_spatializer, attenuationModel: ma_attenuation_model): void <cimport,nodecl> end
global function ma_spatializer_get_attenuation_model(pSpatializer: *ma_spatializer): ma_attenuation_model <cimport,nodecl> end
global function ma_spatializer_set_positioning(pSpatializer: *ma_spatializer, positioning: ma_positioning): void <cimport,nodecl> end
global function ma_spatializer_get_positioning(pSpatializer: *ma_spatializer): ma_positioning <cimport,nodecl> end
global function ma_spatializer_set_rolloff(pSpatializer: *ma_spatializer, rolloff: float32): void <cimport,nodecl> end
global function ma_spatializer_get_rolloff(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_min_gain(pSpatializer: *ma_spatializer, minGain: float32): void <cimport,nodecl> end
global function ma_spatializer_get_min_gain(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_max_gain(pSpatializer: *ma_spatializer, maxGain: float32): void <cimport,nodecl> end
global function ma_spatializer_get_max_gain(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_min_distance(pSpatializer: *ma_spatializer, minDistance: float32): void <cimport,nodecl> end
global function ma_spatializer_get_min_distance(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_max_distance(pSpatializer: *ma_spatializer, maxDistance: float32): void <cimport,nodecl> end
global function ma_spatializer_get_max_distance(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_cone(pSpatializer: *ma_spatializer, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32): void <cimport,nodecl> end
global function ma_spatializer_get_cone(pSpatializer: *ma_spatializer, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32): void <cimport,nodecl> end
global function ma_spatializer_set_doppler_factor(pSpatializer: *ma_spatializer, dopplerFactor: float32): void <cimport,nodecl> end
global function ma_spatializer_get_doppler_factor(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_directional_attenuation_factor(pSpatializer: *ma_spatializer, directionalAttenuationFactor: float32): void <cimport,nodecl> end
global function ma_spatializer_get_directional_attenuation_factor(pSpatializer: *ma_spatializer): float32 <cimport,nodecl> end
global function ma_spatializer_set_position(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_get_position(pSpatializer: *ma_spatializer): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_set_direction(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_get_direction(pSpatializer: *ma_spatializer): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_set_velocity(pSpatializer: *ma_spatializer, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_spatializer_get_velocity(pSpatializer: *ma_spatializer): ma_vec3f <cimport,nodecl> end
global function ma_spatializer_get_relative_position_and_direction(pSpatializer: *ma_spatializer, pListener: *ma_spatializer_listener, pRelativePos: *ma_vec3f, pRelativeDir: *ma_vec3f): void <cimport,nodecl> end
global ma_linear_resampler_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  lpfOrder: uint32,
  lpfNyquistFactor: float64
}
global function ma_linear_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_linear_resampler_config <cimport,nodecl> end
global ma_linear_resampler: type <cimport,nodecl> = @record{
  config: ma_linear_resampler_config,
  inAdvanceInt: uint32,
  inAdvanceFrac: uint32,
  inTimeInt: uint32,
  inTimeFrac: uint32,
  x0: union{
    f32: *float32,
    s16: *int16
  },
  x1: union{
    f32: *float32,
    s16: *int16
  },
  lpf: ma_lpf,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_linear_resampler_get_heap_size(pConfig: *ma_linear_resampler_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_linear_resampler_init_preallocated(pConfig: *ma_linear_resampler_config, pHeap: pointer, pResampler: *ma_linear_resampler): ma_result <cimport,nodecl> end
global function ma_linear_resampler_init(pConfig: *ma_linear_resampler_config, pAllocationCallbacks: *ma_allocation_callbacks, pResampler: *ma_linear_resampler): ma_result <cimport,nodecl> end
global function ma_linear_resampler_uninit(pResampler: *ma_linear_resampler, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_linear_resampler_process_pcm_frames(pResampler: *ma_linear_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport,nodecl> end
global function ma_linear_resampler_set_rate(pResampler: *ma_linear_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport,nodecl> end
global function ma_linear_resampler_set_rate_ratio(pResampler: *ma_linear_resampler, ratioInOut: float32): ma_result <cimport,nodecl> end
global function ma_linear_resampler_get_input_latency(pResampler: *ma_linear_resampler): uint64 <cimport,nodecl> end
global function ma_linear_resampler_get_output_latency(pResampler: *ma_linear_resampler): uint64 <cimport,nodecl> end
global function ma_linear_resampler_get_required_input_frame_count(pResampler: *ma_linear_resampler, outputFrameCount: uint64, pInputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_linear_resampler_get_expected_output_frame_count(pResampler: *ma_linear_resampler, inputFrameCount: uint64, pOutputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_linear_resampler_reset(pResampler: *ma_linear_resampler): ma_result <cimport,nodecl> end
global ma_resampler_config: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resampling_backend_vtable: type <cimport,nodecl> = @record{
  onGetHeapSize: function(pointer, *ma_resampler_config, *csize): ma_result,
  onInit: function(pointer, *ma_resampler_config, pointer, *pointer): ma_result,
  onUninit: function(pointer, pointer, *ma_allocation_callbacks): void,
  onProcess: function(pointer, pointer, pointer, *uint64, pointer, *uint64): ma_result,
  onSetRate: function(pointer, pointer, uint32, uint32): ma_result,
  onGetInputLatency: function(pointer, pointer): uint64,
  onGetOutputLatency: function(pointer, pointer): uint64,
  onGetRequiredInputFrameCount: function(pointer, pointer, uint64, *uint64): ma_result,
  onGetExpectedOutputFrameCount: function(pointer, pointer, uint64, *uint64): ma_result,
  onReset: function(pointer, pointer): ma_result
}
global ma_resample_algorithm: type <cimport,nodecl,using> = @enum(cint){
  ma_resample_algorithm_linear = 0,
  ma_resample_algorithm_custom = 1
}
ma_resampler_config = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  algorithm: ma_resample_algorithm,
  pBackendVTable: *ma_resampling_backend_vtable,
  pBackendUserData: pointer,
  linear: record{
    lpfOrder: uint32
  }
}
global function ma_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32, algorithm: ma_resample_algorithm): ma_resampler_config <cimport,nodecl> end
global ma_resampler: type <cimport,nodecl> = @record{
  pBackend: pointer,
  pBackendVTable: *ma_resampling_backend_vtable,
  pBackendUserData: pointer,
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  state: union{
    linear: ma_linear_resampler
  },
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_resampler_get_heap_size(pConfig: *ma_resampler_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_resampler_init_preallocated(pConfig: *ma_resampler_config, pHeap: pointer, pResampler: *ma_resampler): ma_result <cimport,nodecl> end
global function ma_resampler_init(pConfig: *ma_resampler_config, pAllocationCallbacks: *ma_allocation_callbacks, pResampler: *ma_resampler): ma_result <cimport,nodecl> end
global function ma_resampler_uninit(pResampler: *ma_resampler, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_resampler_process_pcm_frames(pResampler: *ma_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport,nodecl> end
global function ma_resampler_set_rate(pResampler: *ma_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport,nodecl> end
global function ma_resampler_set_rate_ratio(pResampler: *ma_resampler, ratio: float32): ma_result <cimport,nodecl> end
global function ma_resampler_get_input_latency(pResampler: *ma_resampler): uint64 <cimport,nodecl> end
global function ma_resampler_get_output_latency(pResampler: *ma_resampler): uint64 <cimport,nodecl> end
global function ma_resampler_get_required_input_frame_count(pResampler: *ma_resampler, outputFrameCount: uint64, pInputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_resampler_get_expected_output_frame_count(pResampler: *ma_resampler, inputFrameCount: uint64, pOutputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_resampler_reset(pResampler: *ma_resampler): ma_result <cimport,nodecl> end
global ma_channel_conversion_path: type <cimport,nodecl,using> = @enum(cint){
  ma_channel_conversion_path_unknown = 0,
  ma_channel_conversion_path_passthrough = 1,
  ma_channel_conversion_path_mono_out = 2,
  ma_channel_conversion_path_mono_in = 3,
  ma_channel_conversion_path_shuffle = 4,
  ma_channel_conversion_path_weights = 5
}
global ma_mono_expansion_mode: type <cimport,nodecl,using> = @enum(cint){
  ma_mono_expansion_mode_duplicate = 0,
  ma_mono_expansion_mode_average = 1,
  ma_mono_expansion_mode_stereo_only = 2,
  ma_mono_expansion_mode_default = 0
}
global ma_channel_converter_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  pChannelMapIn: *ma_channel,
  pChannelMapOut: *ma_channel,
  mixingMode: ma_channel_mix_mode,
  calculateLFEFromSpatialChannels: ma_bool32,
  ppWeights: **float32
}
global function ma_channel_converter_config_init(format: ma_format, channelsIn: uint32, pChannelMapIn: *ma_channel, channelsOut: uint32, pChannelMapOut: *ma_channel, mixingMode: ma_channel_mix_mode): ma_channel_converter_config <cimport,nodecl> end
global ma_channel_converter: type <cimport,nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  mixingMode: ma_channel_mix_mode,
  conversionPath: ma_channel_conversion_path,
  pChannelMapIn: *ma_channel,
  pChannelMapOut: *ma_channel,
  pShuffleTable: *uint8,
  weights: union{
    f32: **float32,
    s16: **int32
  },
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_channel_converter_get_heap_size(pConfig: *ma_channel_converter_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_channel_converter_init_preallocated(pConfig: *ma_channel_converter_config, pHeap: pointer, pConverter: *ma_channel_converter): ma_result <cimport,nodecl> end
global function ma_channel_converter_init(pConfig: *ma_channel_converter_config, pAllocationCallbacks: *ma_allocation_callbacks, pConverter: *ma_channel_converter): ma_result <cimport,nodecl> end
global function ma_channel_converter_uninit(pConverter: *ma_channel_converter, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_channel_converter_process_pcm_frames(pConverter: *ma_channel_converter, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_channel_converter_get_input_channel_map(pConverter: *ma_channel_converter, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_channel_converter_get_output_channel_map(pConverter: *ma_channel_converter, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global ma_data_converter_config: type <cimport,nodecl> = @record{
  formatIn: ma_format,
  formatOut: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  pChannelMapIn: *ma_channel,
  pChannelMapOut: *ma_channel,
  ditherMode: ma_dither_mode,
  channelMixMode: ma_channel_mix_mode,
  calculateLFEFromSpatialChannels: ma_bool32,
  ppChannelWeights: **float32,
  allowDynamicSampleRate: ma_bool32,
  resampling: ma_resampler_config
}
global function ma_data_converter_config_init_default(): ma_data_converter_config <cimport,nodecl> end
global function ma_data_converter_config_init(formatIn: ma_format, formatOut: ma_format, channelsIn: uint32, channelsOut: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_data_converter_config <cimport,nodecl> end
global ma_data_converter_execution_path: type <cimport,nodecl,using> = @enum(cint){
  ma_data_converter_execution_path_passthrough = 0,
  ma_data_converter_execution_path_format_only = 1,
  ma_data_converter_execution_path_channels_only = 2,
  ma_data_converter_execution_path_resample_only = 3,
  ma_data_converter_execution_path_resample_first = 4,
  ma_data_converter_execution_path_channels_first = 5
}
global ma_data_converter: type <cimport,nodecl> = @record{
  formatIn: ma_format,
  formatOut: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  ditherMode: ma_dither_mode,
  executionPath: ma_data_converter_execution_path,
  channelConverter: ma_channel_converter,
  resampler: ma_resampler,
  hasPreFormatConversion: ma_bool8,
  hasPostFormatConversion: ma_bool8,
  hasChannelConverter: ma_bool8,
  hasResampler: ma_bool8,
  isPassthrough: ma_bool8,
  _ownsHeap: ma_bool8,
  _pHeap: pointer
}
global function ma_data_converter_get_heap_size(pConfig: *ma_data_converter_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_data_converter_init_preallocated(pConfig: *ma_data_converter_config, pHeap: pointer, pConverter: *ma_data_converter): ma_result <cimport,nodecl> end
global function ma_data_converter_init(pConfig: *ma_data_converter_config, pAllocationCallbacks: *ma_allocation_callbacks, pConverter: *ma_data_converter): ma_result <cimport,nodecl> end
global function ma_data_converter_uninit(pConverter: *ma_data_converter, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_data_converter_process_pcm_frames(pConverter: *ma_data_converter, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport,nodecl> end
global function ma_data_converter_set_rate(pConverter: *ma_data_converter, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport,nodecl> end
global function ma_data_converter_set_rate_ratio(pConverter: *ma_data_converter, ratioInOut: float32): ma_result <cimport,nodecl> end
global function ma_data_converter_get_input_latency(pConverter: *ma_data_converter): uint64 <cimport,nodecl> end
global function ma_data_converter_get_output_latency(pConverter: *ma_data_converter): uint64 <cimport,nodecl> end
global function ma_data_converter_get_required_input_frame_count(pConverter: *ma_data_converter, outputFrameCount: uint64, pInputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_data_converter_get_expected_output_frame_count(pConverter: *ma_data_converter, inputFrameCount: uint64, pOutputFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_data_converter_get_input_channel_map(pConverter: *ma_data_converter, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_data_converter_get_output_channel_map(pConverter: *ma_data_converter, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_data_converter_reset(pConverter: *ma_data_converter): ma_result <cimport,nodecl> end
global function ma_pcm_u8_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_u8_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_u8_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_u8_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s16_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s16_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s16_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s16_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s24_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s24_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s24_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s24_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_s32_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_f32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_f32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_f32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_f32_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_pcm_convert(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, sampleCount: uint64, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_convert_pcm_frames_format(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, frameCount: uint64, channels: uint32, ditherMode: ma_dither_mode): void <cimport,nodecl> end
global function ma_deinterleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, pInterleavedPCMFrames: pointer, ppDeinterleavedPCMFrames: *pointer): void <cimport,nodecl> end
global function ma_interleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, ppDeinterleavedPCMFrames: *pointer, pInterleavedPCMFrames: pointer): void <cimport,nodecl> end
global function ma_channel_map_get_channel(pChannelMap: *ma_channel, channelCount: uint32, channelIndex: uint32): ma_channel <cimport,nodecl> end
global function ma_channel_map_init_blank(pChannelMap: *ma_channel, channels: uint32): void <cimport,nodecl> end
global function ma_channel_map_init_standard(standardChannelMap: ma_standard_channel_map, pChannelMap: *ma_channel, channelMapCap: csize, channels: uint32): void <cimport,nodecl> end
global function ma_channel_map_copy(pOut: *ma_channel, pIn: *ma_channel, channels: uint32): void <cimport,nodecl> end
global function ma_channel_map_copy_or_default(pOut: *ma_channel, channelMapCapOut: csize, pIn: *ma_channel, channels: uint32): void <cimport,nodecl> end
global function ma_channel_map_is_valid(pChannelMap: *ma_channel, channels: uint32): ma_bool32 <cimport,nodecl> end
global function ma_channel_map_is_equal(pChannelMapA: *ma_channel, pChannelMapB: *ma_channel, channels: uint32): ma_bool32 <cimport,nodecl> end
global function ma_channel_map_is_blank(pChannelMap: *ma_channel, channels: uint32): ma_bool32 <cimport,nodecl> end
global function ma_channel_map_contains_channel_position(channels: uint32, pChannelMap: *ma_channel, channelPosition: ma_channel): ma_bool32 <cimport,nodecl> end
global function ma_channel_map_find_channel_position(channels: uint32, pChannelMap: *ma_channel, channelPosition: ma_channel, pChannelIndex: *uint32): ma_bool32 <cimport,nodecl> end
global function ma_channel_map_to_string(pChannelMap: *ma_channel, channels: uint32, pBufferOut: cstring, bufferCap: csize): csize <cimport,nodecl> end
global function ma_channel_position_to_string(channel: ma_channel): cstring <cimport,nodecl> end
global function ma_convert_frames(pOut: pointer, frameCountOut: uint64, formatOut: ma_format, channelsOut: uint32, sampleRateOut: uint32, pIn: pointer, frameCountIn: uint64, formatIn: ma_format, channelsIn: uint32, sampleRateIn: uint32): uint64 <cimport,nodecl> end
global function ma_convert_frames_ex(pOut: pointer, frameCountOut: uint64, pIn: pointer, frameCountIn: uint64, pConfig: *ma_data_converter_config): uint64 <cimport,nodecl> end
global ma_data_source_vtable: type <cimport,nodecl> = @record{
  onRead: function(pointer, pointer, uint64, *uint64): ma_result,
  onSeek: function(pointer, uint64): ma_result,
  onGetDataFormat: function(pointer, *ma_format, *uint32, *uint32, *ma_channel, csize): ma_result,
  onGetCursor: function(pointer, *uint64): ma_result,
  onGetLength: function(pointer, *uint64): ma_result,
  onSetLooping: function(pointer, ma_bool32): ma_result,
  flags: uint32
}
global ma_data_source_get_next_proc: type <cimport,nodecl> = @function(pointer): pointer
global ma_data_source_config: type <cimport,nodecl> = @record{
  vtable: *ma_data_source_vtable
}
global function ma_data_source_config_init(): ma_data_source_config <cimport,nodecl> end
global ma_data_source_base: type <cimport,nodecl,aligned(8)> = @record{
  vtable: *ma_data_source_vtable,
  rangeBegInFrames: uint64,
  rangeEndInFrames: uint64,
  loopBegInFrames: uint64,
  loopEndInFrames: uint64,
  pCurrent: pointer,
  pNext: pointer,
  onGetNext: ma_data_source_get_next_proc,
  isLooping: ma_bool32
}
global function ma_data_source_init(pConfig: *ma_data_source_config, pDataSource: pointer): ma_result <cimport,nodecl> end
global function ma_data_source_uninit(pDataSource: pointer): void <cimport,nodecl> end
global function ma_data_source_read_pcm_frames(pDataSource: pointer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_data_source_seek_pcm_frames(pDataSource: pointer, frameCount: uint64, pFramesSeeked: *uint64): ma_result <cimport,nodecl> end
global function ma_data_source_seek_to_pcm_frame(pDataSource: pointer, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_data_source_get_data_format(pDataSource: pointer, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_data_source_get_cursor_in_pcm_frames(pDataSource: pointer, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_data_source_get_length_in_pcm_frames(pDataSource: pointer, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_data_source_get_cursor_in_seconds(pDataSource: pointer, pCursor: *float32): ma_result <cimport,nodecl> end
global function ma_data_source_get_length_in_seconds(pDataSource: pointer, pLength: *float32): ma_result <cimport,nodecl> end
global function ma_data_source_set_looping(pDataSource: pointer, isLooping: ma_bool32): ma_result <cimport,nodecl> end
global function ma_data_source_is_looping(pDataSource: pointer): ma_bool32 <cimport,nodecl> end
global function ma_data_source_set_range_in_pcm_frames(pDataSource: pointer, rangeBegInFrames: uint64, rangeEndInFrames: uint64): ma_result <cimport,nodecl> end
global function ma_data_source_get_range_in_pcm_frames(pDataSource: pointer, pRangeBegInFrames: *uint64, pRangeEndInFrames: *uint64): void <cimport,nodecl> end
global function ma_data_source_set_loop_point_in_pcm_frames(pDataSource: pointer, loopBegInFrames: uint64, loopEndInFrames: uint64): ma_result <cimport,nodecl> end
global function ma_data_source_get_loop_point_in_pcm_frames(pDataSource: pointer, pLoopBegInFrames: *uint64, pLoopEndInFrames: *uint64): void <cimport,nodecl> end
global function ma_data_source_set_current(pDataSource: pointer, pCurrentDataSource: pointer): ma_result <cimport,nodecl> end
global function ma_data_source_get_current(pDataSource: pointer): pointer <cimport,nodecl> end
global function ma_data_source_set_next(pDataSource: pointer, pNextDataSource: pointer): ma_result <cimport,nodecl> end
global function ma_data_source_get_next(pDataSource: pointer): pointer <cimport,nodecl> end
global function ma_data_source_set_next_callback(pDataSource: pointer, onGetNext: ma_data_source_get_next_proc): ma_result <cimport,nodecl> end
global function ma_data_source_get_next_callback(pDataSource: pointer): ma_data_source_get_next_proc <cimport,nodecl> end
global ma_audio_buffer_ref: type <cimport,nodecl,aligned(8)> = @record{
  ds: ma_data_source_base,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cursor: uint64,
  sizeInFrames: uint64,
  pData: pointer
}
global function ma_audio_buffer_ref_init(format: ma_format, channels: uint32, pData: pointer, sizeInFrames: uint64, pAudioBufferRef: *ma_audio_buffer_ref): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_uninit(pAudioBufferRef: *ma_audio_buffer_ref): void <cimport,nodecl> end
global function ma_audio_buffer_ref_set_data(pAudioBufferRef: *ma_audio_buffer_ref, pData: pointer, sizeInFrames: uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_read_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport,nodecl> end
global function ma_audio_buffer_ref_seek_to_pcm_frame(pAudioBufferRef: *ma_audio_buffer_ref, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_map(pAudioBufferRef: *ma_audio_buffer_ref, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_unmap(pAudioBufferRef: *ma_audio_buffer_ref, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_at_end(pAudioBufferRef: *ma_audio_buffer_ref): ma_bool32 <cimport,nodecl> end
global function ma_audio_buffer_ref_get_cursor_in_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_get_length_in_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_ref_get_available_frames(pAudioBufferRef: *ma_audio_buffer_ref, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global ma_audio_buffer_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  sizeInFrames: uint64,
  pData: pointer,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_audio_buffer_config_init(format: ma_format, channels: uint32, sizeInFrames: uint64, pData: pointer, pAllocationCallbacks: *ma_allocation_callbacks): ma_audio_buffer_config <cimport,nodecl> end
global ma_audio_buffer: type <cimport,nodecl,aligned(8)> = @record{
  ref: ma_audio_buffer_ref,
  allocationCallbacks: ma_allocation_callbacks,
  ownsData: ma_bool32,
  _pExtraData: [1]uint8
}
global function ma_audio_buffer_init(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport,nodecl> end
global function ma_audio_buffer_init_copy(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport,nodecl> end
global function ma_audio_buffer_alloc_and_init(pConfig: *ma_audio_buffer_config, ppAudioBuffer: **ma_audio_buffer): ma_result <cimport,nodecl> end
global function ma_audio_buffer_uninit(pAudioBuffer: *ma_audio_buffer): void <cimport,nodecl> end
global function ma_audio_buffer_uninit_and_free(pAudioBuffer: *ma_audio_buffer): void <cimport,nodecl> end
global function ma_audio_buffer_read_pcm_frames(pAudioBuffer: *ma_audio_buffer, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport,nodecl> end
global function ma_audio_buffer_seek_to_pcm_frame(pAudioBuffer: *ma_audio_buffer, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_map(pAudioBuffer: *ma_audio_buffer, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_unmap(pAudioBuffer: *ma_audio_buffer, frameCount: uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_at_end(pAudioBuffer: *ma_audio_buffer): ma_bool32 <cimport,nodecl> end
global function ma_audio_buffer_get_cursor_in_pcm_frames(pAudioBuffer: *ma_audio_buffer, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_get_length_in_pcm_frames(pAudioBuffer: *ma_audio_buffer, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_audio_buffer_get_available_frames(pAudioBuffer: *ma_audio_buffer, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global ma_paged_audio_buffer_page: type <cimport,nodecl,forwarddecl> = @record{}
ma_paged_audio_buffer_page = @record{
  pNext: *ma_paged_audio_buffer_page,
  sizeInFrames: uint64,
  pAudioData: [1]uint8
}
global ma_paged_audio_buffer_data: type <cimport,nodecl,aligned(8)> = @record{
  format: ma_format,
  channels: uint32,
  head: ma_paged_audio_buffer_page,
  pTail: *ma_paged_audio_buffer_page
}
global function ma_paged_audio_buffer_data_init(format: ma_format, channels: uint32, pData: *ma_paged_audio_buffer_data): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_data_uninit(pData: *ma_paged_audio_buffer_data, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_paged_audio_buffer_data_get_head(pData: *ma_paged_audio_buffer_data): *ma_paged_audio_buffer_page <cimport,nodecl> end
global function ma_paged_audio_buffer_data_get_tail(pData: *ma_paged_audio_buffer_data): *ma_paged_audio_buffer_page <cimport,nodecl> end
global function ma_paged_audio_buffer_data_get_length_in_pcm_frames(pData: *ma_paged_audio_buffer_data, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_data_allocate_page(pData: *ma_paged_audio_buffer_data, pageSizeInFrames: uint64, pInitialData: pointer, pAllocationCallbacks: *ma_allocation_callbacks, ppPage: **ma_paged_audio_buffer_page): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_data_free_page(pData: *ma_paged_audio_buffer_data, pPage: *ma_paged_audio_buffer_page, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_data_append_page(pData: *ma_paged_audio_buffer_data, pPage: *ma_paged_audio_buffer_page): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_data_allocate_and_append_page(pData: *ma_paged_audio_buffer_data, pageSizeInFrames: uint32, pInitialData: pointer, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport,nodecl> end
global ma_paged_audio_buffer_config: type <cimport,nodecl> = @record{
  pData: *ma_paged_audio_buffer_data
}
global function ma_paged_audio_buffer_config_init(pData: *ma_paged_audio_buffer_data): ma_paged_audio_buffer_config <cimport,nodecl> end
global ma_paged_audio_buffer: type <cimport,nodecl,aligned(8)> = @record{
  ds: ma_data_source_base,
  pData: *ma_paged_audio_buffer_data,
  pCurrent: *ma_paged_audio_buffer_page,
  relativeCursor: uint64,
  absoluteCursor: uint64
}
global function ma_paged_audio_buffer_init(pConfig: *ma_paged_audio_buffer_config, pPagedAudioBuffer: *ma_paged_audio_buffer): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_uninit(pPagedAudioBuffer: *ma_paged_audio_buffer): void <cimport,nodecl> end
global function ma_paged_audio_buffer_read_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_seek_to_pcm_frame(pPagedAudioBuffer: *ma_paged_audio_buffer, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_get_cursor_in_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_paged_audio_buffer_get_length_in_pcm_frames(pPagedAudioBuffer: *ma_paged_audio_buffer, pLength: *uint64): ma_result <cimport,nodecl> end
global ma_rb: type <cimport,nodecl,aligned(8)> = @record{
  pBuffer: pointer,
  subbufferSizeInBytes: uint32,
  subbufferCount: uint32,
  subbufferStrideInBytes: uint32,
  encodedReadOffset: uint32,
  encodedWriteOffset: uint32,
  ownsBuffer: ma_bool8,
  clearOnWriteAcquire: ma_bool8,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_rb_init_ex(subbufferSizeInBytes: csize, subbufferCount: csize, subbufferStrideInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport,nodecl> end
global function ma_rb_init(bufferSizeInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport,nodecl> end
global function ma_rb_uninit(pRB: *ma_rb): void <cimport,nodecl> end
global function ma_rb_reset(pRB: *ma_rb): void <cimport,nodecl> end
global function ma_rb_acquire_read(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport,nodecl> end
global function ma_rb_commit_read(pRB: *ma_rb, sizeInBytes: csize): ma_result <cimport,nodecl> end
global function ma_rb_acquire_write(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport,nodecl> end
global function ma_rb_commit_write(pRB: *ma_rb, sizeInBytes: csize): ma_result <cimport,nodecl> end
global function ma_rb_seek_read(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport,nodecl> end
global function ma_rb_seek_write(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport,nodecl> end
global function ma_rb_pointer_distance(pRB: *ma_rb): int32 <cimport,nodecl> end
global function ma_rb_available_read(pRB: *ma_rb): uint32 <cimport,nodecl> end
global function ma_rb_available_write(pRB: *ma_rb): uint32 <cimport,nodecl> end
global function ma_rb_get_subbuffer_size(pRB: *ma_rb): csize <cimport,nodecl> end
global function ma_rb_get_subbuffer_stride(pRB: *ma_rb): csize <cimport,nodecl> end
global function ma_rb_get_subbuffer_offset(pRB: *ma_rb, subbufferIndex: csize): csize <cimport,nodecl> end
global function ma_rb_get_subbuffer_ptr(pRB: *ma_rb, subbufferIndex: csize, pBuffer: pointer): pointer <cimport,nodecl> end
global ma_pcm_rb: type <cimport,nodecl,aligned(8)> = @record{
  ds: ma_data_source_base,
  rb: ma_rb,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32
}
global function ma_pcm_rb_init_ex(format: ma_format, channels: uint32, subbufferSizeInFrames: uint32, subbufferCount: uint32, subbufferStrideInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport,nodecl> end
global function ma_pcm_rb_init(format: ma_format, channels: uint32, bufferSizeInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport,nodecl> end
global function ma_pcm_rb_uninit(pRB: *ma_pcm_rb): void <cimport,nodecl> end
global function ma_pcm_rb_reset(pRB: *ma_pcm_rb): void <cimport,nodecl> end
global function ma_pcm_rb_acquire_read(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport,nodecl> end
global function ma_pcm_rb_commit_read(pRB: *ma_pcm_rb, sizeInFrames: uint32): ma_result <cimport,nodecl> end
global function ma_pcm_rb_acquire_write(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport,nodecl> end
global function ma_pcm_rb_commit_write(pRB: *ma_pcm_rb, sizeInFrames: uint32): ma_result <cimport,nodecl> end
global function ma_pcm_rb_seek_read(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport,nodecl> end
global function ma_pcm_rb_seek_write(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport,nodecl> end
global function ma_pcm_rb_pointer_distance(pRB: *ma_pcm_rb): int32 <cimport,nodecl> end
global function ma_pcm_rb_available_read(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_available_write(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_get_subbuffer_size(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_get_subbuffer_stride(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_get_subbuffer_offset(pRB: *ma_pcm_rb, subbufferIndex: uint32): uint32 <cimport,nodecl> end
global function ma_pcm_rb_get_subbuffer_ptr(pRB: *ma_pcm_rb, subbufferIndex: uint32, pBuffer: pointer): pointer <cimport,nodecl> end
global function ma_pcm_rb_get_format(pRB: *ma_pcm_rb): ma_format <cimport,nodecl> end
global function ma_pcm_rb_get_channels(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_get_sample_rate(pRB: *ma_pcm_rb): uint32 <cimport,nodecl> end
global function ma_pcm_rb_set_sample_rate(pRB: *ma_pcm_rb, sampleRate: uint32): void <cimport,nodecl> end
global ma_duplex_rb: type <cimport,nodecl,aligned(8)> = @record{
  rb: ma_pcm_rb
}
global function ma_duplex_rb_init(captureFormat: ma_format, captureChannels: uint32, sampleRate: uint32, captureInternalSampleRate: uint32, captureInternalPeriodSizeInFrames: uint32, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_duplex_rb): ma_result <cimport,nodecl> end
global function ma_duplex_rb_uninit(pRB: *ma_duplex_rb): ma_result <cimport,nodecl> end
global function ma_result_description(result: ma_result): cstring <cimport,nodecl> end
global function ma_malloc(sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport,nodecl> end
global function ma_calloc(sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport,nodecl> end
global function ma_realloc(p: pointer, sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport,nodecl> end
global function ma_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_aligned_malloc(sz: csize, alignment: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport,nodecl> end
global function ma_aligned_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_get_format_name(format: ma_format): cstring <cimport,nodecl> end
global function ma_blend_f32(pOut: *float32, pInA: *float32, pInB: *float32, factor: float32, channels: uint32): void <cimport,nodecl> end
global function ma_get_bytes_per_sample(format: ma_format): uint32 <cimport,nodecl> end
global function ma_get_bytes_per_frame(format: ma_format, channels: uint32): uint32 <cimport,nodecl> end
global function ma_log_level_to_string(logLevel: uint32): cstring <cimport,nodecl> end
global function ma_spinlock_lock(pSpinlock: *cuint): ma_result <cimport,nodecl> end
global function ma_spinlock_lock_noyield(pSpinlock: *cuint): ma_result <cimport,nodecl> end
global function ma_spinlock_unlock(pSpinlock: *cuint): ma_result <cimport,nodecl> end
global function ma_mutex_init(pMutex: *ma_mutex): ma_result <cimport,nodecl> end
global function ma_mutex_uninit(pMutex: *ma_mutex): void <cimport,nodecl> end
global function ma_mutex_lock(pMutex: *ma_mutex): void <cimport,nodecl> end
global function ma_mutex_unlock(pMutex: *ma_mutex): void <cimport,nodecl> end
global function ma_event_init(pEvent: *ma_event): ma_result <cimport,nodecl> end
global function ma_event_uninit(pEvent: *ma_event): void <cimport,nodecl> end
global function ma_event_wait(pEvent: *ma_event): ma_result <cimport,nodecl> end
global function ma_event_signal(pEvent: *ma_event): ma_result <cimport,nodecl> end
global ma_fence: type <cimport,nodecl> = @record{
  e: ma_event,
  counter: uint32
}
global function ma_fence_init(pFence: *ma_fence): ma_result <cimport,nodecl> end
global function ma_fence_uninit(pFence: *ma_fence): void <cimport,nodecl> end
global function ma_fence_acquire(pFence: *ma_fence): ma_result <cimport,nodecl> end
global function ma_fence_release(pFence: *ma_fence): ma_result <cimport,nodecl> end
global function ma_fence_wait(pFence: *ma_fence): ma_result <cimport,nodecl> end
global ma_async_notification_callbacks: type <cimport,nodecl> = @record{
  onSignal: function(pointer): void
}
global function ma_async_notification_signal(pNotification: pointer): ma_result <cimport,nodecl> end
global ma_async_notification_poll: type <cimport,nodecl> = @record{
  cb: ma_async_notification_callbacks,
  signalled: ma_bool32
}
global function ma_async_notification_poll_init(pNotificationPoll: *ma_async_notification_poll): ma_result <cimport,nodecl> end
global function ma_async_notification_poll_is_signalled(pNotificationPoll: *ma_async_notification_poll): ma_bool32 <cimport,nodecl> end
global ma_async_notification_event: type <cimport,nodecl> = @record{
  cb: ma_async_notification_callbacks,
  e: ma_event
}
global function ma_async_notification_event_init(pNotificationEvent: *ma_async_notification_event): ma_result <cimport,nodecl> end
global function ma_async_notification_event_uninit(pNotificationEvent: *ma_async_notification_event): ma_result <cimport,nodecl> end
global function ma_async_notification_event_wait(pNotificationEvent: *ma_async_notification_event): ma_result <cimport,nodecl> end
global function ma_async_notification_event_signal(pNotificationEvent: *ma_async_notification_event): ma_result <cimport,nodecl> end
global ma_slot_allocator_config: type <cimport,nodecl> = @record{
  capacity: uint32
}
global function ma_slot_allocator_config_init(capacity: uint32): ma_slot_allocator_config <cimport,nodecl> end
global ma_slot_allocator_group: type <cimport,nodecl,aligned(4)> = @record{
  bitfield: uint32
}
global ma_slot_allocator: type <cimport,nodecl> = @record{
  pGroups: *ma_slot_allocator_group,
  pSlots: *uint32,
  count: uint32,
  capacity: uint32,
  _ownsHeap: ma_bool32,
  _pHeap: pointer
}
global function ma_slot_allocator_get_heap_size(pConfig: *ma_slot_allocator_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_slot_allocator_init_preallocated(pConfig: *ma_slot_allocator_config, pHeap: pointer, pAllocator: *ma_slot_allocator): ma_result <cimport,nodecl> end
global function ma_slot_allocator_init(pConfig: *ma_slot_allocator_config, pAllocationCallbacks: *ma_allocation_callbacks, pAllocator: *ma_slot_allocator): ma_result <cimport,nodecl> end
global function ma_slot_allocator_uninit(pAllocator: *ma_slot_allocator, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_slot_allocator_alloc(pAllocator: *ma_slot_allocator, pSlot: *uint64): ma_result <cimport,nodecl> end
global function ma_slot_allocator_free(pAllocator: *ma_slot_allocator, slot: uint64): ma_result <cimport,nodecl> end
global ma_job: type <cimport,nodecl,forwarddecl> = @record{}
global ma_job_proc: type <cimport,nodecl> = @function(*ma_job): ma_result
global ma_job_type: type <cimport,nodecl,using> = @enum(cint){
  MA_JOB_TYPE_QUIT = 0,
  MA_JOB_TYPE_CUSTOM = 1,
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER_NODE = 2,
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER_NODE = 3,
  MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_BUFFER_NODE = 4,
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_BUFFER = 5,
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_BUFFER = 6,
  MA_JOB_TYPE_RESOURCE_MANAGER_LOAD_DATA_STREAM = 7,
  MA_JOB_TYPE_RESOURCE_MANAGER_FREE_DATA_STREAM = 8,
  MA_JOB_TYPE_RESOURCE_MANAGER_PAGE_DATA_STREAM = 9,
  MA_JOB_TYPE_RESOURCE_MANAGER_SEEK_DATA_STREAM = 10,
  MA_JOB_TYPE_DEVICE_AAUDIO_REROUTE = 11,
  MA_JOB_TYPE_COUNT = 12
}
ma_job = @record{
  toc: union{
    breakup: record{
      code: uint16,
      slot: uint16,
      refcount: uint32
    },
    allocation: uint64
  },
  next: uint64,
  order: uint32,
  data: union{
    custom: record{
      proc: ma_job_proc,
      data0: usize,
      data1: usize
    },
    resourceManager: union{
      loadDataBufferNode: record{
        pResourceManager: pointer,
        pDataBufferNode: pointer,
        pFilePath: cstring,
        pFilePathW: *cwchar_t,
        flags: uint32,
        pInitNotification: pointer,
        pDoneNotification: pointer,
        pInitFence: *ma_fence,
        pDoneFence: *ma_fence
      },
      freeDataBufferNode: record{
        pResourceManager: pointer,
        pDataBufferNode: pointer,
        pDoneNotification: pointer,
        pDoneFence: *ma_fence
      },
      pageDataBufferNode: record{
        pResourceManager: pointer,
        pDataBufferNode: pointer,
        pDecoder: pointer,
        pDoneNotification: pointer,
        pDoneFence: *ma_fence
      },
      loadDataBuffer: record{
        pDataBuffer: pointer,
        pInitNotification: pointer,
        pDoneNotification: pointer,
        pInitFence: *ma_fence,
        pDoneFence: *ma_fence,
        rangeBegInPCMFrames: uint64,
        rangeEndInPCMFrames: uint64,
        loopPointBegInPCMFrames: uint64,
        loopPointEndInPCMFrames: uint64,
        isLooping: uint32
      },
      freeDataBuffer: record{
        pDataBuffer: pointer,
        pDoneNotification: pointer,
        pDoneFence: *ma_fence
      },
      loadDataStream: record{
        pDataStream: pointer,
        pFilePath: cstring,
        pFilePathW: *cwchar_t,
        initialSeekPoint: uint64,
        pInitNotification: pointer,
        pInitFence: *ma_fence
      },
      freeDataStream: record{
        pDataStream: pointer,
        pDoneNotification: pointer,
        pDoneFence: *ma_fence
      },
      pageDataStream: record{
        pDataStream: pointer,
        pageIndex: uint32
      },
      seekDataStream: record{
        pDataStream: pointer,
        frameIndex: uint64
      }
    },
    device: union{
      aaudio: union{
        reroute: record{
          pDevice: pointer,
          deviceType: uint32
        }
      }
    }
  }
}
global function ma_job_init(code: uint16): ma_job <cimport,nodecl> end
global function ma_job_process(pJob: *ma_job): ma_result <cimport,nodecl> end
global ma_job_queue_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_JOB_QUEUE_FLAG_NON_BLOCKING = 1
}
global ma_job_queue_config: type <cimport,nodecl> = @record{
  flags: uint32,
  capacity: uint32
}
global function ma_job_queue_config_init(flags: uint32, capacity: uint32): ma_job_queue_config <cimport,nodecl> end
global ma_job_queue: type <cimport,nodecl,aligned(8)> = @record{
  flags: uint32,
  capacity: uint32,
  head: uint64,
  tail: uint64,
  sem: ma_semaphore,
  allocator: ma_slot_allocator,
  pJobs: *ma_job,
  lock: cuint,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_job_queue_get_heap_size(pConfig: *ma_job_queue_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_job_queue_init_preallocated(pConfig: *ma_job_queue_config, pHeap: pointer, pQueue: *ma_job_queue): ma_result <cimport,nodecl> end
global function ma_job_queue_init(pConfig: *ma_job_queue_config, pAllocationCallbacks: *ma_allocation_callbacks, pQueue: *ma_job_queue): ma_result <cimport,nodecl> end
global function ma_job_queue_uninit(pQueue: *ma_job_queue, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_job_queue_post(pQueue: *ma_job_queue, pJob: *ma_job): ma_result <cimport,nodecl> end
global function ma_job_queue_next(pQueue: *ma_job_queue, pJob: *ma_job): ma_result <cimport,nodecl> end
global ma_device_state: type <cimport,nodecl,using> = @enum(cint){
  ma_device_state_uninitialized = 0,
  ma_device_state_stopped = 1,
  ma_device_state_started = 2,
  ma_device_state_starting = 3,
  ma_device_state_stopping = 4
}
global ma_atomic_device_state: type <cimport,nodecl,aligned(4)> = @record{
  value: ma_device_state
}
global ma_backend: type <cimport,nodecl,using> = @enum(cint){
  ma_backend_wasapi = 0,
  ma_backend_dsound = 1,
  ma_backend_winmm = 2,
  ma_backend_coreaudio = 3,
  ma_backend_sndio = 4,
  ma_backend_audio4 = 5,
  ma_backend_oss = 6,
  ma_backend_pulseaudio = 7,
  ma_backend_alsa = 8,
  ma_backend_jack = 9,
  ma_backend_aaudio = 10,
  ma_backend_opensl = 11,
  ma_backend_webaudio = 12,
  ma_backend_custom = 13,
  ma_backend_null = 14
}
global ma_device_job_thread_config: type <cimport,nodecl> = @record{
  noThread: ma_bool32,
  jobQueueCapacity: uint32,
  jobQueueFlags: uint32
}
global function ma_device_job_thread_config_init(): ma_device_job_thread_config <cimport,nodecl> end
global ma_device_job_thread: type <cimport,nodecl,aligned(8)> = @record{
  thread: culonglong,
  jobQueue: ma_job_queue,
  _hasThread: ma_bool32
}
global function ma_device_job_thread_init(pConfig: *ma_device_job_thread_config, pAllocationCallbacks: *ma_allocation_callbacks, pJobThread: *ma_device_job_thread): ma_result <cimport,nodecl> end
global function ma_device_job_thread_uninit(pJobThread: *ma_device_job_thread, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_device_job_thread_post(pJobThread: *ma_device_job_thread, pJob: *ma_job): ma_result <cimport,nodecl> end
global function ma_device_job_thread_next(pJobThread: *ma_device_job_thread, pJob: *ma_job): ma_result <cimport,nodecl> end
global ma_device_notification_type: type <cimport,nodecl,using> = @enum(cint){
  ma_device_notification_type_started = 0,
  ma_device_notification_type_stopped = 1,
  ma_device_notification_type_rerouted = 2,
  ma_device_notification_type_interruption_began = 3,
  ma_device_notification_type_interruption_ended = 4
}
global ma_device_notification: type <cimport,nodecl> = @record{
  pDevice: *ma_device,
  type: ma_device_notification_type,
  data: union{
    started: record{
      _unused: cint
    },
    stopped: record{
      _unused: cint
    },
    rerouted: record{
      _unused: cint
    },
    interruption: record{
      _unused: cint
    }
  }
}
global ma_device_notification_proc: type <cimport,nodecl> = @function(*ma_device_notification): void
global ma_device_data_proc: type <cimport,nodecl> = @function(*ma_device, pointer, pointer, uint32): void
global ma_stop_proc: type <cimport,nodecl> = @function(*ma_device): void
global ma_device_type: type <cimport,nodecl,using> = @enum(cint){
  ma_device_type_playback = 1,
  ma_device_type_capture = 2,
  ma_device_type_duplex = 3,
  ma_device_type_loopback = 4
}
global ma_share_mode: type <cimport,nodecl,using> = @enum(cint){
  ma_share_mode_shared = 0,
  ma_share_mode_exclusive = 1
}
global ma_ios_session_category: type <cimport,nodecl,using> = @enum(cint){
  ma_ios_session_category_default = 0,
  ma_ios_session_category_none = 1,
  ma_ios_session_category_ambient = 2,
  ma_ios_session_category_solo_ambient = 3,
  ma_ios_session_category_playback = 4,
  ma_ios_session_category_record = 5,
  ma_ios_session_category_play_and_record = 6,
  ma_ios_session_category_multi_route = 7
}
global ma_ios_session_category_option: type <cimport,nodecl,using> = @enum(cint){
  ma_ios_session_category_option_mix_with_others = 1,
  ma_ios_session_category_option_duck_others = 2,
  ma_ios_session_category_option_allow_bluetooth = 4,
  ma_ios_session_category_option_default_to_speaker = 8,
  ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others = 17,
  ma_ios_session_category_option_allow_bluetooth_a2dp = 32,
  ma_ios_session_category_option_allow_air_play = 64
}
global ma_opensl_stream_type: type <cimport,nodecl,using> = @enum(cint){
  ma_opensl_stream_type_default = 0,
  ma_opensl_stream_type_voice = 1,
  ma_opensl_stream_type_system = 2,
  ma_opensl_stream_type_ring = 3,
  ma_opensl_stream_type_media = 4,
  ma_opensl_stream_type_alarm = 5,
  ma_opensl_stream_type_notification = 6
}
global ma_opensl_recording_preset: type <cimport,nodecl,using> = @enum(cint){
  ma_opensl_recording_preset_default = 0,
  ma_opensl_recording_preset_generic = 1,
  ma_opensl_recording_preset_camcorder = 2,
  ma_opensl_recording_preset_voice_recognition = 3,
  ma_opensl_recording_preset_voice_communication = 4,
  ma_opensl_recording_preset_voice_unprocessed = 5
}
global ma_wasapi_usage: type <cimport,nodecl,using> = @enum(cint){
  ma_wasapi_usage_default = 0,
  ma_wasapi_usage_games = 1,
  ma_wasapi_usage_pro_audio = 2
}
global ma_aaudio_usage: type <cimport,nodecl,using> = @enum(cint){
  ma_aaudio_usage_default = 0,
  ma_aaudio_usage_media = 1,
  ma_aaudio_usage_voice_communication = 2,
  ma_aaudio_usage_voice_communication_signalling = 3,
  ma_aaudio_usage_alarm = 4,
  ma_aaudio_usage_notification = 5,
  ma_aaudio_usage_notification_ringtone = 6,
  ma_aaudio_usage_notification_event = 7,
  ma_aaudio_usage_assistance_accessibility = 8,
  ma_aaudio_usage_assistance_navigation_guidance = 9,
  ma_aaudio_usage_assistance_sonification = 10,
  ma_aaudio_usage_game = 11,
  ma_aaudio_usage_assitant = 12,
  ma_aaudio_usage_emergency = 13,
  ma_aaudio_usage_safety = 14,
  ma_aaudio_usage_vehicle_status = 15,
  ma_aaudio_usage_announcement = 16
}
global ma_aaudio_content_type: type <cimport,nodecl,using> = @enum(cint){
  ma_aaudio_content_type_default = 0,
  ma_aaudio_content_type_speech = 1,
  ma_aaudio_content_type_music = 2,
  ma_aaudio_content_type_movie = 3,
  ma_aaudio_content_type_sonification = 4
}
global ma_aaudio_input_preset: type <cimport,nodecl,using> = @enum(cint){
  ma_aaudio_input_preset_default = 0,
  ma_aaudio_input_preset_generic = 1,
  ma_aaudio_input_preset_camcorder = 2,
  ma_aaudio_input_preset_voice_recognition = 3,
  ma_aaudio_input_preset_voice_communication = 4,
  ma_aaudio_input_preset_unprocessed = 5,
  ma_aaudio_input_preset_voice_performance = 6
}
global ma_aaudio_allowed_capture_policy: type <cimport,nodecl,using> = @enum(cint){
  ma_aaudio_allow_capture_default = 0,
  ma_aaudio_allow_capture_by_all = 1,
  ma_aaudio_allow_capture_by_system = 2,
  ma_aaudio_allow_capture_by_none = 3
}
global ma_timer: type <cimport,nodecl> = @union{
  counter: int64,
  counterD: float64
}
global ma_device_id: type <cimport,nodecl> = @union{
  wasapi: [64]cushort,
  dsound: [16]uint8,
  winmm: uint32,
  alsa: [256]cchar,
  pulse: [256]cchar,
  jack: cint,
  coreaudio: [256]cchar,
  sndio: [256]cchar,
  audio4: [256]cchar,
  oss: [64]cchar,
  aaudio: int32,
  opensl: uint32,
  webaudio: [32]cchar,
  custom: union{
    i: cint,
    s: [256]cchar,
    p: pointer
  },
  nullbackend: cint
}
global ma_context_config: type <cimport,nodecl,forwarddecl> = @record{}
global ma_device_config: type <cimport,nodecl,forwarddecl> = @record{}
global ma_backend_callbacks: type <cimport,nodecl,forwarddecl> = @record{}
global ma_device_info: type <cimport,nodecl> = @record{
  id: ma_device_id,
  name: [256]cchar,
  isDefault: ma_bool32,
  nativeDataFormatCount: uint32,
  nativeDataFormats: [64]record{
    format: ma_format,
    channels: uint32,
    sampleRate: uint32,
    flags: uint32
  }
}
ma_device_config = @record{
  deviceType: ma_device_type,
  sampleRate: uint32,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periods: uint32,
  performanceProfile: ma_performance_profile,
  noPreSilencedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  noDisableDenormals: ma_bool8,
  noFixedSizedCallback: ma_bool8,
  dataCallback: ma_device_data_proc,
  notificationCallback: ma_device_notification_proc,
  stopCallback: ma_stop_proc,
  pUserData: pointer,
  resampling: ma_resampler_config,
  playback: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    pChannelMap: *ma_channel,
    channelMixMode: ma_channel_mix_mode,
    calculateLFEFromSpatialChannels: ma_bool32,
    shareMode: ma_share_mode
  },
  capture: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    pChannelMap: *ma_channel,
    channelMixMode: ma_channel_mix_mode,
    calculateLFEFromSpatialChannels: ma_bool32,
    shareMode: ma_share_mode
  },
  wasapi: record{
    usage: ma_wasapi_usage,
    noAutoConvertSRC: ma_bool8,
    noDefaultQualitySRC: ma_bool8,
    noAutoStreamRouting: ma_bool8,
    noHardwareOffloading: ma_bool8,
    loopbackProcessID: uint32,
    loopbackProcessExclude: ma_bool8
  },
  alsa: record{
    noMMap: ma_bool32,
    noAutoFormat: ma_bool32,
    noAutoChannels: ma_bool32,
    noAutoResample: ma_bool32
  },
  pulse: record{
    pStreamNamePlayback: cstring,
    pStreamNameCapture: cstring
  },
  coreaudio: record{
    allowNominalSampleRateChange: ma_bool32
  },
  opensl: record{
    streamType: ma_opensl_stream_type,
    recordingPreset: ma_opensl_recording_preset,
    enableCompatibilityWorkarounds: ma_bool32
  },
  aaudio: record{
    usage: ma_aaudio_usage,
    contentType: ma_aaudio_content_type,
    inputPreset: ma_aaudio_input_preset,
    allowedCapturePolicy: ma_aaudio_allowed_capture_policy,
    noAutoStartAfterReroute: ma_bool32,
    enableCompatibilityWorkarounds: ma_bool32
  }
}
global ma_enum_devices_callback_proc: type <cimport,nodecl> = @function(*ma_context, ma_device_type, *ma_device_info, pointer): ma_bool32
global ma_device_descriptor: type <cimport,nodecl> = @record{
  pDeviceID: *ma_device_id,
  shareMode: ma_share_mode,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  channelMap: [254]ma_channel,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periodCount: uint32
}
ma_backend_callbacks = @record{
  onContextInit: function(*ma_context, *ma_context_config, *ma_backend_callbacks): ma_result,
  onContextUninit: function(*ma_context): ma_result,
  onContextEnumerateDevices: function(*ma_context, ma_enum_devices_callback_proc, pointer): ma_result,
  onContextGetDeviceInfo: function(*ma_context, ma_device_type, *ma_device_id, *ma_device_info): ma_result,
  onDeviceInit: function(*ma_device, *ma_device_config, *ma_device_descriptor, *ma_device_descriptor): ma_result,
  onDeviceUninit: function(*ma_device): ma_result,
  onDeviceStart: function(*ma_device): ma_result,
  onDeviceStop: function(*ma_device): ma_result,
  onDeviceRead: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceWrite: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceDataLoop: function(*ma_device): ma_result,
  onDeviceDataLoopWakeup: function(*ma_device): ma_result,
  onDeviceGetInfo: function(*ma_device, ma_device_type, *ma_device_info): ma_result
}
ma_context_config = @record{
  pLog: *ma_log,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  alsa: record{
    useVerboseDeviceEnumeration: ma_bool32
  },
  pulse: record{
    pApplicationName: cstring,
    pServerName: cstring,
    tryAutoSpawn: ma_bool32
  },
  coreaudio: record{
    sessionCategory: ma_ios_session_category,
    sessionCategoryOptions: uint32,
    noAudioSessionActivate: ma_bool32,
    noAudioSessionDeactivate: ma_bool32
  },
  jack: record{
    pClientName: cstring,
    tryStartServer: ma_bool32
  },
  custom: ma_backend_callbacks
}
global ma_context_command__wasapi: type <cimport,nodecl> = @record{
  code: cint,
  pEvent: *ma_event,
  data: union{
    quit: record{
      _unused: cint
    },
    createAudioClient: record{
      deviceType: ma_device_type,
      pAudioClient: pointer,
      ppAudioClientService: *pointer,
      pResult: *ma_result
    },
    releaseAudioClient: record{
      pDevice: *ma_device,
      deviceType: ma_device_type
    }
  }
}
ma_context = @record{
  callbacks: ma_backend_callbacks,
  backend: ma_backend,
  pLog: *ma_log,
  log: ma_log,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  deviceEnumLock: ma_mutex,
  deviceInfoLock: ma_mutex,
  deviceInfoCapacity: uint32,
  playbackDeviceInfoCount: uint32,
  captureDeviceInfoCount: uint32,
  pDeviceInfos: *ma_device_info,
  __unnamed1: union{
    alsa: record{
      asoundSO: ma_handle,
      snd_pcm_open: ma_proc,
      snd_pcm_close: ma_proc,
      snd_pcm_hw_params_sizeof: ma_proc,
      snd_pcm_hw_params_any: ma_proc,
      snd_pcm_hw_params_set_format: ma_proc,
      snd_pcm_hw_params_set_format_first: ma_proc,
      snd_pcm_hw_params_get_format_mask: ma_proc,
      snd_pcm_hw_params_set_channels: ma_proc,
      snd_pcm_hw_params_set_channels_near: ma_proc,
      snd_pcm_hw_params_set_channels_minmax: ma_proc,
      snd_pcm_hw_params_set_rate_resample: ma_proc,
      snd_pcm_hw_params_set_rate: ma_proc,
      snd_pcm_hw_params_set_rate_near: ma_proc,
      snd_pcm_hw_params_set_buffer_size_near: ma_proc,
      snd_pcm_hw_params_set_periods_near: ma_proc,
      snd_pcm_hw_params_set_access: ma_proc,
      snd_pcm_hw_params_get_format: ma_proc,
      snd_pcm_hw_params_get_channels: ma_proc,
      snd_pcm_hw_params_get_channels_min: ma_proc,
      snd_pcm_hw_params_get_channels_max: ma_proc,
      snd_pcm_hw_params_get_rate: ma_proc,
      snd_pcm_hw_params_get_rate_min: ma_proc,
      snd_pcm_hw_params_get_rate_max: ma_proc,
      snd_pcm_hw_params_get_buffer_size: ma_proc,
      snd_pcm_hw_params_get_periods: ma_proc,
      snd_pcm_hw_params_get_access: ma_proc,
      snd_pcm_hw_params_test_format: ma_proc,
      snd_pcm_hw_params_test_channels: ma_proc,
      snd_pcm_hw_params_test_rate: ma_proc,
      snd_pcm_hw_params: ma_proc,
      snd_pcm_sw_params_sizeof: ma_proc,
      snd_pcm_sw_params_current: ma_proc,
      snd_pcm_sw_params_get_boundary: ma_proc,
      snd_pcm_sw_params_set_avail_min: ma_proc,
      snd_pcm_sw_params_set_start_threshold: ma_proc,
      snd_pcm_sw_params_set_stop_threshold: ma_proc,
      snd_pcm_sw_params: ma_proc,
      snd_pcm_format_mask_sizeof: ma_proc,
      snd_pcm_format_mask_test: ma_proc,
      snd_pcm_get_chmap: ma_proc,
      snd_pcm_state: ma_proc,
      snd_pcm_prepare: ma_proc,
      snd_pcm_start: ma_proc,
      snd_pcm_drop: ma_proc,
      snd_pcm_drain: ma_proc,
      snd_pcm_reset: ma_proc,
      snd_device_name_hint: ma_proc,
      snd_device_name_get_hint: ma_proc,
      snd_card_get_index: ma_proc,
      snd_device_name_free_hint: ma_proc,
      snd_pcm_mmap_begin: ma_proc,
      snd_pcm_mmap_commit: ma_proc,
      snd_pcm_recover: ma_proc,
      snd_pcm_readi: ma_proc,
      snd_pcm_writei: ma_proc,
      snd_pcm_avail: ma_proc,
      snd_pcm_avail_update: ma_proc,
      snd_pcm_wait: ma_proc,
      snd_pcm_nonblock: ma_proc,
      snd_pcm_info: ma_proc,
      snd_pcm_info_sizeof: ma_proc,
      snd_pcm_info_get_name: ma_proc,
      snd_pcm_poll_descriptors: ma_proc,
      snd_pcm_poll_descriptors_count: ma_proc,
      snd_pcm_poll_descriptors_revents: ma_proc,
      snd_config_update_free_global: ma_proc,
      internalDeviceEnumLock: ma_mutex,
      useVerboseDeviceEnumeration: ma_bool32
    },
    pulse: record{
      pulseSO: ma_handle,
      pa_mainloop_new: ma_proc,
      pa_mainloop_free: ma_proc,
      pa_mainloop_quit: ma_proc,
      pa_mainloop_get_api: ma_proc,
      pa_mainloop_iterate: ma_proc,
      pa_mainloop_wakeup: ma_proc,
      pa_threaded_mainloop_new: ma_proc,
      pa_threaded_mainloop_free: ma_proc,
      pa_threaded_mainloop_start: ma_proc,
      pa_threaded_mainloop_stop: ma_proc,
      pa_threaded_mainloop_lock: ma_proc,
      pa_threaded_mainloop_unlock: ma_proc,
      pa_threaded_mainloop_wait: ma_proc,
      pa_threaded_mainloop_signal: ma_proc,
      pa_threaded_mainloop_accept: ma_proc,
      pa_threaded_mainloop_get_retval: ma_proc,
      pa_threaded_mainloop_get_api: ma_proc,
      pa_threaded_mainloop_in_thread: ma_proc,
      pa_threaded_mainloop_set_name: ma_proc,
      pa_context_new: ma_proc,
      pa_context_unref: ma_proc,
      pa_context_connect: ma_proc,
      pa_context_disconnect: ma_proc,
      pa_context_set_state_callback: ma_proc,
      pa_context_get_state: ma_proc,
      pa_context_get_sink_info_list: ma_proc,
      pa_context_get_source_info_list: ma_proc,
      pa_context_get_sink_info_by_name: ma_proc,
      pa_context_get_source_info_by_name: ma_proc,
      pa_operation_unref: ma_proc,
      pa_operation_get_state: ma_proc,
      pa_channel_map_init_extend: ma_proc,
      pa_channel_map_valid: ma_proc,
      pa_channel_map_compatible: ma_proc,
      pa_stream_new: ma_proc,
      pa_stream_unref: ma_proc,
      pa_stream_connect_playback: ma_proc,
      pa_stream_connect_record: ma_proc,
      pa_stream_disconnect: ma_proc,
      pa_stream_get_state: ma_proc,
      pa_stream_get_sample_spec: ma_proc,
      pa_stream_get_channel_map: ma_proc,
      pa_stream_get_buffer_attr: ma_proc,
      pa_stream_set_buffer_attr: ma_proc,
      pa_stream_get_device_name: ma_proc,
      pa_stream_set_write_callback: ma_proc,
      pa_stream_set_read_callback: ma_proc,
      pa_stream_set_suspended_callback: ma_proc,
      pa_stream_set_moved_callback: ma_proc,
      pa_stream_is_suspended: ma_proc,
      pa_stream_flush: ma_proc,
      pa_stream_drain: ma_proc,
      pa_stream_is_corked: ma_proc,
      pa_stream_cork: ma_proc,
      pa_stream_trigger: ma_proc,
      pa_stream_begin_write: ma_proc,
      pa_stream_write: ma_proc,
      pa_stream_peek: ma_proc,
      pa_stream_drop: ma_proc,
      pa_stream_writable_size: ma_proc,
      pa_stream_readable_size: ma_proc,
      pMainLoop: ma_ptr,
      pPulseContext: ma_ptr,
      pApplicationName: cstring,
      pServerName: cstring
    },
    jack: record{
      jackSO: ma_handle,
      jack_client_open: ma_proc,
      jack_client_close: ma_proc,
      jack_client_name_size: ma_proc,
      jack_set_process_callback: ma_proc,
      jack_set_buffer_size_callback: ma_proc,
      jack_on_shutdown: ma_proc,
      jack_get_sample_rate: ma_proc,
      jack_get_buffer_size: ma_proc,
      jack_get_ports: ma_proc,
      jack_activate: ma_proc,
      jack_deactivate: ma_proc,
      jack_connect: ma_proc,
      jack_port_register: ma_proc,
      jack_port_name: ma_proc,
      jack_port_get_buffer: ma_proc,
      jack_free: ma_proc,
      pClientName: cstring,
      tryStartServer: ma_bool32
    },
    null_backend: record{
      _unused: cint
    }
  },
  __unnamed2: union{
    posix: record{
      _unused: cint
    },
    _unused: cint
  }
}
ma_device = @record{
  pContext: *ma_context,
  type: ma_device_type,
  sampleRate: uint32,
  state: ma_atomic_device_state,
  onData: ma_device_data_proc,
  onNotification: ma_device_notification_proc,
  onStop: ma_stop_proc,
  pUserData: pointer,
  startStopLock: ma_mutex,
  wakeupEvent: ma_event,
  startEvent: ma_event,
  stopEvent: ma_event,
  thread: culonglong,
  workResult: ma_result,
  isOwnerOfContext: ma_bool8,
  noPreSilencedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  noDisableDenormals: ma_bool8,
  noFixedSizedCallback: ma_bool8,
  masterVolumeFactor: ma_atomic_float,
  duplexRB: ma_duplex_rb,
  resampling: record{
    algorithm: ma_resample_algorithm,
    pBackendVTable: *ma_resampling_backend_vtable,
    pBackendUserData: pointer,
    linear: record{
      lpfOrder: uint32
    }
  },
  playback: record{
    pID: *ma_device_id,
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [254]ma_channel,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [254]ma_channel,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    calculateLFEFromSpatialChannels: ma_bool32,
    converter: ma_data_converter,
    pIntermediaryBuffer: pointer,
    intermediaryBufferCap: uint32,
    intermediaryBufferLen: uint32,
    pInputCache: pointer,
    inputCacheCap: uint64,
    inputCacheConsumed: uint64,
    inputCacheRemaining: uint64
  },
  capture: record{
    pID: *ma_device_id,
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [254]ma_channel,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [254]ma_channel,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    calculateLFEFromSpatialChannels: ma_bool32,
    converter: ma_data_converter,
    pIntermediaryBuffer: pointer,
    intermediaryBufferCap: uint32,
    intermediaryBufferLen: uint32
  },
  __unnamed1: union{
    alsa: record{
      pPCMPlayback: ma_ptr,
      pPCMCapture: ma_ptr,
      pPollDescriptorsPlayback: pointer,
      pPollDescriptorsCapture: pointer,
      pollDescriptorCountPlayback: cint,
      pollDescriptorCountCapture: cint,
      wakeupfdPlayback: cint,
      wakeupfdCapture: cint,
      isUsingMMapPlayback: ma_bool8,
      isUsingMMapCapture: ma_bool8
    },
    pulse: record{
      pMainLoop: ma_ptr,
      pPulseContext: ma_ptr,
      pStreamPlayback: ma_ptr,
      pStreamCapture: ma_ptr
    },
    jack: record{
      pClient: ma_ptr,
      ppPortsPlayback: *ma_ptr,
      ppPortsCapture: *ma_ptr,
      pIntermediaryBufferPlayback: *float32,
      pIntermediaryBufferCapture: *float32
    },
    null_device: record{
      deviceThread: culonglong,
      operationEvent: ma_event,
      operationCompletionEvent: ma_event,
      operationSemaphore: ma_semaphore,
      operation: uint32,
      operationResult: ma_result,
      timer: ma_timer,
      priorRunTime: float64,
      currentPeriodFramesRemainingPlayback: uint32,
      currentPeriodFramesRemainingCapture: uint32,
      lastProcessedFramePlayback: uint64,
      lastProcessedFrameCapture: uint64,
      isStarted: ma_atomic_bool32
    }
  }
}
global function ma_context_config_init(): ma_context_config <cimport,nodecl> end
global function ma_context_init(backends: *ma_backend, backendCount: uint32, pConfig: *ma_context_config, pContext: *ma_context): ma_result <cimport,nodecl> end
global function ma_context_uninit(pContext: *ma_context): ma_result <cimport,nodecl> end
global function ma_context_sizeof(): csize <cimport,nodecl> end
global function ma_context_get_log(pContext: *ma_context): *ma_log <cimport,nodecl> end
global function ma_context_enumerate_devices(pContext: *ma_context, callback: ma_enum_devices_callback_proc, pUserData: pointer): ma_result <cimport,nodecl> end
global function ma_context_get_devices(pContext: *ma_context, ppPlaybackDeviceInfos: **ma_device_info, pPlaybackDeviceCount: *uint32, ppCaptureDeviceInfos: **ma_device_info, pCaptureDeviceCount: *uint32): ma_result <cimport,nodecl> end
global function ma_context_get_device_info(pContext: *ma_context, deviceType: ma_device_type, pDeviceID: *ma_device_id, pDeviceInfo: *ma_device_info): ma_result <cimport,nodecl> end
global function ma_context_is_loopback_supported(pContext: *ma_context): ma_bool32 <cimport,nodecl> end
global function ma_device_config_init(deviceType: ma_device_type): ma_device_config <cimport,nodecl> end
global function ma_device_init(pContext: *ma_context, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport,nodecl> end
global function ma_device_init_ex(backends: *ma_backend, backendCount: uint32, pContextConfig: *ma_context_config, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport,nodecl> end
global function ma_device_uninit(pDevice: *ma_device): void <cimport,nodecl> end
global function ma_device_get_context(pDevice: *ma_device): *ma_context <cimport,nodecl> end
global function ma_device_get_log(pDevice: *ma_device): *ma_log <cimport,nodecl> end
global function ma_device_get_info(pDevice: *ma_device, type: ma_device_type, pDeviceInfo: *ma_device_info): ma_result <cimport,nodecl> end
global function ma_device_get_name(pDevice: *ma_device, type: ma_device_type, pName: cstring, nameCap: csize, pLengthNotIncludingNullTerminator: *csize): ma_result <cimport,nodecl> end
global function ma_device_start(pDevice: *ma_device): ma_result <cimport,nodecl> end
global function ma_device_stop(pDevice: *ma_device): ma_result <cimport,nodecl> end
global function ma_device_is_started(pDevice: *ma_device): ma_bool32 <cimport,nodecl> end
global function ma_device_get_state(pDevice: *ma_device): ma_device_state <cimport,nodecl> end
global function ma_device_post_init(pDevice: *ma_device, deviceType: ma_device_type, pPlaybackDescriptor: *ma_device_descriptor, pCaptureDescriptor: *ma_device_descriptor): ma_result <cimport,nodecl> end
global function ma_device_set_master_volume(pDevice: *ma_device, volume: float32): ma_result <cimport,nodecl> end
global function ma_device_get_master_volume(pDevice: *ma_device, pVolume: *float32): ma_result <cimport,nodecl> end
global function ma_device_set_master_volume_db(pDevice: *ma_device, gainDB: float32): ma_result <cimport,nodecl> end
global function ma_device_get_master_volume_db(pDevice: *ma_device, pGainDB: *float32): ma_result <cimport,nodecl> end
global function ma_device_handle_backend_data_callback(pDevice: *ma_device, pOutput: pointer, pInput: pointer, frameCount: uint32): ma_result <cimport,nodecl> end
global function ma_calculate_buffer_size_in_frames_from_descriptor(pDescriptor: *ma_device_descriptor, nativeSampleRate: uint32, performanceProfile: ma_performance_profile): uint32 <cimport,nodecl> end
global function ma_get_backend_name(backend: ma_backend): cstring <cimport,nodecl> end
global function ma_get_backend_from_name(pBackendName: cstring, pBackend: *ma_backend): ma_result <cimport,nodecl> end
global function ma_is_backend_enabled(backend: ma_backend): ma_bool32 <cimport,nodecl> end
global function ma_get_enabled_backends(pBackends: *ma_backend, backendCap: csize, pBackendCount: *csize): ma_result <cimport,nodecl> end
global function ma_is_loopback_supported(backend: ma_backend): ma_bool32 <cimport,nodecl> end
global function ma_calculate_buffer_size_in_milliseconds_from_frames(bufferSizeInFrames: uint32, sampleRate: uint32): uint32 <cimport,nodecl> end
global function ma_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds: uint32, sampleRate: uint32): uint32 <cimport,nodecl> end
global function ma_copy_pcm_frames(dst: pointer, src: pointer, frameCount: uint64, format: ma_format, channels: uint32): void <cimport,nodecl> end
global function ma_silence_pcm_frames(p: pointer, frameCount: uint64, format: ma_format, channels: uint32): void <cimport,nodecl> end
global function ma_offset_pcm_frames_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport,nodecl> end
global function ma_offset_pcm_frames_const_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport,nodecl> end
global function ma_offset_pcm_frames_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport,nodecl> end
global function ma_offset_pcm_frames_const_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport,nodecl> end
global function ma_clip_samples_u8(pDst: *uint8, pSrc: *int16, count: uint64): void <cimport,nodecl> end
global function ma_clip_samples_s16(pDst: *int16, pSrc: *int32, count: uint64): void <cimport,nodecl> end
global function ma_clip_samples_s24(pDst: *uint8, pSrc: *int64, count: uint64): void <cimport,nodecl> end
global function ma_clip_samples_s32(pDst: *int32, pSrc: *int64, count: uint64): void <cimport,nodecl> end
global function ma_clip_samples_f32(pDst: *float32, pSrc: *float32, count: uint64): void <cimport,nodecl> end
global function ma_clip_pcm_frames(pDst: pointer, pSrc: pointer, frameCount: uint64, format: ma_format, channels: uint32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_u8(pSamplesOut: *uint8, pSamplesIn: *uint8, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_s16(pSamplesOut: *int16, pSamplesIn: *int16, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_s24(pSamplesOut: pointer, pSamplesIn: pointer, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_s32(pSamplesOut: *int32, pSamplesIn: *int32, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_f32(pSamplesOut: *float32, pSamplesIn: *float32, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_u8(pSamples: *uint8, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_s16(pSamples: *int16, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_s24(pSamples: pointer, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_s32(pSamples: *int32, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_f32(pSamples: *float32, sampleCount: uint64, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_u8(pFramesOut: *uint8, pFramesIn: *uint8, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s16(pFramesOut: *int16, pFramesIn: *int16, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s24(pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s32(pFramesOut: *int32, pFramesIn: *int32, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_f32(pFramesOut: *float32, pFramesIn: *float32, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames(pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames_u8(pFrames: *uint8, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames_s16(pFrames: *int16, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames_s24(pFrames: pointer, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames_s32(pFrames: *int32, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames_f32(pFrames: *float32, frameCount: uint64, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_apply_volume_factor_pcm_frames(pFrames: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_factor_per_channel_f32(pFramesOut: *float32, pFramesIn: *float32, frameCount: uint64, channels: uint32, pChannelGains: *float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_samples_u8(pDst: *uint8, pSrc: *int16, count: uint64, volume: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_samples_s16(pDst: *int16, pSrc: *int32, count: uint64, volume: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_samples_s24(pDst: *uint8, pSrc: *int64, count: uint64, volume: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_samples_s32(pDst: *int32, pSrc: *int64, count: uint64, volume: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_samples_f32(pDst: *float32, pSrc: *float32, count: uint64, volume: float32): void <cimport,nodecl> end
global function ma_copy_and_apply_volume_and_clip_pcm_frames(pDst: pointer, pSrc: pointer, frameCount: uint64, format: ma_format, channels: uint32, volume: float32): void <cimport,nodecl> end
global function ma_volume_linear_to_db(factor: float32): float32 <cimport,nodecl> end
global function ma_volume_db_to_linear(gain: float32): float32 <cimport,nodecl> end
global function ma_mix_pcm_frames_f32(pDst: *float32, pSrc: *float32, frameCount: uint64, channels: uint32, volume: float32): ma_result <cimport,nodecl> end
global ma_vfs_file: type = @pointer
global ma_open_mode_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_OPEN_MODE_READ = 1,
  MA_OPEN_MODE_WRITE = 2
}
global ma_seek_origin: type <cimport,nodecl,using> = @enum(cint){
  ma_seek_origin_start = 0,
  ma_seek_origin_current = 1,
  ma_seek_origin_end = 2
}
global ma_file_info: type <cimport,nodecl> = @record{
  sizeInBytes: uint64
}
global ma_vfs_callbacks: type <cimport,nodecl> = @record{
  onOpen: function(pointer, cstring, uint32, *ma_vfs_file): ma_result,
  onOpenW: function(pointer, *cwchar_t, uint32, *ma_vfs_file): ma_result,
  onClose: function(pointer, ma_vfs_file): ma_result,
  onRead: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onWrite: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onSeek: function(pointer, ma_vfs_file, int64, ma_seek_origin): ma_result,
  onTell: function(pointer, ma_vfs_file, *int64): ma_result,
  onInfo: function(pointer, ma_vfs_file, *ma_file_info): ma_result
}
global function ma_vfs_open(pVFS: pointer, pFilePath: cstring, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport,nodecl> end
global function ma_vfs_open_w(pVFS: pointer, pFilePath: *cwchar_t, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport,nodecl> end
global function ma_vfs_close(pVFS: pointer, file: ma_vfs_file): ma_result <cimport,nodecl> end
global function ma_vfs_read(pVFS: pointer, file: ma_vfs_file, pDst: pointer, sizeInBytes: csize, pBytesRead: *csize): ma_result <cimport,nodecl> end
global function ma_vfs_write(pVFS: pointer, file: ma_vfs_file, pSrc: pointer, sizeInBytes: csize, pBytesWritten: *csize): ma_result <cimport,nodecl> end
global function ma_vfs_seek(pVFS: pointer, file: ma_vfs_file, offset: int64, origin: ma_seek_origin): ma_result <cimport,nodecl> end
global function ma_vfs_tell(pVFS: pointer, file: ma_vfs_file, pCursor: *int64): ma_result <cimport,nodecl> end
global function ma_vfs_info(pVFS: pointer, file: ma_vfs_file, pInfo: *ma_file_info): ma_result <cimport,nodecl> end
global function ma_vfs_open_and_read_file(pVFS: pointer, pFilePath: cstring, ppData: *pointer, pSize: *csize, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport,nodecl> end
global ma_default_vfs: type <cimport,nodecl> = @record{
  cb: ma_vfs_callbacks,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_default_vfs_init(pVFS: *ma_default_vfs, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport,nodecl> end
global ma_read_proc: type <cimport,nodecl> = @function(pointer, pointer, csize, *csize): ma_result
global ma_seek_proc: type <cimport,nodecl> = @function(pointer, int64, ma_seek_origin): ma_result
global ma_tell_proc: type <cimport,nodecl> = @function(pointer, *int64): ma_result
global ma_encoding_format: type <cimport,nodecl,using> = @enum(cint){
  ma_encoding_format_unknown = 0,
  ma_encoding_format_wav = 1,
  ma_encoding_format_flac = 2,
  ma_encoding_format_mp3 = 3,
  ma_encoding_format_vorbis = 4
}
global ma_decoder: type <cimport,nodecl,forwarddecl> = @record{}
global ma_decoding_backend_config: type <cimport,nodecl> = @record{
  preferredFormat: ma_format,
  seekPointCount: uint32
}
global function ma_decoding_backend_config_init(preferredFormat: ma_format, seekPointCount: uint32): ma_decoding_backend_config <cimport,nodecl> end
global ma_decoding_backend_vtable: type <cimport,nodecl> = @record{
  onInit: function(pointer, ma_read_proc, ma_seek_proc, ma_tell_proc, pointer, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitFile: function(pointer, cstring, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitFileW: function(pointer, *cwchar_t, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onInitMemory: function(pointer, pointer, csize, *ma_decoding_backend_config, *ma_allocation_callbacks, *pointer): ma_result,
  onUninit: function(pointer, pointer, *ma_allocation_callbacks): void
}
global ma_decoder_read_proc: type <cimport,nodecl> = @function(*ma_decoder, pointer, csize, *csize): ma_result
global ma_decoder_seek_proc: type <cimport,nodecl> = @function(*ma_decoder, int64, ma_seek_origin): ma_result
global ma_decoder_tell_proc: type <cimport,nodecl> = @function(*ma_decoder, *int64): ma_result
global ma_decoder_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  pChannelMap: *ma_channel,
  channelMixMode: ma_channel_mix_mode,
  ditherMode: ma_dither_mode,
  resampling: ma_resampler_config,
  allocationCallbacks: ma_allocation_callbacks,
  encodingFormat: ma_encoding_format,
  seekPointCount: uint32,
  ppCustomBackendVTables: **ma_decoding_backend_vtable,
  customBackendCount: uint32,
  pCustomBackendUserData: pointer
}
ma_decoder = @record{
  ds: ma_data_source_base,
  pBackend: pointer,
  pBackendVTable: *ma_decoding_backend_vtable,
  pBackendUserData: pointer,
  onRead: ma_decoder_read_proc,
  onSeek: ma_decoder_seek_proc,
  onTell: ma_decoder_tell_proc,
  pUserData: pointer,
  readPointerInPCMFrames: uint64,
  outputFormat: ma_format,
  outputChannels: uint32,
  outputSampleRate: uint32,
  converter: ma_data_converter,
  pInputCache: pointer,
  inputCacheCap: uint64,
  inputCacheConsumed: uint64,
  inputCacheRemaining: uint64,
  allocationCallbacks: ma_allocation_callbacks,
  data: union{
    vfs: record{
      pVFS: pointer,
      file: ma_vfs_file
    },
    memory: record{
      pData: *uint8,
      dataSize: csize,
      currentReadPos: csize
    }
  }
}
global function ma_decoder_config_init(outputFormat: ma_format, outputChannels: uint32, outputSampleRate: uint32): ma_decoder_config <cimport,nodecl> end
global function ma_decoder_config_init_default(): ma_decoder_config <cimport,nodecl> end
global function ma_decoder_init(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_init_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_init_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_init_vfs_w(pVFS: pointer, pFilePath: *cwchar_t, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_init_file(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_init_file_w(pFilePath: *cwchar_t, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_uninit(pDecoder: *ma_decoder): ma_result <cimport,nodecl> end
global function ma_decoder_read_pcm_frames(pDecoder: *ma_decoder, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_decoder_seek_to_pcm_frame(pDecoder: *ma_decoder, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_decoder_get_data_format(pDecoder: *ma_decoder, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_decoder_get_cursor_in_pcm_frames(pDecoder: *ma_decoder, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_decoder_get_length_in_pcm_frames(pDecoder: *ma_decoder, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_decoder_get_available_frames(pDecoder: *ma_decoder, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global function ma_decode_from_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport,nodecl> end
global function ma_decode_file(pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport,nodecl> end
global function ma_decode_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport,nodecl> end
global ma_encoder: type <cimport,nodecl,forwarddecl> = @record{}
global ma_encoder_write_proc: type <cimport,nodecl> = @function(*ma_encoder, pointer, csize, *csize): ma_result
global ma_encoder_seek_proc: type <cimport,nodecl> = @function(*ma_encoder, int64, ma_seek_origin): ma_result
global ma_encoder_init_proc: type <cimport,nodecl> = @function(*ma_encoder): ma_result
global ma_encoder_uninit_proc: type <cimport,nodecl> = @function(*ma_encoder): void
global ma_encoder_write_pcm_frames_proc: type <cimport,nodecl> = @function(*ma_encoder, pointer, uint64, *uint64): ma_result
global ma_encoder_config: type <cimport,nodecl> = @record{
  encodingFormat: ma_encoding_format,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_encoder_config_init(encodingFormat: ma_encoding_format, format: ma_format, channels: uint32, sampleRate: uint32): ma_encoder_config <cimport,nodecl> end
ma_encoder = @record{
  config: ma_encoder_config,
  onWrite: ma_encoder_write_proc,
  onSeek: ma_encoder_seek_proc,
  onInit: ma_encoder_init_proc,
  onUninit: ma_encoder_uninit_proc,
  onWritePCMFrames: ma_encoder_write_pcm_frames_proc,
  pUserData: pointer,
  pInternalEncoder: pointer,
  data: union{
    vfs: record{
      pVFS: pointer,
      file: ma_vfs_file
    }
  }
}
global function ma_encoder_init(onWrite: ma_encoder_write_proc, onSeek: ma_encoder_seek_proc, pUserData: pointer, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport,nodecl> end
global function ma_encoder_init_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport,nodecl> end
global function ma_encoder_init_vfs_w(pVFS: pointer, pFilePath: *cwchar_t, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport,nodecl> end
global function ma_encoder_init_file(pFilePath: cstring, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport,nodecl> end
global function ma_encoder_init_file_w(pFilePath: *cwchar_t, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport,nodecl> end
global function ma_encoder_uninit(pEncoder: *ma_encoder): void <cimport,nodecl> end
global function ma_encoder_write_pcm_frames(pEncoder: *ma_encoder, pFramesIn: pointer, frameCount: uint64, pFramesWritten: *uint64): ma_result <cimport,nodecl> end
global ma_waveform_type: type <cimport,nodecl,using> = @enum(cint){
  ma_waveform_type_sine = 0,
  ma_waveform_type_square = 1,
  ma_waveform_type_triangle = 2,
  ma_waveform_type_sawtooth = 3
}
global ma_waveform_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  type: ma_waveform_type,
  amplitude: float64,
  frequency: float64
}
global function ma_waveform_config_init(format: ma_format, channels: uint32, sampleRate: uint32, type: ma_waveform_type, amplitude: float64, frequency: float64): ma_waveform_config <cimport,nodecl> end
global ma_waveform: type <cimport,nodecl,aligned(8)> = @record{
  ds: ma_data_source_base,
  config: ma_waveform_config,
  advance: float64,
  time: float64
}
global function ma_waveform_init(pConfig: *ma_waveform_config, pWaveform: *ma_waveform): ma_result <cimport,nodecl> end
global function ma_waveform_uninit(pWaveform: *ma_waveform): void <cimport,nodecl> end
global function ma_waveform_read_pcm_frames(pWaveform: *ma_waveform, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_waveform_seek_to_pcm_frame(pWaveform: *ma_waveform, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_waveform_set_amplitude(pWaveform: *ma_waveform, amplitude: float64): ma_result <cimport,nodecl> end
global function ma_waveform_set_frequency(pWaveform: *ma_waveform, frequency: float64): ma_result <cimport,nodecl> end
global function ma_waveform_set_type(pWaveform: *ma_waveform, type: ma_waveform_type): ma_result <cimport,nodecl> end
global function ma_waveform_set_sample_rate(pWaveform: *ma_waveform, sampleRate: uint32): ma_result <cimport,nodecl> end
global ma_noise_type: type <cimport,nodecl,using> = @enum(cint){
  ma_noise_type_white = 0,
  ma_noise_type_pink = 1,
  ma_noise_type_brownian = 2
}
global ma_noise_config: type <cimport,nodecl> = @record{
  format: ma_format,
  channels: uint32,
  type: ma_noise_type,
  seed: int32,
  amplitude: float64,
  duplicateChannels: ma_bool32
}
global function ma_noise_config_init(format: ma_format, channels: uint32, type: ma_noise_type, seed: int32, amplitude: float64): ma_noise_config <cimport,nodecl> end
global ma_noise: type <cimport,nodecl> = @record{
  ds: ma_data_source_vtable,
  config: ma_noise_config,
  lcg: ma_lcg,
  state: union{
    pink: record{
      bin: **float64,
      accumulation: *float64,
      counter: *uint32
    },
    brownian: record{
      accumulation: *float64
    }
  },
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_noise_get_heap_size(pConfig: *ma_noise_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_noise_init_preallocated(pConfig: *ma_noise_config, pHeap: pointer, pNoise: *ma_noise): ma_result <cimport,nodecl> end
global function ma_noise_init(pConfig: *ma_noise_config, pAllocationCallbacks: *ma_allocation_callbacks, pNoise: *ma_noise): ma_result <cimport,nodecl> end
global function ma_noise_uninit(pNoise: *ma_noise, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_noise_read_pcm_frames(pNoise: *ma_noise, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_noise_set_amplitude(pNoise: *ma_noise, amplitude: float64): ma_result <cimport,nodecl> end
global function ma_noise_set_seed(pNoise: *ma_noise, seed: int32): ma_result <cimport,nodecl> end
global function ma_noise_set_type(pNoise: *ma_noise, type: ma_noise_type): ma_result <cimport,nodecl> end
global ma_resource_manager: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resource_manager_data_buffer_node: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resource_manager_data_buffer: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resource_manager_data_stream: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resource_manager_data_source: type <cimport,nodecl,forwarddecl> = @record{}
global ma_resource_manager_data_source_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_STREAM = 1,
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_DECODE = 2,
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_ASYNC = 4,
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_WAIT_INIT = 8,
  MA_RESOURCE_MANAGER_DATA_SOURCE_FLAG_UNKNOWN_LENGTH = 16
}
global ma_resource_manager_pipeline_stage_notification: type <cimport,nodecl> = @record{
  pNotification: pointer,
  pFence: *ma_fence
}
global ma_resource_manager_pipeline_notifications: type <cimport,nodecl> = @record{
  init: ma_resource_manager_pipeline_stage_notification,
  done: ma_resource_manager_pipeline_stage_notification
}
global function ma_resource_manager_pipeline_notifications_init(): ma_resource_manager_pipeline_notifications <cimport,nodecl> end
global ma_resource_manager_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_RESOURCE_MANAGER_FLAG_NON_BLOCKING = 1,
  MA_RESOURCE_MANAGER_FLAG_NO_THREADING = 2
}
global ma_resource_manager_data_source_config: type <cimport,nodecl> = @record{
  pFilePath: cstring,
  pFilePathW: *cwchar_t,
  pNotifications: *ma_resource_manager_pipeline_notifications,
  initialSeekPointInPCMFrames: uint64,
  rangeBegInPCMFrames: uint64,
  rangeEndInPCMFrames: uint64,
  loopPointBegInPCMFrames: uint64,
  loopPointEndInPCMFrames: uint64,
  isLooping: ma_bool32,
  flags: uint32
}
global function ma_resource_manager_data_source_config_init(): ma_resource_manager_data_source_config <cimport,nodecl> end
global ma_resource_manager_data_supply_type: type <cimport,nodecl,using> = @enum(cint){
  ma_resource_manager_data_supply_type_unknown = 0,
  ma_resource_manager_data_supply_type_encoded = 1,
  ma_resource_manager_data_supply_type_decoded = 2,
  ma_resource_manager_data_supply_type_decoded_paged = 3
}
global ma_resource_manager_data_supply: type <cimport,nodecl,aligned(8)> = @record{
  type: ma_resource_manager_data_supply_type,
  backend: union{
    encoded: record{
      pData: pointer,
      sizeInBytes: csize
    },
    decoded: record{
      pData: pointer,
      totalFrameCount: uint64,
      decodedFrameCount: uint64,
      format: ma_format,
      channels: uint32,
      sampleRate: uint32
    },
    decodedPaged: record{
      data: ma_paged_audio_buffer_data,
      decodedFrameCount: uint64,
      sampleRate: uint32
    }
  }
}
ma_resource_manager_data_buffer_node = @record{
  hashedName32: uint32,
  refCount: uint32,
  result: ma_result,
  executionCounter: uint32,
  executionPointer: uint32,
  isDataOwnedByResourceManager: ma_bool32,
  data: ma_resource_manager_data_supply,
  pParent: *ma_resource_manager_data_buffer_node,
  pChildLo: *ma_resource_manager_data_buffer_node,
  pChildHi: *ma_resource_manager_data_buffer_node
}
ma_resource_manager_data_buffer = @record{
  ds: ma_data_source_base,
  pResourceManager: *ma_resource_manager,
  pNode: *ma_resource_manager_data_buffer_node,
  flags: uint32,
  executionCounter: uint32,
  executionPointer: uint32,
  seekTargetInPCMFrames: uint64,
  seekToCursorOnNextRead: ma_bool32,
  result: ma_result,
  isLooping: ma_bool32,
  isConnectorInitialized: ma_atomic_bool32,
  connector: union{
    decoder: ma_decoder,
    buffer: ma_audio_buffer,
    pagedBuffer: ma_paged_audio_buffer
  }
}
ma_resource_manager_data_stream = @record{
  ds: ma_data_source_base,
  pResourceManager: *ma_resource_manager,
  flags: uint32,
  decoder: ma_decoder,
  isDecoderInitialized: ma_bool32,
  totalLengthInPCMFrames: uint64,
  relativeCursor: uint32,
  absoluteCursor: uint64,
  currentPageIndex: uint32,
  executionCounter: uint32,
  executionPointer: uint32,
  isLooping: ma_bool32,
  pPageData: pointer,
  pageFrameCount: [2]uint32,
  result: ma_result,
  isDecoderAtEnd: ma_bool32,
  isPageValid: [2]ma_bool32,
  seekCounter: ma_bool32
}
ma_resource_manager_data_source = @record{
  backend: union{
    buffer: ma_resource_manager_data_buffer,
    stream: ma_resource_manager_data_stream
  },
  flags: uint32,
  executionCounter: uint32,
  executionPointer: uint32
}
global ma_resource_manager_config: type <cimport,nodecl> = @record{
  allocationCallbacks: ma_allocation_callbacks,
  pLog: *ma_log,
  decodedFormat: ma_format,
  decodedChannels: uint32,
  decodedSampleRate: uint32,
  jobThreadCount: uint32,
  jobThreadStackSize: csize,
  jobQueueCapacity: uint32,
  flags: uint32,
  pVFS: pointer,
  ppCustomDecodingBackendVTables: **ma_decoding_backend_vtable,
  customDecodingBackendCount: uint32,
  pCustomDecodingBackendUserData: pointer
}
global function ma_resource_manager_config_init(): ma_resource_manager_config <cimport,nodecl> end
ma_resource_manager = @record{
  config: ma_resource_manager_config,
  pRootDataBufferNode: *ma_resource_manager_data_buffer_node,
  dataBufferBSTLock: ma_mutex,
  jobThreads: [64]culonglong,
  jobQueue: ma_job_queue,
  defaultVFS: ma_default_vfs,
  log: ma_log
}
global function ma_resource_manager_init(pConfig: *ma_resource_manager_config, pResourceManager: *ma_resource_manager): ma_result <cimport,nodecl> end
global function ma_resource_manager_uninit(pResourceManager: *ma_resource_manager): void <cimport,nodecl> end
global function ma_resource_manager_get_log(pResourceManager: *ma_resource_manager): *ma_log <cimport,nodecl> end
global function ma_resource_manager_register_file(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32): ma_result <cimport,nodecl> end
global function ma_resource_manager_register_file_w(pResourceManager: *ma_resource_manager, pFilePath: *cwchar_t, flags: uint32): ma_result <cimport,nodecl> end
global function ma_resource_manager_register_decoded_data(pResourceManager: *ma_resource_manager, pName: cstring, pData: pointer, frameCount: uint64, format: ma_format, channels: uint32, sampleRate: uint32): ma_result <cimport,nodecl> end
global function ma_resource_manager_register_decoded_data_w(pResourceManager: *ma_resource_manager, pName: *cwchar_t, pData: pointer, frameCount: uint64, format: ma_format, channels: uint32, sampleRate: uint32): ma_result <cimport,nodecl> end
global function ma_resource_manager_register_encoded_data(pResourceManager: *ma_resource_manager, pName: cstring, pData: pointer, sizeInBytes: csize): ma_result <cimport,nodecl> end
global function ma_resource_manager_register_encoded_data_w(pResourceManager: *ma_resource_manager, pName: *cwchar_t, pData: pointer, sizeInBytes: csize): ma_result <cimport,nodecl> end
global function ma_resource_manager_unregister_file(pResourceManager: *ma_resource_manager, pFilePath: cstring): ma_result <cimport,nodecl> end
global function ma_resource_manager_unregister_file_w(pResourceManager: *ma_resource_manager, pFilePath: *cwchar_t): ma_result <cimport,nodecl> end
global function ma_resource_manager_unregister_data(pResourceManager: *ma_resource_manager, pName: cstring): ma_result <cimport,nodecl> end
global function ma_resource_manager_unregister_data_w(pResourceManager: *ma_resource_manager, pName: *cwchar_t): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_init_ex(pResourceManager: *ma_resource_manager, pConfig: *ma_resource_manager_data_source_config, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_init(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_init_w(pResourceManager: *ma_resource_manager, pFilePath: *cwchar_t, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_init_copy(pResourceManager: *ma_resource_manager, pExistingDataBuffer: *ma_resource_manager_data_buffer, pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_uninit(pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_read_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_seek_to_pcm_frame(pDataBuffer: *ma_resource_manager_data_buffer, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_get_data_format(pDataBuffer: *ma_resource_manager_data_buffer, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_get_cursor_in_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_get_length_in_pcm_frames(pDataBuffer: *ma_resource_manager_data_buffer, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_result(pDataBuffer: *ma_resource_manager_data_buffer): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_set_looping(pDataBuffer: *ma_resource_manager_data_buffer, isLooping: ma_bool32): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_buffer_is_looping(pDataBuffer: *ma_resource_manager_data_buffer): ma_bool32 <cimport,nodecl> end
global function ma_resource_manager_data_buffer_get_available_frames(pDataBuffer: *ma_resource_manager_data_buffer, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_init_ex(pResourceManager: *ma_resource_manager, pConfig: *ma_resource_manager_data_source_config, pDataStream: *ma_resource_manager_data_stream): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_init(pResourceManager: *ma_resource_manager, pFilePath: cstring, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataStream: *ma_resource_manager_data_stream): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_init_w(pResourceManager: *ma_resource_manager, pFilePath: *cwchar_t, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataStream: *ma_resource_manager_data_stream): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_uninit(pDataStream: *ma_resource_manager_data_stream): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_read_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_seek_to_pcm_frame(pDataStream: *ma_resource_manager_data_stream, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_get_data_format(pDataStream: *ma_resource_manager_data_stream, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_get_cursor_in_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_get_length_in_pcm_frames(pDataStream: *ma_resource_manager_data_stream, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_result(pDataStream: *ma_resource_manager_data_stream): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_set_looping(pDataStream: *ma_resource_manager_data_stream, isLooping: ma_bool32): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_stream_is_looping(pDataStream: *ma_resource_manager_data_stream): ma_bool32 <cimport,nodecl> end
global function ma_resource_manager_data_stream_get_available_frames(pDataStream: *ma_resource_manager_data_stream, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_init_ex(pResourceManager: *ma_resource_manager, pConfig: *ma_resource_manager_data_source_config, pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_init(pResourceManager: *ma_resource_manager, pName: cstring, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_init_w(pResourceManager: *ma_resource_manager, pName: *cwchar_t, flags: uint32, pNotifications: *ma_resource_manager_pipeline_notifications, pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_init_copy(pResourceManager: *ma_resource_manager, pExistingDataSource: *ma_resource_manager_data_source, pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_uninit(pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_read_pcm_frames(pDataSource: *ma_resource_manager_data_source, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_seek_to_pcm_frame(pDataSource: *ma_resource_manager_data_source, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_get_data_format(pDataSource: *ma_resource_manager_data_source, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_get_cursor_in_pcm_frames(pDataSource: *ma_resource_manager_data_source, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_get_length_in_pcm_frames(pDataSource: *ma_resource_manager_data_source, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_result(pDataSource: *ma_resource_manager_data_source): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_set_looping(pDataSource: *ma_resource_manager_data_source, isLooping: ma_bool32): ma_result <cimport,nodecl> end
global function ma_resource_manager_data_source_is_looping(pDataSource: *ma_resource_manager_data_source): ma_bool32 <cimport,nodecl> end
global function ma_resource_manager_data_source_get_available_frames(pDataSource: *ma_resource_manager_data_source, pAvailableFrames: *uint64): ma_result <cimport,nodecl> end
global function ma_resource_manager_post_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport,nodecl> end
global function ma_resource_manager_post_job_quit(pResourceManager: *ma_resource_manager): ma_result <cimport,nodecl> end
global function ma_resource_manager_next_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport,nodecl> end
global function ma_resource_manager_process_job(pResourceManager: *ma_resource_manager, pJob: *ma_job): ma_result <cimport,nodecl> end
global function ma_resource_manager_process_next_job(pResourceManager: *ma_resource_manager): ma_result <cimport,nodecl> end
global ma_node_graph: type <cimport,nodecl,forwarddecl> = @record{}
global ma_node_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_NODE_FLAG_PASSTHROUGH = 1,
  MA_NODE_FLAG_CONTINUOUS_PROCESSING = 2,
  MA_NODE_FLAG_ALLOW_NULL_INPUT = 4,
  MA_NODE_FLAG_DIFFERENT_PROCESSING_RATES = 8,
  MA_NODE_FLAG_SILENT_OUTPUT = 16
}
global ma_node_state: type <cimport,nodecl,using> = @enum(cint){
  ma_node_state_started = 0,
  ma_node_state_stopped = 1
}
global ma_node_vtable: type <cimport,nodecl> = @record{
  onProcess: function(pointer, **float32, *uint32, **float32, *uint32): void,
  onGetRequiredInputFrameCount: function(pointer, uint32, *uint32): ma_result,
  inputBusCount: uint8,
  outputBusCount: uint8,
  flags: uint32
}
global ma_node_config: type <cimport,nodecl> = @record{
  vtable: *ma_node_vtable,
  initialState: ma_node_state,
  inputBusCount: uint32,
  outputBusCount: uint32,
  pInputChannels: *uint32,
  pOutputChannels: *uint32
}
global function ma_node_config_init(): ma_node_config <cimport,nodecl> end
global ma_node_output_bus: type <cimport,nodecl,forwarddecl> = @record{}
ma_node_output_bus = @record{
  pNode: pointer,
  outputBusIndex: uint8,
  channels: uint8,
  inputNodeInputBusIndex: uint8,
  flags: uint32,
  refCount: uint32,
  isAttached: ma_bool32,
  lock: cuint,
  volume: float32,
  pNext: *ma_node_output_bus,
  pPrev: *ma_node_output_bus,
  pInputNode: pointer
}
global ma_node_input_bus: type <cimport,nodecl,forwarddecl> = @record{}
ma_node_input_bus = @record{
  head: ma_node_output_bus,
  nextCounter: uint32,
  lock: cuint,
  channels: uint8
}
global ma_node_base: type <cimport,nodecl,forwarddecl> = @record{}
ma_node_base = @record{
  pNodeGraph: *ma_node_graph,
  vtable: *ma_node_vtable,
  pCachedData: *float32,
  cachedDataCapInFramesPerBus: uint16,
  cachedFrameCountOut: uint16,
  cachedFrameCountIn: uint16,
  consumedFrameCountIn: uint16,
  state: ma_node_state,
  stateTimes: [2]uint64,
  localTime: uint64,
  inputBusCount: uint32,
  outputBusCount: uint32,
  pInputBuses: *ma_node_input_bus,
  pOutputBuses: *ma_node_output_bus,
  _inputBuses: [2]ma_node_input_bus,
  _outputBuses: [2]ma_node_output_bus,
  _pHeap: pointer,
  _ownsHeap: ma_bool32
}
global function ma_node_get_heap_size(pNodeGraph: *ma_node_graph, pConfig: *ma_node_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_node_init_preallocated(pNodeGraph: *ma_node_graph, pConfig: *ma_node_config, pHeap: pointer, pNode: pointer): ma_result <cimport,nodecl> end
global function ma_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: pointer): ma_result <cimport,nodecl> end
global function ma_node_uninit(pNode: pointer, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_node_get_node_graph(pNode: pointer): *ma_node_graph <cimport,nodecl> end
global function ma_node_get_input_bus_count(pNode: pointer): uint32 <cimport,nodecl> end
global function ma_node_get_output_bus_count(pNode: pointer): uint32 <cimport,nodecl> end
global function ma_node_get_input_channels(pNode: pointer, inputBusIndex: uint32): uint32 <cimport,nodecl> end
global function ma_node_get_output_channels(pNode: pointer, outputBusIndex: uint32): uint32 <cimport,nodecl> end
global function ma_node_attach_output_bus(pNode: pointer, outputBusIndex: uint32, pOtherNode: pointer, otherNodeInputBusIndex: uint32): ma_result <cimport,nodecl> end
global function ma_node_detach_output_bus(pNode: pointer, outputBusIndex: uint32): ma_result <cimport,nodecl> end
global function ma_node_detach_all_output_buses(pNode: pointer): ma_result <cimport,nodecl> end
global function ma_node_set_output_bus_volume(pNode: pointer, outputBusIndex: uint32, volume: float32): ma_result <cimport,nodecl> end
global function ma_node_get_output_bus_volume(pNode: pointer, outputBusIndex: uint32): float32 <cimport,nodecl> end
global function ma_node_set_state(pNode: pointer, state: ma_node_state): ma_result <cimport,nodecl> end
global function ma_node_get_state(pNode: pointer): ma_node_state <cimport,nodecl> end
global function ma_node_set_state_time(pNode: pointer, state: ma_node_state, globalTime: uint64): ma_result <cimport,nodecl> end
global function ma_node_get_state_time(pNode: pointer, state: ma_node_state): uint64 <cimport,nodecl> end
global function ma_node_get_state_by_time(pNode: pointer, globalTime: uint64): ma_node_state <cimport,nodecl> end
global function ma_node_get_state_by_time_range(pNode: pointer, globalTimeBeg: uint64, globalTimeEnd: uint64): ma_node_state <cimport,nodecl> end
global function ma_node_get_time(pNode: pointer): uint64 <cimport,nodecl> end
global function ma_node_set_time(pNode: pointer, localTime: uint64): ma_result <cimport,nodecl> end
global ma_node_graph_config: type <cimport,nodecl> = @record{
  channels: uint32,
  nodeCacheCapInFrames: uint16
}
global function ma_node_graph_config_init(channels: uint32): ma_node_graph_config <cimport,nodecl> end
ma_node_graph = @record{
  base: ma_node_base,
  endpoint: ma_node_base,
  nodeCacheCapInFrames: uint16,
  isReading: ma_bool32
}
global function ma_node_graph_init(pConfig: *ma_node_graph_config, pAllocationCallbacks: *ma_allocation_callbacks, pNodeGraph: *ma_node_graph): ma_result <cimport,nodecl> end
global function ma_node_graph_uninit(pNodeGraph: *ma_node_graph, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_node_graph_get_endpoint(pNodeGraph: *ma_node_graph): pointer <cimport,nodecl> end
global function ma_node_graph_read_pcm_frames(pNodeGraph: *ma_node_graph, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_node_graph_get_channels(pNodeGraph: *ma_node_graph): uint32 <cimport,nodecl> end
global function ma_node_graph_get_time(pNodeGraph: *ma_node_graph): uint64 <cimport,nodecl> end
global function ma_node_graph_set_time(pNodeGraph: *ma_node_graph, globalTime: uint64): ma_result <cimport,nodecl> end
global ma_data_source_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  pDataSource: pointer
}
global function ma_data_source_node_config_init(pDataSource: pointer): ma_data_source_node_config <cimport,nodecl> end
global ma_data_source_node: type <cimport,nodecl,aligned(8)> = @record{
  base: ma_node_base,
  pDataSource: pointer
}
global function ma_data_source_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_data_source_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pDataSourceNode: *ma_data_source_node): ma_result <cimport,nodecl> end
global function ma_data_source_node_uninit(pDataSourceNode: *ma_data_source_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_data_source_node_set_looping(pDataSourceNode: *ma_data_source_node, isLooping: ma_bool32): ma_result <cimport,nodecl> end
global function ma_data_source_node_is_looping(pDataSourceNode: *ma_data_source_node): ma_bool32 <cimport,nodecl> end
global ma_splitter_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  channels: uint32,
  outputBusCount: uint32
}
global function ma_splitter_node_config_init(channels: uint32): ma_splitter_node_config <cimport,nodecl> end
global ma_splitter_node: type <cimport,nodecl,aligned(8)> = @record{
  base: ma_node_base
}
global function ma_splitter_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_splitter_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pSplitterNode: *ma_splitter_node): ma_result <cimport,nodecl> end
global function ma_splitter_node_uninit(pSplitterNode: *ma_splitter_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_biquad_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  biquad: ma_biquad_config
}
global function ma_biquad_node_config_init(channels: uint32, b0: float32, b1: float32, b2: float32, a0: float32, a1: float32, a2: float32): ma_biquad_node_config <cimport,nodecl> end
global ma_biquad_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  biquad: ma_biquad
}
global function ma_biquad_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_biquad_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_biquad_node): ma_result <cimport,nodecl> end
global function ma_biquad_node_reinit(pConfig: *ma_biquad_config, pNode: *ma_biquad_node): ma_result <cimport,nodecl> end
global function ma_biquad_node_uninit(pNode: *ma_biquad_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_lpf_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  lpf: ma_lpf_config
}
global function ma_lpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_lpf_node_config <cimport,nodecl> end
global ma_lpf_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  lpf: ma_lpf
}
global function ma_lpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_lpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_lpf_node): ma_result <cimport,nodecl> end
global function ma_lpf_node_reinit(pConfig: *ma_lpf_config, pNode: *ma_lpf_node): ma_result <cimport,nodecl> end
global function ma_lpf_node_uninit(pNode: *ma_lpf_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_hpf_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  hpf: ma_hpf_config
}
global function ma_hpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_hpf_node_config <cimport,nodecl> end
global ma_hpf_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  hpf: ma_hpf
}
global function ma_hpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_hpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_hpf_node): ma_result <cimport,nodecl> end
global function ma_hpf_node_reinit(pConfig: *ma_hpf_config, pNode: *ma_hpf_node): ma_result <cimport,nodecl> end
global function ma_hpf_node_uninit(pNode: *ma_hpf_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_bpf_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  bpf: ma_bpf_config
}
global function ma_bpf_node_config_init(channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_bpf_node_config <cimport,nodecl> end
global ma_bpf_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  bpf: ma_bpf
}
global function ma_bpf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_bpf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_bpf_node): ma_result <cimport,nodecl> end
global function ma_bpf_node_reinit(pConfig: *ma_bpf_config, pNode: *ma_bpf_node): ma_result <cimport,nodecl> end
global function ma_bpf_node_uninit(pNode: *ma_bpf_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_notch_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  notch: ma_notch_config
}
global function ma_notch_node_config_init(channels: uint32, sampleRate: uint32, q: float64, frequency: float64): ma_notch_node_config <cimport,nodecl> end
global ma_notch_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  notch: ma_notch2
}
global function ma_notch_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_notch_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_notch_node): ma_result <cimport,nodecl> end
global function ma_notch_node_reinit(pConfig: *ma_notch_config, pNode: *ma_notch_node): ma_result <cimport,nodecl> end
global function ma_notch_node_uninit(pNode: *ma_notch_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_peak_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  peak: ma_peak_config
}
global function ma_peak_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_peak_node_config <cimport,nodecl> end
global ma_peak_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  peak: ma_peak2
}
global function ma_peak_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_peak_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_peak_node): ma_result <cimport,nodecl> end
global function ma_peak_node_reinit(pConfig: *ma_peak_config, pNode: *ma_peak_node): ma_result <cimport,nodecl> end
global function ma_peak_node_uninit(pNode: *ma_peak_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_loshelf_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  loshelf: ma_loshelf_config
}
global function ma_loshelf_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_loshelf_node_config <cimport,nodecl> end
global ma_loshelf_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  loshelf: ma_loshelf2
}
global function ma_loshelf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_loshelf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_loshelf_node): ma_result <cimport,nodecl> end
global function ma_loshelf_node_reinit(pConfig: *ma_loshelf_config, pNode: *ma_loshelf_node): ma_result <cimport,nodecl> end
global function ma_loshelf_node_uninit(pNode: *ma_loshelf_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_hishelf_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  hishelf: ma_hishelf_config
}
global function ma_hishelf_node_config_init(channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_hishelf_node_config <cimport,nodecl> end
global ma_hishelf_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  hishelf: ma_hishelf2
}
global function ma_hishelf_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_hishelf_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pNode: *ma_hishelf_node): ma_result <cimport,nodecl> end
global function ma_hishelf_node_reinit(pConfig: *ma_hishelf_config, pNode: *ma_hishelf_node): ma_result <cimport,nodecl> end
global function ma_hishelf_node_uninit(pNode: *ma_hishelf_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_delay_node_config: type <cimport,nodecl> = @record{
  nodeConfig: ma_node_config,
  delay: ma_delay_config
}
global function ma_delay_node_config_init(channels: uint32, sampleRate: uint32, delayInFrames: uint32, decay: float32): ma_delay_node_config <cimport,nodecl> end
global ma_delay_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  delay: ma_delay
}
global function ma_delay_node_init(pNodeGraph: *ma_node_graph, pConfig: *ma_delay_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pDelayNode: *ma_delay_node): ma_result <cimport,nodecl> end
global function ma_delay_node_uninit(pDelayNode: *ma_delay_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global function ma_delay_node_set_wet(pDelayNode: *ma_delay_node, value: float32): void <cimport,nodecl> end
global function ma_delay_node_get_wet(pDelayNode: *ma_delay_node): float32 <cimport,nodecl> end
global function ma_delay_node_set_dry(pDelayNode: *ma_delay_node, value: float32): void <cimport,nodecl> end
global function ma_delay_node_get_dry(pDelayNode: *ma_delay_node): float32 <cimport,nodecl> end
global function ma_delay_node_set_decay(pDelayNode: *ma_delay_node, value: float32): void <cimport,nodecl> end
global function ma_delay_node_get_decay(pDelayNode: *ma_delay_node): float32 <cimport,nodecl> end
global ma_engine: type <cimport,nodecl,forwarddecl> = @record{}
global ma_sound: type <cimport,nodecl,forwarddecl> = @record{}
global ma_sound_flags: type <cimport,nodecl,using> = @enum(cint){
  MA_SOUND_FLAG_STREAM = 1,
  MA_SOUND_FLAG_DECODE = 2,
  MA_SOUND_FLAG_ASYNC = 4,
  MA_SOUND_FLAG_WAIT_INIT = 8,
  MA_SOUND_FLAG_UNKNOWN_LENGTH = 16,
  MA_SOUND_FLAG_NO_DEFAULT_ATTACHMENT = 4096,
  MA_SOUND_FLAG_NO_PITCH = 8192,
  MA_SOUND_FLAG_NO_SPATIALIZATION = 16384
}
global ma_engine_node_type: type <cimport,nodecl,using> = @enum(cint){
  ma_engine_node_type_sound = 0,
  ma_engine_node_type_group = 1
}
global ma_engine_node_config: type <cimport,nodecl> = @record{
  pEngine: *ma_engine,
  type: ma_engine_node_type,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRate: uint32,
  monoExpansionMode: ma_mono_expansion_mode,
  isPitchDisabled: ma_bool8,
  isSpatializationDisabled: ma_bool8,
  pinnedListenerIndex: uint8
}
global function ma_engine_node_config_init(pEngine: *ma_engine, type: ma_engine_node_type, flags: uint32): ma_engine_node_config <cimport,nodecl> end
global ma_engine_node: type <cimport,nodecl,aligned(8)> = @record{
  baseNode: ma_node_base,
  pEngine: *ma_engine,
  sampleRate: uint32,
  monoExpansionMode: ma_mono_expansion_mode,
  fader: ma_fader,
  resampler: ma_linear_resampler,
  spatializer: ma_spatializer,
  panner: ma_panner,
  pitch: float32,
  oldPitch: float32,
  oldDopplerPitch: float32,
  isPitchDisabled: ma_bool32,
  isSpatializationDisabled: ma_bool32,
  pinnedListenerIndex: uint32,
  _ownsHeap: ma_bool8,
  _pHeap: pointer
}
global function ma_engine_node_get_heap_size(pConfig: *ma_engine_node_config, pHeapSizeInBytes: *csize): ma_result <cimport,nodecl> end
global function ma_engine_node_init_preallocated(pConfig: *ma_engine_node_config, pHeap: pointer, pEngineNode: *ma_engine_node): ma_result <cimport,nodecl> end
global function ma_engine_node_init(pConfig: *ma_engine_node_config, pAllocationCallbacks: *ma_allocation_callbacks, pEngineNode: *ma_engine_node): ma_result <cimport,nodecl> end
global function ma_engine_node_uninit(pEngineNode: *ma_engine_node, pAllocationCallbacks: *ma_allocation_callbacks): void <cimport,nodecl> end
global ma_sound_end_proc: type <cimport,nodecl> = @function(pointer, *ma_sound): void
global ma_sound_config: type <cimport,nodecl> = @record{
  pFilePath: cstring,
  pFilePathW: *cwchar_t,
  pDataSource: pointer,
  pInitialAttachment: pointer,
  initialAttachmentInputBusIndex: uint32,
  channelsIn: uint32,
  channelsOut: uint32,
  monoExpansionMode: ma_mono_expansion_mode,
  flags: uint32,
  initialSeekPointInPCMFrames: uint64,
  rangeBegInPCMFrames: uint64,
  rangeEndInPCMFrames: uint64,
  loopPointBegInPCMFrames: uint64,
  loopPointEndInPCMFrames: uint64,
  isLooping: ma_bool32,
  endCallback: ma_sound_end_proc,
  pEndCallbackUserData: pointer,
  initNotifications: ma_resource_manager_pipeline_notifications,
  pDoneFence: *ma_fence
}
global function ma_sound_config_init(): ma_sound_config <cimport,nodecl> end
global function ma_sound_config_init_2(pEngine: *ma_engine): ma_sound_config <cimport,nodecl> end
ma_sound = @record{
  engineNode: ma_engine_node,
  pDataSource: pointer,
  seekTarget: uint64,
  atEnd: ma_bool32,
  endCallback: ma_sound_end_proc,
  pEndCallbackUserData: pointer,
  ownsDataSource: ma_bool8,
  pResourceManagerDataSource: *ma_resource_manager_data_source
}
global ma_sound_inlined: type <cimport,nodecl,forwarddecl> = @record{}
ma_sound_inlined = @record{
  sound: ma_sound,
  pNext: *ma_sound_inlined,
  pPrev: *ma_sound_inlined
}
global ma_sound_group_config: type = @ma_sound_config
global ma_sound_group: type = @ma_sound
global function ma_sound_group_config_init(): ma_sound_group_config <cimport,nodecl> end
global function ma_sound_group_config_init_2(pEngine: *ma_engine): ma_sound_group_config <cimport,nodecl> end
global ma_engine_config: type <cimport,nodecl> = @record{
  pResourceManager: *ma_resource_manager,
  pContext: *ma_context,
  pDevice: *ma_device,
  pPlaybackDeviceID: *ma_device_id,
  notificationCallback: ma_device_notification_proc,
  pLog: *ma_log,
  listenerCount: uint32,
  channels: uint32,
  sampleRate: uint32,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  gainSmoothTimeInFrames: uint32,
  gainSmoothTimeInMilliseconds: uint32,
  allocationCallbacks: ma_allocation_callbacks,
  noAutoStart: ma_bool32,
  noDevice: ma_bool32,
  monoExpansionMode: ma_mono_expansion_mode,
  pResourceManagerVFS: pointer
}
global function ma_engine_config_init(): ma_engine_config <cimport,nodecl> end
ma_engine = @record{
  nodeGraph: ma_node_graph,
  pResourceManager: *ma_resource_manager,
  pDevice: *ma_device,
  pLog: *ma_log,
  sampleRate: uint32,
  listenerCount: uint32,
  listeners: [4]ma_spatializer_listener,
  allocationCallbacks: ma_allocation_callbacks,
  ownsResourceManager: ma_bool8,
  ownsDevice: ma_bool8,
  inlinedSoundLock: cuint,
  pInlinedSoundHead: *ma_sound_inlined,
  inlinedSoundCount: uint32,
  gainSmoothTimeInFrames: uint32,
  monoExpansionMode: ma_mono_expansion_mode
}
global function ma_engine_init(pConfig: *ma_engine_config, pEngine: *ma_engine): ma_result <cimport,nodecl> end
global function ma_engine_uninit(pEngine: *ma_engine): void <cimport,nodecl> end
global function ma_engine_read_pcm_frames(pEngine: *ma_engine, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64): ma_result <cimport,nodecl> end
global function ma_engine_get_node_graph(pEngine: *ma_engine): *ma_node_graph <cimport,nodecl> end
global function ma_engine_get_resource_manager(pEngine: *ma_engine): *ma_resource_manager <cimport,nodecl> end
global function ma_engine_get_device(pEngine: *ma_engine): *ma_device <cimport,nodecl> end
global function ma_engine_get_log(pEngine: *ma_engine): *ma_log <cimport,nodecl> end
global function ma_engine_get_endpoint(pEngine: *ma_engine): pointer <cimport,nodecl> end
global function ma_engine_get_time_in_pcm_frames(pEngine: *ma_engine): uint64 <cimport,nodecl> end
global function ma_engine_get_time_in_milliseconds(pEngine: *ma_engine): uint64 <cimport,nodecl> end
global function ma_engine_set_time_in_pcm_frames(pEngine: *ma_engine, globalTime: uint64): ma_result <cimport,nodecl> end
global function ma_engine_set_time_in_milliseconds(pEngine: *ma_engine, globalTime: uint64): ma_result <cimport,nodecl> end
global function ma_engine_get_time(pEngine: *ma_engine): uint64 <cimport,nodecl> end
global function ma_engine_set_time(pEngine: *ma_engine, globalTime: uint64): ma_result <cimport,nodecl> end
global function ma_engine_get_channels(pEngine: *ma_engine): uint32 <cimport,nodecl> end
global function ma_engine_get_sample_rate(pEngine: *ma_engine): uint32 <cimport,nodecl> end
global function ma_engine_start(pEngine: *ma_engine): ma_result <cimport,nodecl> end
global function ma_engine_stop(pEngine: *ma_engine): ma_result <cimport,nodecl> end
global function ma_engine_set_volume(pEngine: *ma_engine, volume: float32): ma_result <cimport,nodecl> end
global function ma_engine_set_gain_db(pEngine: *ma_engine, gainDB: float32): ma_result <cimport,nodecl> end
global function ma_engine_get_listener_count(pEngine: *ma_engine): uint32 <cimport,nodecl> end
global function ma_engine_find_closest_listener(pEngine: *ma_engine, absolutePosX: float32, absolutePosY: float32, absolutePosZ: float32): uint32 <cimport,nodecl> end
global function ma_engine_listener_set_position(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_engine_listener_get_position(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport,nodecl> end
global function ma_engine_listener_set_direction(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_engine_listener_get_direction(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport,nodecl> end
global function ma_engine_listener_set_velocity(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_engine_listener_get_velocity(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport,nodecl> end
global function ma_engine_listener_set_cone(pEngine: *ma_engine, listenerIndex: uint32, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32): void <cimport,nodecl> end
global function ma_engine_listener_get_cone(pEngine: *ma_engine, listenerIndex: uint32, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32): void <cimport,nodecl> end
global function ma_engine_listener_set_world_up(pEngine: *ma_engine, listenerIndex: uint32, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_engine_listener_get_world_up(pEngine: *ma_engine, listenerIndex: uint32): ma_vec3f <cimport,nodecl> end
global function ma_engine_listener_set_enabled(pEngine: *ma_engine, listenerIndex: uint32, isEnabled: ma_bool32): void <cimport,nodecl> end
global function ma_engine_listener_is_enabled(pEngine: *ma_engine, listenerIndex: uint32): ma_bool32 <cimport,nodecl> end
global function ma_engine_play_sound_ex(pEngine: *ma_engine, pFilePath: cstring, pNode: pointer, nodeInputBusIndex: uint32): ma_result <cimport,nodecl> end
global function ma_engine_play_sound(pEngine: *ma_engine, pFilePath: cstring, pGroup: *ma_sound_group): ma_result <cimport,nodecl> end
global function ma_sound_init_from_file(pEngine: *ma_engine, pFilePath: cstring, flags: uint32, pGroup: *ma_sound_group, pDoneFence: *ma_fence, pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_init_from_file_w(pEngine: *ma_engine, pFilePath: *cwchar_t, flags: uint32, pGroup: *ma_sound_group, pDoneFence: *ma_fence, pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_init_copy(pEngine: *ma_engine, pExistingSound: *ma_sound, flags: uint32, pGroup: *ma_sound_group, pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_init_from_data_source(pEngine: *ma_engine, pDataSource: pointer, flags: uint32, pGroup: *ma_sound_group, pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_init_ex(pEngine: *ma_engine, pConfig: *ma_sound_config, pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_uninit(pSound: *ma_sound): void <cimport,nodecl> end
global function ma_sound_get_engine(pSound: *ma_sound): *ma_engine <cimport,nodecl> end
global function ma_sound_get_data_source(pSound: *ma_sound): pointer <cimport,nodecl> end
global function ma_sound_start(pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_stop(pSound: *ma_sound): ma_result <cimport,nodecl> end
global function ma_sound_set_volume(pSound: *ma_sound, volume: float32): void <cimport,nodecl> end
global function ma_sound_get_volume(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_pan(pSound: *ma_sound, pan: float32): void <cimport,nodecl> end
global function ma_sound_get_pan(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_pan_mode(pSound: *ma_sound, panMode: ma_pan_mode): void <cimport,nodecl> end
global function ma_sound_get_pan_mode(pSound: *ma_sound): ma_pan_mode <cimport,nodecl> end
global function ma_sound_set_pitch(pSound: *ma_sound, pitch: float32): void <cimport,nodecl> end
global function ma_sound_get_pitch(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_spatialization_enabled(pSound: *ma_sound, enabled: ma_bool32): void <cimport,nodecl> end
global function ma_sound_is_spatialization_enabled(pSound: *ma_sound): ma_bool32 <cimport,nodecl> end
global function ma_sound_set_pinned_listener_index(pSound: *ma_sound, listenerIndex: uint32): void <cimport,nodecl> end
global function ma_sound_get_pinned_listener_index(pSound: *ma_sound): uint32 <cimport,nodecl> end
global function ma_sound_get_listener_index(pSound: *ma_sound): uint32 <cimport,nodecl> end
global function ma_sound_get_direction_to_listener(pSound: *ma_sound): ma_vec3f <cimport,nodecl> end
global function ma_sound_set_position(pSound: *ma_sound, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_get_position(pSound: *ma_sound): ma_vec3f <cimport,nodecl> end
global function ma_sound_set_direction(pSound: *ma_sound, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_get_direction(pSound: *ma_sound): ma_vec3f <cimport,nodecl> end
global function ma_sound_set_velocity(pSound: *ma_sound, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_get_velocity(pSound: *ma_sound): ma_vec3f <cimport,nodecl> end
global function ma_sound_set_attenuation_model(pSound: *ma_sound, attenuationModel: ma_attenuation_model): void <cimport,nodecl> end
global function ma_sound_get_attenuation_model(pSound: *ma_sound): ma_attenuation_model <cimport,nodecl> end
global function ma_sound_set_positioning(pSound: *ma_sound, positioning: ma_positioning): void <cimport,nodecl> end
global function ma_sound_get_positioning(pSound: *ma_sound): ma_positioning <cimport,nodecl> end
global function ma_sound_set_rolloff(pSound: *ma_sound, rolloff: float32): void <cimport,nodecl> end
global function ma_sound_get_rolloff(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_min_gain(pSound: *ma_sound, minGain: float32): void <cimport,nodecl> end
global function ma_sound_get_min_gain(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_max_gain(pSound: *ma_sound, maxGain: float32): void <cimport,nodecl> end
global function ma_sound_get_max_gain(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_min_distance(pSound: *ma_sound, minDistance: float32): void <cimport,nodecl> end
global function ma_sound_get_min_distance(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_max_distance(pSound: *ma_sound, maxDistance: float32): void <cimport,nodecl> end
global function ma_sound_get_max_distance(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_cone(pSound: *ma_sound, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32): void <cimport,nodecl> end
global function ma_sound_get_cone(pSound: *ma_sound, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32): void <cimport,nodecl> end
global function ma_sound_set_doppler_factor(pSound: *ma_sound, dopplerFactor: float32): void <cimport,nodecl> end
global function ma_sound_get_doppler_factor(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_directional_attenuation_factor(pSound: *ma_sound, directionalAttenuationFactor: float32): void <cimport,nodecl> end
global function ma_sound_get_directional_attenuation_factor(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_fade_in_pcm_frames(pSound: *ma_sound, volumeBeg: float32, volumeEnd: float32, fadeLengthInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_set_fade_in_milliseconds(pSound: *ma_sound, volumeBeg: float32, volumeEnd: float32, fadeLengthInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_get_current_fade_volume(pSound: *ma_sound): float32 <cimport,nodecl> end
global function ma_sound_set_start_time_in_pcm_frames(pSound: *ma_sound, absoluteGlobalTimeInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_set_start_time_in_milliseconds(pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_set_stop_time_in_pcm_frames(pSound: *ma_sound, absoluteGlobalTimeInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_set_stop_time_in_milliseconds(pSound: *ma_sound, absoluteGlobalTimeInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_is_playing(pSound: *ma_sound): ma_bool32 <cimport,nodecl> end
global function ma_sound_get_time_in_pcm_frames(pSound: *ma_sound): uint64 <cimport,nodecl> end
global function ma_sound_set_looping(pSound: *ma_sound, isLooping: ma_bool32): void <cimport,nodecl> end
global function ma_sound_is_looping(pSound: *ma_sound): ma_bool32 <cimport,nodecl> end
global function ma_sound_at_end(pSound: *ma_sound): ma_bool32 <cimport,nodecl> end
global function ma_sound_seek_to_pcm_frame(pSound: *ma_sound, frameIndex: uint64): ma_result <cimport,nodecl> end
global function ma_sound_get_data_format(pSound: *ma_sound, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32, pChannelMap: *ma_channel, channelMapCap: csize): ma_result <cimport,nodecl> end
global function ma_sound_get_cursor_in_pcm_frames(pSound: *ma_sound, pCursor: *uint64): ma_result <cimport,nodecl> end
global function ma_sound_get_length_in_pcm_frames(pSound: *ma_sound, pLength: *uint64): ma_result <cimport,nodecl> end
global function ma_sound_get_cursor_in_seconds(pSound: *ma_sound, pCursor: *float32): ma_result <cimport,nodecl> end
global function ma_sound_get_length_in_seconds(pSound: *ma_sound, pLength: *float32): ma_result <cimport,nodecl> end
global function ma_sound_set_end_callback(pSound: *ma_sound, callback: ma_sound_end_proc, pUserData: pointer): ma_result <cimport,nodecl> end
global function ma_sound_group_init(pEngine: *ma_engine, flags: uint32, pParentGroup: *ma_sound_group, pGroup: *ma_sound_group): ma_result <cimport,nodecl> end
global function ma_sound_group_init_ex(pEngine: *ma_engine, pConfig: *ma_sound_group_config, pGroup: *ma_sound_group): ma_result <cimport,nodecl> end
global function ma_sound_group_uninit(pGroup: *ma_sound_group): void <cimport,nodecl> end
global function ma_sound_group_get_engine(pGroup: *ma_sound_group): *ma_engine <cimport,nodecl> end
global function ma_sound_group_start(pGroup: *ma_sound_group): ma_result <cimport,nodecl> end
global function ma_sound_group_stop(pGroup: *ma_sound_group): ma_result <cimport,nodecl> end
global function ma_sound_group_set_volume(pGroup: *ma_sound_group, volume: float32): void <cimport,nodecl> end
global function ma_sound_group_get_volume(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_pan(pGroup: *ma_sound_group, pan: float32): void <cimport,nodecl> end
global function ma_sound_group_get_pan(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_pan_mode(pGroup: *ma_sound_group, panMode: ma_pan_mode): void <cimport,nodecl> end
global function ma_sound_group_get_pan_mode(pGroup: *ma_sound_group): ma_pan_mode <cimport,nodecl> end
global function ma_sound_group_set_pitch(pGroup: *ma_sound_group, pitch: float32): void <cimport,nodecl> end
global function ma_sound_group_get_pitch(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_spatialization_enabled(pGroup: *ma_sound_group, enabled: ma_bool32): void <cimport,nodecl> end
global function ma_sound_group_is_spatialization_enabled(pGroup: *ma_sound_group): ma_bool32 <cimport,nodecl> end
global function ma_sound_group_set_pinned_listener_index(pGroup: *ma_sound_group, listenerIndex: uint32): void <cimport,nodecl> end
global function ma_sound_group_get_pinned_listener_index(pGroup: *ma_sound_group): uint32 <cimport,nodecl> end
global function ma_sound_group_get_listener_index(pGroup: *ma_sound_group): uint32 <cimport,nodecl> end
global function ma_sound_group_get_direction_to_listener(pGroup: *ma_sound_group): ma_vec3f <cimport,nodecl> end
global function ma_sound_group_set_position(pGroup: *ma_sound_group, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_group_get_position(pGroup: *ma_sound_group): ma_vec3f <cimport,nodecl> end
global function ma_sound_group_set_direction(pGroup: *ma_sound_group, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_group_get_direction(pGroup: *ma_sound_group): ma_vec3f <cimport,nodecl> end
global function ma_sound_group_set_velocity(pGroup: *ma_sound_group, x: float32, y: float32, z: float32): void <cimport,nodecl> end
global function ma_sound_group_get_velocity(pGroup: *ma_sound_group): ma_vec3f <cimport,nodecl> end
global function ma_sound_group_set_attenuation_model(pGroup: *ma_sound_group, attenuationModel: ma_attenuation_model): void <cimport,nodecl> end
global function ma_sound_group_get_attenuation_model(pGroup: *ma_sound_group): ma_attenuation_model <cimport,nodecl> end
global function ma_sound_group_set_positioning(pGroup: *ma_sound_group, positioning: ma_positioning): void <cimport,nodecl> end
global function ma_sound_group_get_positioning(pGroup: *ma_sound_group): ma_positioning <cimport,nodecl> end
global function ma_sound_group_set_rolloff(pGroup: *ma_sound_group, rolloff: float32): void <cimport,nodecl> end
global function ma_sound_group_get_rolloff(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_min_gain(pGroup: *ma_sound_group, minGain: float32): void <cimport,nodecl> end
global function ma_sound_group_get_min_gain(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_max_gain(pGroup: *ma_sound_group, maxGain: float32): void <cimport,nodecl> end
global function ma_sound_group_get_max_gain(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_min_distance(pGroup: *ma_sound_group, minDistance: float32): void <cimport,nodecl> end
global function ma_sound_group_get_min_distance(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_max_distance(pGroup: *ma_sound_group, maxDistance: float32): void <cimport,nodecl> end
global function ma_sound_group_get_max_distance(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_cone(pGroup: *ma_sound_group, innerAngleInRadians: float32, outerAngleInRadians: float32, outerGain: float32): void <cimport,nodecl> end
global function ma_sound_group_get_cone(pGroup: *ma_sound_group, pInnerAngleInRadians: *float32, pOuterAngleInRadians: *float32, pOuterGain: *float32): void <cimport,nodecl> end
global function ma_sound_group_set_doppler_factor(pGroup: *ma_sound_group, dopplerFactor: float32): void <cimport,nodecl> end
global function ma_sound_group_get_doppler_factor(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_directional_attenuation_factor(pGroup: *ma_sound_group, directionalAttenuationFactor: float32): void <cimport,nodecl> end
global function ma_sound_group_get_directional_attenuation_factor(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_fade_in_pcm_frames(pGroup: *ma_sound_group, volumeBeg: float32, volumeEnd: float32, fadeLengthInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_group_set_fade_in_milliseconds(pGroup: *ma_sound_group, volumeBeg: float32, volumeEnd: float32, fadeLengthInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_group_get_current_fade_volume(pGroup: *ma_sound_group): float32 <cimport,nodecl> end
global function ma_sound_group_set_start_time_in_pcm_frames(pGroup: *ma_sound_group, absoluteGlobalTimeInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_group_set_start_time_in_milliseconds(pGroup: *ma_sound_group, absoluteGlobalTimeInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_group_set_stop_time_in_pcm_frames(pGroup: *ma_sound_group, absoluteGlobalTimeInFrames: uint64): void <cimport,nodecl> end
global function ma_sound_group_set_stop_time_in_milliseconds(pGroup: *ma_sound_group, absoluteGlobalTimeInMilliseconds: uint64): void <cimport,nodecl> end
global function ma_sound_group_is_playing(pGroup: *ma_sound_group): ma_bool32 <cimport,nodecl> end
global function ma_sound_group_get_time_in_pcm_frames(pGroup: *ma_sound_group): uint64 <cimport,nodecl> end
global MA_VERSION_MAJOR: cint <cimport,nodecl,const>
global MA_VERSION_MINOR: cint <cimport,nodecl,const>
global MA_VERSION_REVISION: cint <cimport,nodecl,const>
global MA_VERSION_STRING: cstring <cimport,nodecl,const>
global MA_SIZEOF_PTR: cint <comptime> = 8
global MA_TRUE: cint <comptime> = 1
global MA_FALSE: cint <comptime> = 0
global MA_FALLTHROUGH: cint <cimport,nodecl,const>
global MA_GNUC_INLINE_HINT: cint <cimport,nodecl,const>
global MA_MIN_CHANNELS: cint <comptime> = 1
global MA_MAX_CHANNELS: cint <comptime> = 254
global MA_MAX_FILTER_ORDER: cint <comptime> = 8
global MA_MAX_LOG_CALLBACKS: cint <comptime> = 4
global MA_CHANNEL_INDEX_NULL: cint <comptime> = 255
global MA_DATA_SOURCE_SELF_MANAGED_RANGE_AND_LOOP_POINT: cint <comptime> = 0x00000001
global MA_BACKEND_COUNT: cint <cimport,nodecl,const>
global MA_DATA_FORMAT_FLAG_EXCLUSIVE_MODE: cint <cimport,nodecl,const>
global MA_MAX_DEVICE_NAME_LENGTH: cint <comptime> = 255
global MA_JOB_TYPE_RESOURCE_MANAGER_QUEUE_FLAG_NON_BLOCKING: cint <cimport,nodecl,const>
global MA_RESOURCE_MANAGER_MAX_JOB_THREAD_COUNT: cint <comptime> = 64
global MA_MAX_NODE_BUS_COUNT: cint <comptime> = 254
global MA_MAX_NODE_LOCAL_BUS_COUNT: cint <comptime> = 2
global MA_NODE_BUS_COUNT_UNKNOWN: cint <comptime> = 255
global MA_ENGINE_MAX_LISTENERS: cint <comptime> = 4
global MA_LISTENER_INDEX_CLOSEST: cint <cimport,nodecl,const>
global MA_SOUND_SOURCE_CHANNEL_COUNT: uint32 <comptime> = 0xffffffff
