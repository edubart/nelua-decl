##[[
cinclude '<uv.h>'
linklib 'uv'
if ccinfo.is_gcc then
  cflags '-fno-strict-aliasing'
end
]]
global FILE: type <cimport,nodecl,forwarddecl> = @record{}
global DIR: type <cimport,nodecl,forwarddecl> = @record{}
global sockaddr: type <cimport,nodecl,ctypedef> = @record{
  sa_family: cushort,
  sa_data: [14]cchar
}
global in_addr: type <cimport,nodecl,ctypedef> = @record{
  s_addr: cuint
}
global in6_addr: type <cimport,nodecl,ctypedef> = @record{
  __in6_u: union{
    __u6_addr8: [16]uint8,
    __u6_addr16: [8]uint16,
    __u6_addr32: [4]uint32
  }
}
global sockaddr_in: type <cimport,nodecl,ctypedef> = @record{
  sin_family: cushort,
  sin_port: cushort,
  sin_addr: in_addr,
  sin_zero: [8]cuchar
}
global sockaddr_in6: type <cimport,nodecl,ctypedef> = @record{
  sin6_family: cushort,
  sin6_port: cushort,
  sin6_flowinfo: uint32,
  sin6_addr: in6_addr,
  sin6_scope_id: uint32
}
global addrinfo: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
addrinfo = @record{
  ai_flags: cint,
  ai_family: cint,
  ai_socktype: cint,
  ai_protocol: cint,
  ai_addrlen: cuint,
  ai_addr: *sockaddr,
  ai_canonname: cstring,
  ai_next: *addrinfo
}
global uv_loop_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv__io_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_buf_t: type <cimport,nodecl> = @record{
  base: cstring,
  len: csize
}
global uv_file: type <cimport,nodecl,cincomplete> = @record{}
global uv_os_sock_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_os_fd_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_pid_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_once_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_thread_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_mutex_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_rwlock_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_sem_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_cond_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_key_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_barrier_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_gid_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_uid_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_lib_t: type <cimport,nodecl,cincomplete> = @record{}
global uv_errno_t: type <cimport,nodecl,using> = @enum(cint){
  UV_E2BIG = -7,
  UV_EACCES = -13,
  UV_EADDRINUSE = -98,
  UV_EADDRNOTAVAIL = -99,
  UV_EAFNOSUPPORT = -97,
  UV_EAGAIN = -11,
  UV_EAI_ADDRFAMILY = -3000,
  UV_EAI_AGAIN = -3001,
  UV_EAI_BADFLAGS = -3002,
  UV_EAI_BADHINTS = -3013,
  UV_EAI_CANCELED = -3003,
  UV_EAI_FAIL = -3004,
  UV_EAI_FAMILY = -3005,
  UV_EAI_MEMORY = -3006,
  UV_EAI_NODATA = -3007,
  UV_EAI_NONAME = -3008,
  UV_EAI_OVERFLOW = -3009,
  UV_EAI_PROTOCOL = -3014,
  UV_EAI_SERVICE = -3010,
  UV_EAI_SOCKTYPE = -3011,
  UV_EALREADY = -114,
  UV_EBADF = -9,
  UV_EBUSY = -16,
  UV_ECANCELED = -125,
  UV_ECHARSET = -4080,
  UV_ECONNABORTED = -103,
  UV_ECONNREFUSED = -111,
  UV_ECONNRESET = -104,
  UV_EDESTADDRREQ = -89,
  UV_EEXIST = -17,
  UV_EFAULT = -14,
  UV_EFBIG = -27,
  UV_EHOSTUNREACH = -113,
  UV_EINTR = -4,
  UV_EINVAL = -22,
  UV_EIO = -5,
  UV_EISCONN = -106,
  UV_EISDIR = -21,
  UV_ELOOP = -40,
  UV_EMFILE = -24,
  UV_EMSGSIZE = -90,
  UV_ENAMETOOLONG = -36,
  UV_ENETDOWN = -100,
  UV_ENETUNREACH = -101,
  UV_ENFILE = -23,
  UV_ENOBUFS = -105,
  UV_ENODEV = -19,
  UV_ENOENT = -2,
  UV_ENOMEM = -12,
  UV_ENONET = -64,
  UV_ENOPROTOOPT = -92,
  UV_ENOSPC = -28,
  UV_ENOSYS = -38,
  UV_ENOTCONN = -107,
  UV_ENOTDIR = -20,
  UV_ENOTEMPTY = -39,
  UV_ENOTSOCK = -88,
  UV_ENOTSUP = -95,
  UV_EOVERFLOW = -75,
  UV_EPERM = -1,
  UV_EPIPE = -32,
  UV_EPROTO = -71,
  UV_EPROTONOSUPPORT = -93,
  UV_EPROTOTYPE = -91,
  UV_ERANGE = -34,
  UV_EROFS = -30,
  UV_ESHUTDOWN = -108,
  UV_ESPIPE = -29,
  UV_ESRCH = -3,
  UV_ETIMEDOUT = -110,
  UV_ETXTBSY = -26,
  UV_EXDEV = -18,
  UV_UNKNOWN = -4094,
  UV_EOF = -4095,
  UV_ENXIO = -6,
  UV_EMLINK = -31,
  UV_EHOSTDOWN = -112,
  UV_EREMOTEIO = -121,
  UV_ENOTTY = -25,
  UV_EFTYPE = -4028,
  UV_EILSEQ = -84,
  UV_ESOCKTNOSUPPORT = -94,
  UV_ERRNO_MAX = -4096
}
global uv_handle_type: type <cimport,nodecl,using> = @enum(cint){
  UV_UNKNOWN_HANDLE = 0,
  UV_ASYNC = 1,
  UV_CHECK = 2,
  UV_FS_EVENT = 3,
  UV_FS_POLL = 4,
  UV_HANDLE = 5,
  UV_IDLE = 6,
  UV_NAMED_PIPE = 7,
  UV_POLL = 8,
  UV_PREPARE = 9,
  UV_PROCESS = 10,
  UV_STREAM = 11,
  UV_TCP = 12,
  UV_TIMER = 13,
  UV_TTY = 14,
  UV_UDP = 15,
  UV_SIGNAL = 16,
  UV_FILE = 17,
  UV_HANDLE_TYPE_MAX = 18
}
global uv_req_type: type <cimport,nodecl,using> = @enum(cint){
  UV_UNKNOWN_REQ = 0,
  UV_REQ = 1,
  UV_CONNECT = 2,
  UV_WRITE = 3,
  UV_SHUTDOWN = 4,
  UV_UDP_SEND = 5,
  UV_FS = 6,
  UV_WORK = 7,
  UV_GETADDRINFO = 8,
  UV_GETNAMEINFO = 9,
  UV_RANDOM = 10,
  UV_REQ_TYPE_MAX = 11
}
global uv_loop_t: type = @uv_loop_s
global uv_handle_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_handle_t: type = @uv_handle_s
global uv_dir_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_dir_t: type = @uv_dir_s
global uv_stream_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_stream_t: type = @uv_stream_s
global uv_tcp_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_tcp_t: type = @uv_tcp_s
global uv_udp_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_udp_t: type = @uv_udp_s
global uv_pipe_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_pipe_t: type = @uv_pipe_s
global uv_tty_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_tty_t: type = @uv_tty_s
global uv_poll_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_poll_t: type = @uv_poll_s
global uv_timer_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_timer_t: type = @uv_timer_s
global uv_prepare_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_prepare_t: type = @uv_prepare_s
global uv_check_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_check_t: type = @uv_check_s
global uv_idle_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_idle_t: type = @uv_idle_s
global uv_async_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_async_t: type = @uv_async_s
global uv_process_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_process_t: type = @uv_process_s
global uv_fs_event_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_fs_event_t: type = @uv_fs_event_s
global uv_fs_poll_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_fs_poll_t: type = @uv_fs_poll_s
global uv_signal_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_signal_t: type = @uv_signal_s
global uv_req_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_req_t: type = @uv_req_s
global uv_getaddrinfo_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_getaddrinfo_t: type = @uv_getaddrinfo_s
global uv_getnameinfo_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_getnameinfo_t: type = @uv_getnameinfo_s
global uv_shutdown_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_shutdown_t: type = @uv_shutdown_s
global uv_write_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_write_t: type = @uv_write_s
global uv_connect_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_connect_t: type = @uv_connect_s
global uv_udp_send_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_udp_send_t: type = @uv_udp_send_s
global uv_fs_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_fs_t: type = @uv_fs_s
global uv_work_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_work_t: type = @uv_work_s
global uv_random_s: type <cimport,nodecl,forwarddecl,cincomplete,ctypedef> = @record{}
global uv_random_t: type = @uv_random_s
global uv_env_item_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_env_item_t: type = @uv_env_item_s
global uv_cpu_info_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_cpu_info_t: type = @uv_cpu_info_s
global uv_interface_address_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_interface_address_t: type = @uv_interface_address_s
global uv_dirent_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_dirent_t: type = @uv_dirent_s
global uv_passwd_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_passwd_t: type = @uv_passwd_s
global uv_utsname_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_utsname_t: type = @uv_utsname_s
global uv_statfs_s: type <cimport,nodecl,forwarddecl,ctypedef> = @record{}
global uv_statfs_t: type = @uv_statfs_s
global uv_loop_option: type <cimport,nodecl,using> = @enum(cint){
  UV_LOOP_BLOCK_SIGNAL = 0,
  UV_METRICS_IDLE_TIME = 1
}
global uv_run_mode: type <cimport,nodecl,using> = @enum(cint){
  UV_RUN_DEFAULT = 0,
  UV_RUN_ONCE = 1,
  UV_RUN_NOWAIT = 2
}
global function uv_version(): cuint <cimport,nodecl> end
global function uv_version_string(): cstring <cimport,nodecl> end
global uv_malloc_func: type <cimport,nodecl> = @function(csize): pointer
global uv_realloc_func: type <cimport,nodecl> = @function(pointer, csize): pointer
global uv_calloc_func: type <cimport,nodecl> = @function(csize, csize): pointer
global uv_free_func: type <cimport,nodecl> = @function(pointer): void
global function uv_library_shutdown(): void <cimport,nodecl> end
global function uv_replace_allocator(malloc_func: uv_malloc_func, realloc_func: uv_realloc_func, calloc_func: uv_calloc_func, free_func: uv_free_func): cint <cimport,nodecl> end
global function uv_default_loop(): *uv_loop_t <cimport,nodecl> end
global function uv_loop_init(loop: *uv_loop_t): cint <cimport,nodecl> end
global function uv_loop_close(loop: *uv_loop_t): cint <cimport,nodecl> end
global function uv_loop_new(): *uv_loop_t <cimport,nodecl> end
global function uv_loop_delete(a1: *uv_loop_t): void <cimport,nodecl> end
global function uv_loop_size(): csize <cimport,nodecl> end
global function uv_loop_alive(loop: *uv_loop_t): cint <cimport,nodecl> end
global function uv_loop_configure(loop: *uv_loop_t, option: uv_loop_option, ...: cvarargs): cint <cimport,nodecl> end
global function uv_loop_fork(loop: *uv_loop_t): cint <cimport,nodecl> end
global function uv_run(a1: *uv_loop_t, mode: uv_run_mode): cint <cimport,nodecl> end
global function uv_stop(a1: *uv_loop_t): void <cimport,nodecl> end
global function uv_ref(a1: *uv_handle_t): void <cimport,nodecl> end
global function uv_unref(a1: *uv_handle_t): void <cimport,nodecl> end
global function uv_has_ref(a1: *uv_handle_t): cint <cimport,nodecl> end
global function uv_update_time(a1: *uv_loop_t): void <cimport,nodecl> end
global function uv_now(a1: *uv_loop_t): uint64 <cimport,nodecl> end
global function uv_backend_fd(a1: *uv_loop_t): cint <cimport,nodecl> end
global function uv_backend_timeout(a1: *uv_loop_t): cint <cimport,nodecl> end
global uv_alloc_cb: type <cimport,nodecl> = @function(*uv_handle_t, csize, *uv_buf_t): void
global uv_read_cb: type <cimport,nodecl> = @function(*uv_stream_t, clong, *uv_buf_t): void
global uv_write_cb: type <cimport,nodecl> = @function(*uv_write_t, cint): void
global uv_connect_cb: type <cimport,nodecl> = @function(*uv_connect_t, cint): void
global uv_shutdown_cb: type <cimport,nodecl> = @function(*uv_shutdown_t, cint): void
global uv_connection_cb: type <cimport,nodecl> = @function(*uv_stream_t, cint): void
global uv_close_cb: type <cimport,nodecl> = @function(*uv_handle_t): void
global uv_poll_cb: type <cimport,nodecl> = @function(*uv_poll_t, cint, cint): void
global uv_timer_cb: type <cimport,nodecl> = @function(*uv_timer_t): void
global uv_async_cb: type <cimport,nodecl> = @function(*uv_async_t): void
global uv_prepare_cb: type <cimport,nodecl> = @function(*uv_prepare_t): void
global uv_check_cb: type <cimport,nodecl> = @function(*uv_check_t): void
global uv_idle_cb: type <cimport,nodecl> = @function(*uv_idle_t): void
global uv_exit_cb: type <cimport,nodecl> = @function(*uv_process_t, int64, cint): void
global uv_walk_cb: type <cimport,nodecl> = @function(*uv_handle_t, pointer): void
global uv_fs_cb: type <cimport,nodecl> = @function(*uv_fs_t): void
global uv_work_cb: type <cimport,nodecl> = @function(*uv_work_t): void
global uv_after_work_cb: type <cimport,nodecl> = @function(*uv_work_t, cint): void
global uv_getaddrinfo_cb: type <cimport,nodecl> = @function(*uv_getaddrinfo_t, cint, *addrinfo): void
global uv_getnameinfo_cb: type <cimport,nodecl> = @function(*uv_getnameinfo_t, cint, cstring, cstring): void
global uv_random_cb: type <cimport,nodecl> = @function(*uv_random_t, cint, pointer, csize): void
global uv_timespec_t: type <cimport,nodecl> = @record{
  tv_sec: clong,
  tv_nsec: clong
}
global uv_stat_t: type <cimport,nodecl> = @record{
  st_dev: uint64,
  st_mode: uint64,
  st_nlink: uint64,
  st_uid: uint64,
  st_gid: uint64,
  st_rdev: uint64,
  st_ino: uint64,
  st_size: uint64,
  st_blksize: uint64,
  st_blocks: uint64,
  st_flags: uint64,
  st_gen: uint64,
  st_atim: uv_timespec_t,
  st_mtim: uv_timespec_t,
  st_ctim: uv_timespec_t,
  st_birthtim: uv_timespec_t
}
global uv_fs_event_cb: type <cimport,nodecl> = @function(*uv_fs_event_t, cstring, cint, cint): void
global uv_fs_poll_cb: type <cimport,nodecl> = @function(*uv_fs_poll_t, cint, *uv_stat_t, *uv_stat_t): void
global uv_signal_cb: type <cimport,nodecl> = @function(*uv_signal_t, cint): void
global uv_membership: type <cimport,nodecl,using> = @enum(cint){
  UV_LEAVE_GROUP = 0,
  UV_JOIN_GROUP = 1
}
global function uv_translate_sys_error(sys_errno: cint): cint <cimport,nodecl> end
global function uv_strerror(err: cint): cstring <cimport,nodecl> end
global function uv_strerror_r(err: cint, buf: cstring, buflen: csize): cstring <cimport,nodecl> end
global function uv_err_name(err: cint): cstring <cimport,nodecl> end
global function uv_err_name_r(err: cint, buf: cstring, buflen: csize): cstring <cimport,nodecl> end
uv_req_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer
}
global function uv_shutdown(req: *uv_shutdown_t, handle: *uv_stream_t, cb: uv_shutdown_cb): cint <cimport,nodecl> end
uv_shutdown_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  handle: *uv_stream_t,
  cb: uv_shutdown_cb
}
uv_handle_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint
}
global function uv_handle_size(type: uv_handle_type): csize <cimport,nodecl> end
global function uv_handle_get_type(handle: *uv_handle_t): uv_handle_type <cimport,nodecl> end
global function uv_handle_type_name(type: uv_handle_type): cstring <cimport,nodecl> end
global function uv_handle_get_data(handle: *uv_handle_t): pointer <cimport,nodecl> end
global function uv_handle_get_loop(handle: *uv_handle_t): *uv_loop_t <cimport,nodecl> end
global function uv_handle_set_data(handle: *uv_handle_t, data: pointer): void <cimport,nodecl> end
global function uv_req_size(type: uv_req_type): csize <cimport,nodecl> end
global function uv_req_get_data(req: *uv_req_t): pointer <cimport,nodecl> end
global function uv_req_set_data(req: *uv_req_t, data: pointer): void <cimport,nodecl> end
global function uv_req_get_type(req: *uv_req_t): uv_req_type <cimport,nodecl> end
global function uv_req_type_name(type: uv_req_type): cstring <cimport,nodecl> end
global function uv_is_active(handle: *uv_handle_t): cint <cimport,nodecl> end
global function uv_walk(loop: *uv_loop_t, walk_cb: uv_walk_cb, arg: pointer): void <cimport,nodecl> end
global function uv_print_all_handles(loop: *uv_loop_t, stream: *FILE): void <cimport,nodecl> end
global function uv_print_active_handles(loop: *uv_loop_t, stream: *FILE): void <cimport,nodecl> end
global function uv_close(handle: *uv_handle_t, close_cb: uv_close_cb): void <cimport,nodecl> end
global function uv_send_buffer_size(handle: *uv_handle_t, value: *cint): cint <cimport,nodecl> end
global function uv_recv_buffer_size(handle: *uv_handle_t, value: *cint): cint <cimport,nodecl> end
global function uv_fileno(handle: *uv_handle_t, fd: *uv_os_fd_t): cint <cimport,nodecl> end
global function uv_buf_init(base: cstring, len: cuint): uv_buf_t <cimport,nodecl> end
global function uv_pipe(fds: *uv_file, read_flags: cint, write_flags: cint): cint <cimport,nodecl> end
global function uv_socketpair(type: cint, protocol: cint, socket_vector: *uv_os_sock_t, flags0: cint, flags1: cint): cint <cimport,nodecl> end
uv_stream_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  write_queue_size: csize,
  alloc_cb: uv_alloc_cb,
  read_cb: uv_read_cb,
  connect_req: *uv_connect_t,
  shutdown_req: *uv_shutdown_t,
  io_watcher: uv__io_t,
  write_queue: [2]pointer,
  write_completed_queue: [2]pointer,
  connection_cb: uv_connection_cb,
  delayed_error: cint,
  accepted_fd: cint,
  queued_fds: pointer
}
global function uv_stream_get_write_queue_size(stream: *uv_stream_t): csize <cimport,nodecl> end
global function uv_listen(stream: *uv_stream_t, backlog: cint, cb: uv_connection_cb): cint <cimport,nodecl> end
global function uv_accept(server: *uv_stream_t, client: *uv_stream_t): cint <cimport,nodecl> end
global function uv_read_start(a1: *uv_stream_t, alloc_cb: uv_alloc_cb, read_cb: uv_read_cb): cint <cimport,nodecl> end
global function uv_read_stop(a1: *uv_stream_t): cint <cimport,nodecl> end
global function uv_write(req: *uv_write_t, handle: *uv_stream_t, bufs: *uv_buf_t, nbufs: cuint, cb: uv_write_cb): cint <cimport,nodecl> end
global function uv_write2(req: *uv_write_t, handle: *uv_stream_t, bufs: *uv_buf_t, nbufs: cuint, send_handle: *uv_stream_t, cb: uv_write_cb): cint <cimport,nodecl> end
global function uv_try_write(handle: *uv_stream_t, bufs: *uv_buf_t, nbufs: cuint): cint <cimport,nodecl> end
global function uv_try_write2(handle: *uv_stream_t, bufs: *uv_buf_t, nbufs: cuint, send_handle: *uv_stream_t): cint <cimport,nodecl> end
uv_write_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  cb: uv_write_cb,
  send_handle: *uv_stream_t,
  handle: *uv_stream_t,
  queue: [2]pointer,
  write_index: cuint,
  bufs: *uv_buf_t,
  nbufs: cuint,
  error: cint,
  bufsml: [4]uv_buf_t
}
global function uv_is_readable(handle: *uv_stream_t): cint <cimport,nodecl> end
global function uv_is_writable(handle: *uv_stream_t): cint <cimport,nodecl> end
global function uv_stream_set_blocking(handle: *uv_stream_t, blocking: cint): cint <cimport,nodecl> end
global function uv_is_closing(handle: *uv_handle_t): cint <cimport,nodecl> end
uv_tcp_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  write_queue_size: csize,
  alloc_cb: uv_alloc_cb,
  read_cb: uv_read_cb,
  connect_req: *uv_connect_t,
  shutdown_req: *uv_shutdown_t,
  io_watcher: uv__io_t,
  write_queue: [2]pointer,
  write_completed_queue: [2]pointer,
  connection_cb: uv_connection_cb,
  delayed_error: cint,
  accepted_fd: cint,
  queued_fds: pointer
}
global function uv_tcp_init(a1: *uv_loop_t, handle: *uv_tcp_t): cint <cimport,nodecl> end
global function uv_tcp_init_ex(a1: *uv_loop_t, handle: *uv_tcp_t, flags: cuint): cint <cimport,nodecl> end
global function uv_tcp_open(handle: *uv_tcp_t, sock: uv_os_sock_t): cint <cimport,nodecl> end
global function uv_tcp_nodelay(handle: *uv_tcp_t, enable: cint): cint <cimport,nodecl> end
global function uv_tcp_keepalive(handle: *uv_tcp_t, enable: cint, delay: cuint): cint <cimport,nodecl> end
global function uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: cint): cint <cimport,nodecl> end
global uv_tcp_flags: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_TCP_IPV6ONLY = 1
}
global function uv_tcp_bind(handle: *uv_tcp_t, addr: *sockaddr, flags: cuint): cint <cimport,nodecl> end
global function uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr, namelen: *cint): cint <cimport,nodecl> end
global function uv_tcp_getpeername(handle: *uv_tcp_t, name: *sockaddr, namelen: *cint): cint <cimport,nodecl> end
global function uv_tcp_close_reset(handle: *uv_tcp_t, close_cb: uv_close_cb): cint <cimport,nodecl> end
global function uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t, addr: *sockaddr, cb: uv_connect_cb): cint <cimport,nodecl> end
uv_connect_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  cb: uv_connect_cb,
  handle: *uv_stream_t,
  queue: [2]pointer
}
global uv_udp_flags: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_UDP_IPV6ONLY = 1,
  UV_UDP_PARTIAL = 2,
  UV_UDP_REUSEADDR = 4,
  UV_UDP_MMSG_CHUNK = 8,
  UV_UDP_MMSG_FREE = 16,
  UV_UDP_LINUX_RECVERR = 32,
  UV_UDP_RECVMMSG = 256
}
global uv_udp_send_cb: type <cimport,nodecl> = @function(*uv_udp_send_t, cint): void
global uv_udp_recv_cb: type <cimport,nodecl> = @function(*uv_udp_t, clong, *uv_buf_t, *sockaddr, cuint): void
uv_udp_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  send_queue_size: csize,
  send_queue_count: csize,
  alloc_cb: uv_alloc_cb,
  recv_cb: uv_udp_recv_cb,
  io_watcher: uv__io_t,
  write_queue: [2]pointer,
  write_completed_queue: [2]pointer
}
uv_udp_send_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  handle: *uv_udp_t,
  cb: uv_udp_send_cb,
  queue: [2]pointer,
  nbufs: cuint,
  bufs: *uv_buf_t,
  status: clong,
  send_cb: uv_udp_send_cb,
  bufsml: [4]uv_buf_t
}
global function uv_udp_init(a1: *uv_loop_t, handle: *uv_udp_t): cint <cimport,nodecl> end
global function uv_udp_init_ex(a1: *uv_loop_t, handle: *uv_udp_t, flags: cuint): cint <cimport,nodecl> end
global function uv_udp_open(handle: *uv_udp_t, sock: uv_os_sock_t): cint <cimport,nodecl> end
global function uv_udp_bind(handle: *uv_udp_t, addr: *sockaddr, flags: cuint): cint <cimport,nodecl> end
global function uv_udp_connect(handle: *uv_udp_t, addr: *sockaddr): cint <cimport,nodecl> end
global function uv_udp_getpeername(handle: *uv_udp_t, name: *sockaddr, namelen: *cint): cint <cimport,nodecl> end
global function uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr, namelen: *cint): cint <cimport,nodecl> end
global function uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: cstring, interface_addr: cstring, membership: uv_membership): cint <cimport,nodecl> end
global function uv_udp_set_source_membership(handle: *uv_udp_t, multicast_addr: cstring, interface_addr: cstring, source_addr: cstring, membership: uv_membership): cint <cimport,nodecl> end
global function uv_udp_set_multicast_loop(handle: *uv_udp_t, on: cint): cint <cimport,nodecl> end
global function uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: cint): cint <cimport,nodecl> end
global function uv_udp_set_multicast_interface(handle: *uv_udp_t, interface_addr: cstring): cint <cimport,nodecl> end
global function uv_udp_set_broadcast(handle: *uv_udp_t, on: cint): cint <cimport,nodecl> end
global function uv_udp_set_ttl(handle: *uv_udp_t, ttl: cint): cint <cimport,nodecl> end
global function uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, bufs: *uv_buf_t, nbufs: cuint, addr: *sockaddr, send_cb: uv_udp_send_cb): cint <cimport,nodecl> end
global function uv_udp_try_send(handle: *uv_udp_t, bufs: *uv_buf_t, nbufs: cuint, addr: *sockaddr): cint <cimport,nodecl> end
global function uv_udp_recv_start(handle: *uv_udp_t, alloc_cb: uv_alloc_cb, recv_cb: uv_udp_recv_cb): cint <cimport,nodecl> end
global function uv_udp_using_recvmmsg(handle: *uv_udp_t): cint <cimport,nodecl> end
global function uv_udp_recv_stop(handle: *uv_udp_t): cint <cimport,nodecl> end
global function uv_udp_get_send_queue_size(handle: *uv_udp_t): csize <cimport,nodecl> end
global function uv_udp_get_send_queue_count(handle: *uv_udp_t): csize <cimport,nodecl> end
uv_tty_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  write_queue_size: csize,
  alloc_cb: uv_alloc_cb,
  read_cb: uv_read_cb,
  connect_req: *uv_connect_t,
  shutdown_req: *uv_shutdown_t,
  io_watcher: uv__io_t,
  write_queue: [2]pointer,
  write_completed_queue: [2]pointer,
  connection_cb: uv_connection_cb,
  delayed_error: cint,
  accepted_fd: cint,
  queued_fds: pointer,
  mode: cint
}
global uv_tty_mode_t: type <cimport,nodecl,using> = @enum(cint){
  UV_TTY_MODE_NORMAL = 0,
  UV_TTY_MODE_RAW = 1,
  UV_TTY_MODE_IO = 2
}
global uv_tty_vtermstate_t: type <cimport,nodecl,using> = @enum(cint){
  UV_TTY_SUPPORTED = 0,
  UV_TTY_UNSUPPORTED = 1
}
global function uv_tty_init(a1: *uv_loop_t, a2: *uv_tty_t, fd: uv_file, readable: cint): cint <cimport,nodecl> end
global function uv_tty_set_mode(a1: *uv_tty_t, mode: uv_tty_mode_t): cint <cimport,nodecl> end
global function uv_tty_reset_mode(): cint <cimport,nodecl> end
global function uv_tty_get_winsize(a1: *uv_tty_t, width: *cint, height: *cint): cint <cimport,nodecl> end
global function uv_tty_set_vterm_state(state: uv_tty_vtermstate_t): void <cimport,nodecl> end
global function uv_tty_get_vterm_state(state: *uv_tty_vtermstate_t): cint <cimport,nodecl> end
global function uv_guess_handle(file: uv_file): uv_handle_type <cimport,nodecl> end
uv_pipe_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  write_queue_size: csize,
  alloc_cb: uv_alloc_cb,
  read_cb: uv_read_cb,
  connect_req: *uv_connect_t,
  shutdown_req: *uv_shutdown_t,
  io_watcher: uv__io_t,
  write_queue: [2]pointer,
  write_completed_queue: [2]pointer,
  connection_cb: uv_connection_cb,
  delayed_error: cint,
  accepted_fd: cint,
  queued_fds: pointer,
  ipc: cint,
  pipe_fname: cstring
}
global function uv_pipe_init(a1: *uv_loop_t, handle: *uv_pipe_t, ipc: cint): cint <cimport,nodecl> end
global function uv_pipe_open(a1: *uv_pipe_t, file: uv_file): cint <cimport,nodecl> end
global function uv_pipe_bind(handle: *uv_pipe_t, name: cstring): cint <cimport,nodecl> end
global function uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t, name: cstring, cb: uv_connect_cb): void <cimport,nodecl> end
global function uv_pipe_getsockname(handle: *uv_pipe_t, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_pipe_getpeername(handle: *uv_pipe_t, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_pipe_pending_instances(handle: *uv_pipe_t, count: cint): void <cimport,nodecl> end
global function uv_pipe_pending_count(handle: *uv_pipe_t): cint <cimport,nodecl> end
global function uv_pipe_pending_type(handle: *uv_pipe_t): uv_handle_type <cimport,nodecl> end
global function uv_pipe_chmod(handle: *uv_pipe_t, flags: cint): cint <cimport,nodecl> end
uv_poll_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  poll_cb: uv_poll_cb,
  io_watcher: uv__io_t
}
global uv_poll_event: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_READABLE = 1,
  UV_WRITABLE = 2,
  UV_DISCONNECT = 4,
  UV_PRIORITIZED = 8
}
global function uv_poll_init(loop: *uv_loop_t, handle: *uv_poll_t, fd: cint): cint <cimport,nodecl> end
global function uv_poll_init_socket(loop: *uv_loop_t, handle: *uv_poll_t, socket: uv_os_sock_t): cint <cimport,nodecl> end
global function uv_poll_start(handle: *uv_poll_t, events: cint, cb: uv_poll_cb): cint <cimport,nodecl> end
global function uv_poll_stop(handle: *uv_poll_t): cint <cimport,nodecl> end
uv_prepare_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  prepare_cb: uv_prepare_cb,
  queue: [2]pointer
}
global function uv_prepare_init(a1: *uv_loop_t, prepare: *uv_prepare_t): cint <cimport,nodecl> end
global function uv_prepare_start(prepare: *uv_prepare_t, cb: uv_prepare_cb): cint <cimport,nodecl> end
global function uv_prepare_stop(prepare: *uv_prepare_t): cint <cimport,nodecl> end
uv_check_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  check_cb: uv_check_cb,
  queue: [2]pointer
}
global function uv_check_init(a1: *uv_loop_t, check: *uv_check_t): cint <cimport,nodecl> end
global function uv_check_start(check: *uv_check_t, cb: uv_check_cb): cint <cimport,nodecl> end
global function uv_check_stop(check: *uv_check_t): cint <cimport,nodecl> end
uv_idle_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  idle_cb: uv_idle_cb,
  queue: [2]pointer
}
global function uv_idle_init(a1: *uv_loop_t, idle: *uv_idle_t): cint <cimport,nodecl> end
global function uv_idle_start(idle: *uv_idle_t, cb: uv_idle_cb): cint <cimport,nodecl> end
global function uv_idle_stop(idle: *uv_idle_t): cint <cimport,nodecl> end
uv_async_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  async_cb: uv_async_cb,
  queue: [2]pointer,
  pending: cint
}
global function uv_async_init(a1: *uv_loop_t, async: *uv_async_t, async_cb: uv_async_cb): cint <cimport,nodecl> end
global function uv_async_send(async: *uv_async_t): cint <cimport,nodecl> end
uv_timer_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  timer_cb: uv_timer_cb,
  heap_node: [3]pointer,
  timeout: uint64,
  Repeat: uint64,
  start_id: uint64
}
global function uv_timer_init(a1: *uv_loop_t, handle: *uv_timer_t): cint <cimport,nodecl> end
global function uv_timer_start(handle: *uv_timer_t, cb: uv_timer_cb, timeout: uint64, Repeat: uint64): cint <cimport,nodecl> end
global function uv_timer_stop(handle: *uv_timer_t): cint <cimport,nodecl> end
global function uv_timer_again(handle: *uv_timer_t): cint <cimport,nodecl> end
global function uv_timer_set_repeat(handle: *uv_timer_t, Repeat: uint64): void <cimport,nodecl> end
global function uv_timer_get_repeat(handle: *uv_timer_t): uint64 <cimport,nodecl> end
global function uv_timer_get_due_in(handle: *uv_timer_t): uint64 <cimport,nodecl> end
uv_getaddrinfo_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  loop: *uv_loop_t,
  cb: uv_getaddrinfo_cb,
  hints: *addrinfo,
  hostname: cstring,
  service: cstring,
  addrinfo: *addrinfo,
  retcode: cint
}
global function uv_getaddrinfo(loop: *uv_loop_t, req: *uv_getaddrinfo_t, getaddrinfo_cb: uv_getaddrinfo_cb, node: cstring, service: cstring, hints: *addrinfo): cint <cimport,nodecl> end
global function uv_freeaddrinfo(ai: *addrinfo): void <cimport,nodecl> end
uv_getnameinfo_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  loop: *uv_loop_t,
  getnameinfo_cb: uv_getnameinfo_cb,
  flags: cint,
  host: [1025]cchar,
  service: [32]cchar,
  retcode: cint
}
global function uv_getnameinfo(loop: *uv_loop_t, req: *uv_getnameinfo_t, getnameinfo_cb: uv_getnameinfo_cb, addr: *sockaddr, flags: cint): cint <cimport,nodecl> end
global uv_stdio_flags: type <cimport,nodecl,using> = @enum(cint){
  UV_IGNORE = 0,
  UV_CREATE_PIPE = 1,
  UV_INHERIT_FD = 2,
  UV_INHERIT_STREAM = 4,
  UV_READABLE_PIPE = 16,
  UV_WRITABLE_PIPE = 32,
  UV_NONBLOCK_PIPE = 64,
  UV_OVERLAPPED_PIPE = 64
}
global uv_stdio_container_s: type <cimport,nodecl,ctypedef> = @record{
  flags: uv_stdio_flags,
  data: union{
    stream: *uv_stream_t,
    fd: cint
  }
}
global uv_stdio_container_t: type = @uv_stdio_container_s
global uv_process_options_s: type <cimport,nodecl,ctypedef> = @record{
  exit_cb: uv_exit_cb,
  file: cstring,
  args: *cstring,
  env: *cstring,
  cwd: cstring,
  flags: cuint,
  stdio_count: cint,
  stdio: *uv_stdio_container_t,
  uid: uv_uid_t,
  gid: uv_gid_t
}
global uv_process_options_t: type = @uv_process_options_s
global uv_process_flags: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_PROCESS_SETUID = 1,
  UV_PROCESS_SETGID = 2,
  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = 4,
  UV_PROCESS_DETACHED = 8,
  UV_PROCESS_WINDOWS_HIDE = 16,
  UV_PROCESS_WINDOWS_HIDE_CONSOLE = 32,
  UV_PROCESS_WINDOWS_HIDE_GUI = 64
}
uv_process_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  exit_cb: uv_exit_cb,
  pid: cint,
  queue: [2]pointer,
  status: cint
}
global function uv_spawn(loop: *uv_loop_t, handle: *uv_process_t, options: *uv_process_options_t): cint <cimport,nodecl> end
global function uv_process_kill(a1: *uv_process_t, signum: cint): cint <cimport,nodecl> end
global function uv_kill(pid: cint, signum: cint): cint <cimport,nodecl> end
global function uv_process_get_pid(a1: *uv_process_t): uv_pid_t <cimport,nodecl> end
uv_work_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  loop: *uv_loop_t,
  work_cb: uv_work_cb,
  after_work_cb: uv_after_work_cb,
}
global function uv_queue_work(loop: *uv_loop_t, req: *uv_work_t, work_cb: uv_work_cb, after_work_cb: uv_after_work_cb): cint <cimport,nodecl> end
global function uv_cancel(req: *uv_req_t): cint <cimport,nodecl> end
global uv_cpu_times_s: type <cimport,nodecl,ctypedef> = @record{
  user: uint64,
  nice: uint64,
  sys: uint64,
  idle: uint64,
  irq: uint64
}
uv_cpu_info_s = @record{
  model: cstring,
  speed: cint,
  cpu_times: uv_cpu_times_s
}
uv_interface_address_s = @record{
  name: cstring,
  phys_addr: [6]cchar,
  is_internal: cint,
  address: union{
    address4: sockaddr_in,
    address6: sockaddr_in6
  },
  netmask: union{
    netmask4: sockaddr_in,
    netmask6: sockaddr_in6
  }
}
uv_passwd_s = @record{
  username: cstring,
  uid: clong,
  gid: clong,
  shell: cstring,
  homedir: cstring
}
uv_utsname_s = @record{
  sysname: [256]cchar,
  release: [256]cchar,
  version: [256]cchar,
  machine: [256]cchar
}
uv_statfs_s = @record{
  f_type: uint64,
  f_bsize: uint64,
  f_blocks: uint64,
  f_bfree: uint64,
  f_bavail: uint64,
  f_files: uint64,
  f_ffree: uint64,
  f_spare: [4]uint64
}
global uv_dirent_type_t: type <cimport,nodecl,using> = @enum(cint){
  UV_DIRENT_UNKNOWN = 0,
  UV_DIRENT_FILE = 1,
  UV_DIRENT_DIR = 2,
  UV_DIRENT_LINK = 3,
  UV_DIRENT_FIFO = 4,
  UV_DIRENT_SOCKET = 5,
  UV_DIRENT_CHAR = 6,
  UV_DIRENT_BLOCK = 7
}
uv_dirent_s = @record{
  name: cstring,
  type: uv_dirent_type_t
}
global function uv_setup_args(argc: cint, argv: *cstring): *cstring <cimport,nodecl> end
global function uv_get_process_title(buffer: cstring, size: csize): cint <cimport,nodecl> end
global function uv_set_process_title(title: cstring): cint <cimport,nodecl> end
global function uv_resident_set_memory(rss: *csize): cint <cimport,nodecl> end
global function uv_uptime(uptime: *float64): cint <cimport,nodecl> end
global function uv_get_osfhandle(fd: cint): uv_os_fd_t <cimport,nodecl> end
global function uv_open_osfhandle(os_fd: uv_os_fd_t): cint <cimport,nodecl> end
global uv_timeval_t: type <cimport,nodecl> = @record{
  tv_sec: clong,
  tv_usec: clong
}
global uv_timeval64_t: type <cimport,nodecl> = @record{
  tv_sec: int64,
  tv_usec: int32
}
global uv_rusage_t: type <cimport,nodecl> = @record{
  ru_utime: uv_timeval_t,
  ru_stime: uv_timeval_t,
  ru_maxrss: uint64,
  ru_ixrss: uint64,
  ru_idrss: uint64,
  ru_isrss: uint64,
  ru_minflt: uint64,
  ru_majflt: uint64,
  ru_nswap: uint64,
  ru_inblock: uint64,
  ru_oublock: uint64,
  ru_msgsnd: uint64,
  ru_msgrcv: uint64,
  ru_nsignals: uint64,
  ru_nvcsw: uint64,
  ru_nivcsw: uint64
}
global function uv_getrusage(rusage: *uv_rusage_t): cint <cimport,nodecl> end
global function uv_os_homedir(buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_os_tmpdir(buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_os_get_passwd(pwd: *uv_passwd_t): cint <cimport,nodecl> end
global function uv_os_free_passwd(pwd: *uv_passwd_t): void <cimport,nodecl> end
global function uv_os_getpid(): uv_pid_t <cimport,nodecl> end
global function uv_os_getppid(): uv_pid_t <cimport,nodecl> end
global function uv_os_getpriority(pid: uv_pid_t, priority: *cint): cint <cimport,nodecl> end
global function uv_os_setpriority(pid: uv_pid_t, priority: cint): cint <cimport,nodecl> end
global function uv_cpu_info(cpu_infos: **uv_cpu_info_t, count: *cint): cint <cimport,nodecl> end
global function uv_free_cpu_info(cpu_infos: *uv_cpu_info_t, count: cint): void <cimport,nodecl> end
global function uv_interface_addresses(addresses: **uv_interface_address_t, count: *cint): cint <cimport,nodecl> end
global function uv_free_interface_addresses(addresses: *uv_interface_address_t, count: cint): void <cimport,nodecl> end
uv_env_item_s = @record{
  name: cstring,
  value: cstring
}
global function uv_os_environ(envitems: **uv_env_item_t, count: *cint): cint <cimport,nodecl> end
global function uv_os_free_environ(envitems: *uv_env_item_t, count: cint): void <cimport,nodecl> end
global function uv_os_getenv(name: cstring, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_os_setenv(name: cstring, value: cstring): cint <cimport,nodecl> end
global function uv_os_unsetenv(name: cstring): cint <cimport,nodecl> end
global function uv_os_gethostname(buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_os_uname(buffer: *uv_utsname_t): cint <cimport,nodecl> end
global function uv_metrics_idle_time(loop: *uv_loop_t): uint64 <cimport,nodecl> end
global uv_fs_type: type <cimport,nodecl,using> = @enum(cint){
  UV_FS_UNKNOWN = -1,
  UV_FS_CUSTOM = 0,
  UV_FS_OPEN = 1,
  UV_FS_CLOSE = 2,
  UV_FS_READ = 3,
  UV_FS_WRITE = 4,
  UV_FS_SENDFILE = 5,
  UV_FS_STAT = 6,
  UV_FS_LSTAT = 7,
  UV_FS_FSTAT = 8,
  UV_FS_FTRUNCATE = 9,
  UV_FS_UTIME = 10,
  UV_FS_FUTIME = 11,
  UV_FS_ACCESS = 12,
  UV_FS_CHMOD = 13,
  UV_FS_FCHMOD = 14,
  UV_FS_FSYNC = 15,
  UV_FS_FDATASYNC = 16,
  UV_FS_UNLINK = 17,
  UV_FS_RMDIR = 18,
  UV_FS_MKDIR = 19,
  UV_FS_MKDTEMP = 20,
  UV_FS_RENAME = 21,
  UV_FS_SCANDIR = 22,
  UV_FS_LINK = 23,
  UV_FS_SYMLINK = 24,
  UV_FS_READLINK = 25,
  UV_FS_CHOWN = 26,
  UV_FS_FCHOWN = 27,
  UV_FS_REALPATH = 28,
  UV_FS_COPYFILE = 29,
  UV_FS_LCHOWN = 30,
  UV_FS_OPENDIR = 31,
  UV_FS_READDIR = 32,
  UV_FS_CLOSEDIR = 33,
  UV_FS_STATFS = 34,
  UV_FS_MKSTEMP = 35,
  UV_FS_LUTIME = 36
}
uv_dir_s = @record{
  dirents: *uv_dirent_t,
  nentries: csize,
  reserved: [4]pointer,
  dir: *DIR
}
uv_fs_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  fs_type: uv_fs_type,
  loop: *uv_loop_t,
  cb: uv_fs_cb,
  result: clong,
  ptr: pointer,
  path: cstring,
  statbuf: uv_stat_t,
  new_path: cstring,
  file: uv_file,
  flags: cint,
  mode: cuint,
  nbufs: cuint,
  bufs: *uv_buf_t,
  off: clong,
  uid: uv_uid_t,
  gid: uv_gid_t,
  atime: float64,
  mtime: float64,
  bufsml: [4]uv_buf_t
}
global function uv_fs_get_type(a1: *uv_fs_t): uv_fs_type <cimport,nodecl> end
global function uv_fs_get_result(a1: *uv_fs_t): clong <cimport,nodecl> end
global function uv_fs_get_system_error(a1: *uv_fs_t): cint <cimport,nodecl> end
global function uv_fs_get_ptr(a1: *uv_fs_t): pointer <cimport,nodecl> end
global function uv_fs_get_path(a1: *uv_fs_t): cstring <cimport,nodecl> end
global function uv_fs_get_statbuf(a1: *uv_fs_t): *uv_stat_t <cimport,nodecl> end
global function uv_fs_req_cleanup(req: *uv_fs_t): void <cimport,nodecl> end
global function uv_fs_close(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_open(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, flags: cint, mode: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_read(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, bufs: *uv_buf_t, nbufs: cuint, offset: int64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_unlink(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_write(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, bufs: *uv_buf_t, nbufs: cuint, offset: int64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_copyfile(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, new_path: cstring, flags: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_mkdir(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, mode: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_mkdtemp(loop: *uv_loop_t, req: *uv_fs_t, tpl: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_mkstemp(loop: *uv_loop_t, req: *uv_fs_t, tpl: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_rmdir(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_scandir(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, flags: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_scandir_next(req: *uv_fs_t, ent: *uv_dirent_t): cint <cimport,nodecl> end
global function uv_fs_opendir(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_readdir(loop: *uv_loop_t, req: *uv_fs_t, dir: *uv_dir_t, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_closedir(loop: *uv_loop_t, req: *uv_fs_t, dir: *uv_dir_t, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_stat(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_fstat(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_rename(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, new_path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_fsync(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_fdatasync(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_ftruncate(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, offset: int64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_sendfile(loop: *uv_loop_t, req: *uv_fs_t, out_fd: uv_file, in_fd: uv_file, in_offset: int64, length: csize, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_access(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, mode: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_chmod(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, mode: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_utime(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, atime: float64, mtime: float64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_futime(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, atime: float64, mtime: float64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_lutime(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, atime: float64, mtime: float64, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_lstat(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_link(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, new_path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_symlink(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, new_path: cstring, flags: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_readlink(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_realpath(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_fchmod(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, mode: cint, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_chown(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_fchown(loop: *uv_loop_t, req: *uv_fs_t, file: uv_file, uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_lchown(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb): cint <cimport,nodecl> end
global function uv_fs_statfs(loop: *uv_loop_t, req: *uv_fs_t, path: cstring, cb: uv_fs_cb): cint <cimport,nodecl> end
global uv_fs_event: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_RENAME = 1,
  UV_CHANGE = 2
}
uv_fs_event_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  path: cstring,
  cb: uv_fs_event_cb,
  watchers: [2]pointer,
  wd: cint
}
uv_fs_poll_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  poll_ctx: pointer
}
global function uv_fs_poll_init(loop: *uv_loop_t, handle: *uv_fs_poll_t): cint <cimport,nodecl> end
global function uv_fs_poll_start(handle: *uv_fs_poll_t, poll_cb: uv_fs_poll_cb, path: cstring, interval: cuint): cint <cimport,nodecl> end
global function uv_fs_poll_stop(handle: *uv_fs_poll_t): cint <cimport,nodecl> end
global function uv_fs_poll_getpath(handle: *uv_fs_poll_t, buffer: cstring, size: *csize): cint <cimport,nodecl> end
uv_signal_s = @record{
  data: pointer,
  loop: *uv_loop_t,
  type: uv_handle_type,
  close_cb: uv_close_cb,
  handle_queue: [2]pointer,
  u: union{
    fd: cint,
    reserved: [4]pointer
  },
  next_closing: *uv_handle_t,
  flags: cuint,
  signal_cb: uv_signal_cb,
  signum: cint,
  tree_entry: record{
    rbe_left: *uv_signal_s,
    rbe_right: *uv_signal_s,
    rbe_parent: *uv_signal_s,
    rbe_color: cint
  },
  caught_signals: cuint,
  dispatched_signals: cuint
}
global function uv_signal_init(loop: *uv_loop_t, handle: *uv_signal_t): cint <cimport,nodecl> end
global function uv_signal_start(handle: *uv_signal_t, signal_cb: uv_signal_cb, signum: cint): cint <cimport,nodecl> end
global function uv_signal_start_oneshot(handle: *uv_signal_t, signal_cb: uv_signal_cb, signum: cint): cint <cimport,nodecl> end
global function uv_signal_stop(handle: *uv_signal_t): cint <cimport,nodecl> end
global function uv_loadavg(avg: *float64): void <cimport,nodecl> end
global uv_fs_event_flags: type <cimport,nodecl,using,ctypedef> = @enum(cint){
  UV_FS_EVENT_WATCH_ENTRY = 1,
  UV_FS_EVENT_STAT = 2,
  UV_FS_EVENT_RECURSIVE = 4
}
global function uv_fs_event_init(loop: *uv_loop_t, handle: *uv_fs_event_t): cint <cimport,nodecl> end
global function uv_fs_event_start(handle: *uv_fs_event_t, cb: uv_fs_event_cb, path: cstring, flags: cuint): cint <cimport,nodecl> end
global function uv_fs_event_stop(handle: *uv_fs_event_t): cint <cimport,nodecl> end
global function uv_fs_event_getpath(handle: *uv_fs_event_t, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_ip4_addr(ip: cstring, port: cint, addr: *sockaddr_in): cint <cimport,nodecl> end
global function uv_ip6_addr(ip: cstring, port: cint, addr: *sockaddr_in6): cint <cimport,nodecl> end
global function uv_ip4_name(src: *sockaddr_in, dst: cstring, size: csize): cint <cimport,nodecl> end
global function uv_ip6_name(src: *sockaddr_in6, dst: cstring, size: csize): cint <cimport,nodecl> end
global function uv_ip_name(src: *sockaddr, dst: cstring, size: csize): cint <cimport,nodecl> end
global function uv_inet_ntop(af: cint, src: pointer, dst: cstring, size: csize): cint <cimport,nodecl> end
global function uv_inet_pton(af: cint, src: cstring, dst: pointer): cint <cimport,nodecl> end
uv_random_s = @record{
  data: pointer,
  type: uv_req_type,
  reserved: [6]pointer,
  loop: *uv_loop_t,
  status: cint,
  buf: pointer,
  buflen: csize,
  cb: uv_random_cb,
}
global function uv_random(loop: *uv_loop_t, req: *uv_random_t, buf: pointer, buflen: csize, flags: cuint, cb: uv_random_cb): cint <cimport,nodecl> end
global function uv_if_indextoname(ifindex: cuint, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_if_indextoiid(ifindex: cuint, buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_exepath(buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_cwd(buffer: cstring, size: *csize): cint <cimport,nodecl> end
global function uv_chdir(dir: cstring): cint <cimport,nodecl> end
global function uv_get_free_memory(): uint64 <cimport,nodecl> end
global function uv_get_total_memory(): uint64 <cimport,nodecl> end
global function uv_get_constrained_memory(): uint64 <cimport,nodecl> end
global function uv_hrtime(): uint64 <cimport,nodecl> end
global function uv_sleep(msec: cuint): void <cimport,nodecl> end
global function uv_disable_stdio_inheritance(): void <cimport,nodecl> end
global function uv_dlopen(filename: cstring, lib: *uv_lib_t): cint <cimport,nodecl> end
global function uv_dlclose(lib: *uv_lib_t): void <cimport,nodecl> end
global function uv_dlsym(lib: *uv_lib_t, name: cstring, ptr: *pointer): cint <cimport,nodecl> end
global function uv_dlerror(lib: *uv_lib_t): cstring <cimport,nodecl> end
global function uv_mutex_init(handle: *uv_mutex_t): cint <cimport,nodecl> end
global function uv_mutex_init_recursive(handle: *uv_mutex_t): cint <cimport,nodecl> end
global function uv_mutex_destroy(handle: *uv_mutex_t): void <cimport,nodecl> end
global function uv_mutex_lock(handle: *uv_mutex_t): void <cimport,nodecl> end
global function uv_mutex_trylock(handle: *uv_mutex_t): cint <cimport,nodecl> end
global function uv_mutex_unlock(handle: *uv_mutex_t): void <cimport,nodecl> end
global function uv_rwlock_init(rwlock: *uv_rwlock_t): cint <cimport,nodecl> end
global function uv_rwlock_destroy(rwlock: *uv_rwlock_t): void <cimport,nodecl> end
global function uv_rwlock_rdlock(rwlock: *uv_rwlock_t): void <cimport,nodecl> end
global function uv_rwlock_tryrdlock(rwlock: *uv_rwlock_t): cint <cimport,nodecl> end
global function uv_rwlock_rdunlock(rwlock: *uv_rwlock_t): void <cimport,nodecl> end
global function uv_rwlock_wrlock(rwlock: *uv_rwlock_t): void <cimport,nodecl> end
global function uv_rwlock_trywrlock(rwlock: *uv_rwlock_t): cint <cimport,nodecl> end
global function uv_rwlock_wrunlock(rwlock: *uv_rwlock_t): void <cimport,nodecl> end
global function uv_sem_init(sem: *uv_sem_t, value: cuint): cint <cimport,nodecl> end
global function uv_sem_destroy(sem: *uv_sem_t): void <cimport,nodecl> end
global function uv_sem_post(sem: *uv_sem_t): void <cimport,nodecl> end
global function uv_sem_wait(sem: *uv_sem_t): void <cimport,nodecl> end
global function uv_sem_trywait(sem: *uv_sem_t): cint <cimport,nodecl> end
global function uv_cond_init(cond: *uv_cond_t): cint <cimport,nodecl> end
global function uv_cond_destroy(cond: *uv_cond_t): void <cimport,nodecl> end
global function uv_cond_signal(cond: *uv_cond_t): void <cimport,nodecl> end
global function uv_cond_broadcast(cond: *uv_cond_t): void <cimport,nodecl> end
global function uv_barrier_init(barrier: *uv_barrier_t, count: cuint): cint <cimport,nodecl> end
global function uv_barrier_destroy(barrier: *uv_barrier_t): void <cimport,nodecl> end
global function uv_barrier_wait(barrier: *uv_barrier_t): cint <cimport,nodecl> end
global function uv_cond_wait(cond: *uv_cond_t, mutex: *uv_mutex_t): void <cimport,nodecl> end
global function uv_cond_timedwait(cond: *uv_cond_t, mutex: *uv_mutex_t, timeout: uint64): cint <cimport,nodecl> end
global function uv_once(guard: *uv_once_t, callback: function(): void): void <cimport,nodecl> end
global function uv_key_create(key: *uv_key_t): cint <cimport,nodecl> end
global function uv_key_delete(key: *uv_key_t): void <cimport,nodecl> end
global function uv_key_get(key: *uv_key_t): pointer <cimport,nodecl> end
global function uv_key_set(key: *uv_key_t, value: pointer): void <cimport,nodecl> end
global function uv_gettimeofday(tv: *uv_timeval64_t): cint <cimport,nodecl> end
global uv_thread_cb: type <cimport,nodecl> = @function(pointer): void
global function uv_thread_create(tid: *uv_thread_t, entry: uv_thread_cb, arg: pointer): cint <cimport,nodecl> end
global uv_thread_create_flags: type <cimport,nodecl,using> = @enum(cint){
  UV_THREAD_NO_FLAGS = 0,
  UV_THREAD_HAS_STACK_SIZE = 1
}
global uv_thread_options_s: type <cimport,nodecl,ctypedef> = @record{
  flags: cuint,
  stack_size: csize
}
global uv_thread_options_t: type = @uv_thread_options_s
global function uv_thread_create_ex(tid: *uv_thread_t, params: *uv_thread_options_t, entry: uv_thread_cb, arg: pointer): cint <cimport,nodecl> end
global function uv_thread_self(): uv_thread_t <cimport,nodecl> end
global function uv_thread_join(tid: *uv_thread_t): cint <cimport,nodecl> end
global function uv_thread_equal(t1: *uv_thread_t, t2: *uv_thread_t): cint <cimport,nodecl> end
global uv_any_handle: type <cimport,nodecl,ctypedef> = @union{
  async: uv_async_t,
  check: uv_check_t,
  fs_event: uv_fs_event_t,
  fs_poll: uv_fs_poll_t,
  handle: uv_handle_t,
  idle: uv_idle_t,
  pipe: uv_pipe_t,
  poll: uv_poll_t,
  prepare: uv_prepare_t,
  process: uv_process_t,
  stream: uv_stream_t,
  tcp: uv_tcp_t,
  timer: uv_timer_t,
  tty: uv_tty_t,
  udp: uv_udp_t,
  signal: uv_signal_t
}
global uv_any_req: type <cimport,nodecl,ctypedef> = @union{
  req: uv_req_t,
  connect: uv_connect_t,
  write: uv_write_t,
  shutdown: uv_shutdown_t,
  udp_send: uv_udp_send_t,
  fs: uv_fs_t,
  work: uv_work_t,
  getaddrinfo: uv_getaddrinfo_t,
  getnameinfo: uv_getnameinfo_t,
  random: uv_random_t
}
uv_loop_s = @record{
  data: pointer,
  active_handles: cuint,
  handle_queue: [2]pointer,
  active_reqs: union{
    unused: pointer,
    count: cuint
  },
  internal_fields: pointer,
  stop_flag: cuint,
  flags: culong,
  backend_fd: cint,
  pending_queue: [2]pointer,
  watcher_queue: [2]pointer,
  watchers: **uv__io_t,
  nwatchers: cuint,
  nfds: cuint,
  wq: [2]pointer,
  wq_mutex: uv_mutex_t,
  wq_async: uv_async_t,
  cloexec_lock: uv_rwlock_t,
  closing_handles: *uv_handle_t,
  process_handles: [2]pointer,
  prepare_handles: [2]pointer,
  check_handles: [2]pointer,
  idle_handles: [2]pointer,
  async_handles: [2]pointer,
  async_unused: function(): void,
  async_io_watcher: uv__io_t,
  async_wfd: cint,
  timer_heap: record{
    min: pointer,
    nelts: cuint
  },
  timer_counter: uint64,
  time: uint64,
  signal_pipefd: [2]cint,
  signal_io_watcher: uv__io_t,
  child_watcher: uv_signal_t,
  emfile_fd: cint,
  inotify_read_watcher: uv__io_t,
  inotify_watchers: pointer,
  inotify_fd: cint
}
global function uv_loop_get_data(a1: *uv_loop_t): pointer <cimport,nodecl> end
global function uv_loop_set_data(a1: *uv_loop_t, data: pointer): void <cimport,nodecl> end
